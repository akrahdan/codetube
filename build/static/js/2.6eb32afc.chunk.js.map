{"version":3,"sources":["../../src/utils/errors.ts","../../src/utils/common.ts","../../src/types/types-internal.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/immer.ts","../../src/utils/env.ts","../../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../src/utils/weak-maps.ts","../../src/create-editor.ts","../../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../src/utils/string.ts","../../src/interfaces/element.ts","../../src/interfaces/editor.ts","../../src/interfaces/location.ts","../../src/interfaces/node.ts","../../src/interfaces/operation.ts","../../src/interfaces/path.ts","../../src/interfaces/path-ref.ts","../../src/interfaces/point.ts","../../src/interfaces/point-ref.ts","../../src/interfaces/range.ts","../../src/interfaces/range-ref.ts","../../src/interfaces/text.ts","../../src/transforms/node.ts","../../src/transforms/selection.ts","../../src/transforms/text.ts","../../src/transforms/index.ts","../../src/transforms/general.ts","../node_modules/is-hotkey/lib/index.js","../node_modules/escape-html/index.js","../../src/history.ts","../../src/history-editor.ts","../../src/with-history.ts","../../src/tokens.ts","../../src/creators.ts","../../src/hyperscript.ts","../../src/index.ts","../node_modules/scroll-into-view-if-needed/es/index.js","../node_modules/slate-react/node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../../src/components/string.tsx","../../src/components/leaf.tsx","../../src/utils/environment.ts","../../src/hooks/use-isomorphic-layout-effect.ts","../../src/utils/range-list.ts","../../src/components/text.tsx","../../src/hooks/use-selected.ts","../../src/components/element.tsx","../../src/hooks/use-slate-static.tsx","../../src/hooks/use-decorate.ts","../../src/hooks/use-children.tsx","../../src/utils/hotkeys.ts","../../src/hooks/use-read-only.ts","../../src/hooks/use-slate.tsx","../../src/utils/dom.ts","../../src/components/editable.tsx","../../src/utils/key.ts","../../src/plugin/react-editor.ts","../../src/components/android/diff-text.ts","../../src/components/android/restore-dom.ts","../../src/components/android/android-input-manager.ts","../../src/components/android/mutation-detection.ts","../../src/components/android/use-android-input-manager.ts","../../src/components/android/use-track-user-input.ts","../../src/components/android/use-mutation-observer.ts","../../src/hooks/use-focused.ts","../../src/components/slate.tsx","../../src/utils/lines.ts","../../src/plugin/with-react.ts","../../src/components/android/android-editable.tsx","../node_modules/@emotion/css/create-instance/dist/emotion-css-create-instance.esm.js","../node_modules/@emotion/css/dist/emotion-css.esm.js","../node_modules/is-plain-object/index.es.js","../node_modules/lodash/isObject.js","../node_modules/lodash/_root.js","../node_modules/lodash/_Symbol.js","../node_modules/esrever/esrever.js","../node_modules/fast-deep-equal/index.js","../node_modules/direction/index.js","../node_modules/lodash/throttle.js","../node_modules/lodash/debounce.js","../node_modules/lodash/now.js","../node_modules/lodash/_freeGlobal.js","../node_modules/lodash/toNumber.js","../node_modules/lodash/_baseTrim.js","../node_modules/lodash/_trimmedEndIndex.js","../node_modules/lodash/isSymbol.js","../node_modules/lodash/_baseGetTag.js","../node_modules/lodash/_getRawTag.js","../node_modules/lodash/_objectToString.js","../node_modules/lodash/isObjectLike.js"],"names":["die","error","args","msg","Error","length","map","s","join","isDraft","value","DRAFT_STATE","isDraftable","proto","Object","getPrototypeOf","Ctor","hasOwnProperty","call","constructor","Function","toString","objectCtorString","Array","isArray","DRAFTABLE","isMap","isSet","each","obj","iter","enumerableOnly","getArchtype","keys","ownKeys","forEach","key","entry","index","thing","state","type_","has","prop","prototype","get","set","propOrOldValue","t","delete","add","is","x","y","target","hasMap","Map","hasSet","Set","latest","copy_","base_","shallowCopy","base","slice","descriptors","getOwnPropertyDescriptors","i","desc","writable","configurable","enumerable","create","freeze","deep","isFrozen","clear","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","getCurrentScope","currentScope","usePatchesInScope","scope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","result","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","path","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","res","assigned_","concat","undefined","autoFreeze_","peek","getDescriptorFromProto","source","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","parent","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","push","copyHelper","archType","from","hasSymbol","Symbol","hasProxies","Reflect","for","iterator","getOwnPropertySymbols","getOwnPropertyNames","current","currentState","deleteProperty","owner","defineProperty","setPrototypeOf","fn","arguments","apply","this","e","config","recipe","defaultBase","self","_this","produce","_this2","hasError","Promise","then","arg1","arg2","produceWithPatches","p","ip","patches","inversePatches","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","currentImpl","copy","hasChanges_","finishDraft","applyPatches","patch","op","applyPatchesImpl","applyPatches_","bind","_defineProperty","DIRTY_PATHS","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","createEditor","editor","children","operations","selection","marks","isInline","isVoid","onChange","Editor","PathRef","PointRef","RangeRef","dirtyPaths","oldDirtyPaths","newDirtyPaths","getDirtyPaths","Path","Transforms","addMark","Range","match","Text","split","deleteBackward","unit","reverse","deleteForward","deleteFragment","direction","getFragment","Node","insertBreak","always","insertFragment","fragment","insertNode","node","insertText","text","inline","n","mode","point","anchor","focus","normalizeNode","Element","at","voids","shouldHaveInlines","currentNode","child","prev","isLast","loose","removeMark","levels","descendants","ancestors","previousPath","newPath","oldAncestors","newAncestors","newParent","newIndex","resultPath","nextPath","_objectWithoutProperties","excluded","sourceKeys","indexOf","objectWithoutPropertiesLoose","sourceSymbolKeys","propertyIsEnumerable","SPACE","PUNCTUATION","CHAMELEON","getCharacterDistance","offset","charCode","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","started","char","l","rest","isWordCharacter","next","remaining","code","SURROGATE_START","isAncestor","isPlainObject","isElement","isElementList","val","isElementProps","props","matches","element","IS_EDITOR_CACHE","above","options","after","edge","range","distance","d","before","edges","end","first","hasBlocks","hasInlines","hasTexts","isBlock","isEditor","cachedIsEditor","Operation","isEnd","Point","isEdge","isEmpty","isNormalizing","isStart","start","last","leaf","isText","block","pointAfterLocation","span","universal","Span","to","nodeEntries","pass","isLower","hit","emit","normalize","force","allPaths","dirtyPath","max","m","parentPath","depth","hasPath","pathRef","affinity","ref","unref","pathRefs","refs","pointRef","pointRefs","isNewBlock","blockText","leafTextRemaining","leafTextOffset","reverseText","isFirst","calcDistance","previous","pointBeforeLocation","rangeRef","rangeRefs","string","unhangRange","endBlock","blockPath","skip","void","withoutNormalizing","isSpan","IS_NODE_LIST_CACHE","ancestor","JSON","c","root","childPath","common","descendant","extractProps","r","isNode","isNodeList","cachedResult","visited","nextIndex","isNodeOperation","isOperation","isOperationList","isSelectionOperation","isTextOperation","inverse","type","inversePath","inverseNewPath","newProperties","properties","paths","another","av","compare","min","Math","endsAfter","as","bs","bv","endsAt","endsBefore","equals","hasPrevious","isAfter","isBefore","isChild","isCommon","isDescendant","isParent","isPath","isSibling","list","relative","transform","operation","position","onp","isPoint","includes","isAfterStart","isBeforeEnd","intersection","isBackward","isCollapsed","isExpanded","isForward","isRange","affinityAnchor","affinityFocus","isEqual","omitText","isTextList","isTextProps","decorations","leaves","o","middle","off","NodeTransforms","insertNodes","hanging","select","nodes","isAtEnd","liftNodes","matchPath","parentNodeEntry","toPath","splitPath","mergeNodes","prevPath","commonPath","isPreviousSibling","emptyAncestor","hasSingleChildNest","emptyRef","prevNode","moveNodes","toRef","targets","removeNodes","depths","setNodes","splitMode","endAtEndOfNode","startAtStartOfNode","k","splitNodes","height","deleteRange","beforeRef","voidMatch","afterPath","voidPath","afterRef","lowestPath","highestPath","unsetNodes","unwrapNodes","wrapNodes","a","commonNodeEntry","wrapperPath","lastPath","wrapper","commonNode","SelectionTransforms","collapse","deselect","move","opts","setPoint","setSelection","oldProps","newProps","TextTransforms","furthestVoid","endOfDoc","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","isInlineStart","isInlineEnd","middleRef","truePath","newNode","applyToDraft","exports","IS_MAC","window","test","navigator","platform","MODIFIERS","alt","control","meta","shift","ALIASES","break","cmd","command","ctl","ctrl","del","down","esc","ins","left","mod","opt","option","return","right","space","spacebar","up","win","windows","CODES","backspace","tab","enter","pause","capslock","escape","pageup","pagedown","home","arrowleft","arrowup","arrowright","arrowdown","insert","numlock","scrolllock","'","f","isHotkey","hotkey","event","array","parseHotkey","check","some","object","compareHotkey","byKey","ret","values","replace","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","done","optional","endsWith","name","toKeyName","which","toKeyCode","err","expected","actual","toLowerCase","toUpperCase","charCodeAt","default","isCodeHotkey","isKeyHotkey","matchHtmlRegExp","module","str","exec","html","lastIndex","substring","History","SAVING","WeakMap","MERGING","HistoryEditor","isHistoryEditor","isMerging","isSaving","redo","undo","withoutMerging","withoutSaving","withHistory","undos","redos","history","batch","inverseOps","lastBatch","lastOp","overwrite","shouldOverwrite","save","merge","shouldSave","shouldMerge","shouldClear","ANCHOR","FOCUS","Token","AnchorToken","FocusToken","getFocusOffset","STRINGS","resolveDescendants","addChild","addAnchorToken","addFocusToken","createElement","tagName","attributes","DEFAULT_CREATORS","cursor","otherChildren","selectionChild","makeEditor","createFactory","creators","creator","Boolean","normalizeElements","elements","jsx","elementCreators","createHyperscript","el","nodeType","canOverflow","overflow","skipOverflowHiddenElements","isScrollable","clientHeight","scrollHeight","clientWidth","scrollWidth","style","getComputedStyle","overflowY","overflowX","frame","ownerDocument","defaultView","frameElement","alignNearest","scrollingEdgeStart","scrollingEdgeEnd","scrollingSize","scrollingBorderStart","scrollingBorderEnd","elementEdgeStart","elementEdgeEnd","elementSize","windowWithViewport","scrollMode","boundary","checkBoundary","TypeError","scrollingElement","document","documentElement","frames","parentElement","body","viewportWidth","visualViewport","width","innerWidth","viewportHeight","innerHeight","viewportX","scrollX","pageXOffset","viewportY","scrollY","pageYOffset","getBoundingClientRect","targetHeight","targetWidth","targetTop","top","targetRight","targetBottom","bottom","targetLeft","targetBlock","targetInline","computations","frameStyle","borderLeft","parseInt","borderLeftWidth","borderTop","borderTopWidth","borderRight","borderRightWidth","borderBottom","borderBottomWidth","blockScroll","inlineScroll","scrollbarWidth","offsetWidth","scrollbarHeight","offsetHeight","scrollLeft","scrollTop","isOptionsObject","scrollIntoView","targetIsDetached","contains","behavior","compute","computeOptions","getOptions","actions","canSmoothScroll","_ref","scroll","defaultBehavior","prefix","invariant","condition","message","String","useSlateStatic","ReactEditor","React","isTrailing","isLineBreak","TextString","ZeroWidthString","NODE_TO_INDEX","NODE_TO_PARENT","EDITOR_TO_WINDOW","EDITOR_TO_ELEMENT","ELEMENT_TO_NODE","KEY_TO_ELEMENT","NODE_TO_ELEMENT","NODE_TO_KEY","IS_READ_ONLY","IS_FOCUSED","EDITOR_TO_ON_CHANGE","EDITOR_TO_RESTORE_DOM","PLACEHOLDER_SYMBOL","keyForString","Leaf","renderLeaf","placeholderRef","useRef","useEffect","placeholderEl","editorEl","placeholderProps","pointerEvents","maxWidth","display","opacity","userSelect","textDecoration","contentEditable","renderPlaceholder","MemoizedLeaf","DefaultLeaf","IS_APPLE","IS_ANDROID","IS_FIREFOX","IS_SAFARI","IS_EDGE_LEGACY","IS_CHROME","IS_CHROME_LEGACY","IS_FIREFOX_LEGACY","CAN_USE_DOM","HAS_BEFORE_INPUT_SUPPORT","globalThis","useIsomorphicLayoutEffect","shallowCompare","obj1","obj2","isDecoratorRangeListEqual","other","rangeOwnProps","otherOwnProps","SlateText","MemoizedText","SelectedContext","createContext","renderElement","readOnly","useReadOnly","useChildren","dir","getDirection","Tag","color","outline","MemoizedElement","DefaultElement","EditorContext","useContext","DecorateContext","decorate","isLeafBlock","sel","ds","id","HOTKEYS","bold","compose","moveBackward","moveForward","moveWordBackward","moveWordForward","extendBackward","extendForward","italic","splitBlock","APPLE_HOTKEYS","moveLineBackward","moveLineForward","deleteLineBackward","deleteLineForward","deleteWordBackward","deleteWordForward","extendLineBackward","extendLineForward","transposeCharacter","WINDOWS_HOTKEYS","generic","apple","isGeneric","isApple","isWindows","isBold","isCompose","isMoveBackward","isMoveForward","isDeleteBackward","isDeleteForward","isDeleteLineBackward","isDeleteLineForward","isDeleteWordBackward","isDeleteWordForward","isExtendBackward","isExtendForward","isExtendLineBackward","isExtendLineForward","isItalic","isMoveLineBackward","isMoveLineForward","isMoveWordBackward","isMoveWordForward","isRedo","isSplitBlock","isTransposeCharacter","isUndo","ReadOnlyContext","SlateContext","useSlate","context","getDefaultView","isDOMElement","isDOMNode","isDOMSelection","isDOMText","getEditableChildAndIndex","childNodes","triedForward","triedBackward","isDOMComment","getEditableChild","getPlainText","domNode","DefaultPlaceholder","defaultDecorate","hasTarget","hasEditableTarget","editable","isTargetInsideVoid","slateNode","isEventHandled","shouldTreatEventAsHandled","handler","isDOMEventHandled","Key","getWindow","findKey","findPath","findDocumentOrShadowRoot","isFocused","isReadOnly","blur","preventScroll","domSelection","hasDOMNode","targetEl","insertData","setFragmentData","toDOMNode","toDOMPoint","attr","domPoint","toDOMRange","domAnchor","domFocus","domRange","isStartAtZeroWidth","startNode","startEl","isEndAtZeroWidth","endNode","endEl","toSlateNode","domEl","findEventRange","clientX","clientY","rect","isPrev","exactMatch","toSlatePoint","normalizeDOMPoint","parentNode","nearestNode","textNode","voidNode","leafNode","contents","removals","toSlateRange","anchorNode","anchorOffset","focusNode","focusOffset","hasRange","getDiffOffsets","getDiffStart","prevLength","nextLength","getDiffEnd","sliceText","offsets","getTextInsertion","prevText","nextText","textDiff","removeText","diffText","normalizeTextInsertionRange","insertionRange","characterBeforeAnchor","characterAfterAnchor","restoreDOM","onRestoreDOM","console","AndroidInputManager","flush","mutations","reconcileMutations","mutationData","addedNodes","removedNodes","insertedText","characterDataMutations","mutation","addedNode","removedNode","textInsertion","gatherMutationData","isReplaceExpandedSelection","combineInsertedText","parentDOMNode","isRemoveLeafNodes","insertion","setTimeout","replaceExpandedSelection","removeLeafNodes","MUTATION_OBSERVER_CONFIG","childList","characterData","characterDataOldValue","subtree","useAndroidInputManager","useState","receivedUserInput","animationFrameRef","onUserInput","useCallback","useTrackUserInput","timeoutId","isReconciling","callback","MutationObserver","mutationObserver","useMutationObserver","inputManager","clearTimeout","FocusedContext","Slate","useMemo","onContextChange","setKey","setIsFocused","doRectsIntersect","compareRect","areRangesSameLine","rect1","rect2","withReact","parentBlockEntry","parentElementRange","currentLineRange","parentRangeBoundary","positions","parentRange","findCurrentLineRange","data","attach","zw","isNewline","encoded","encodeURIComponent","div","decoded","decodeURIComponent","parsed","lines","ReactDOM","Editable","onDOMBeforeInput","Component","isUpdatingSelection","latestElement","setContentKey","hasDomSelection","editorElement","hasDomSelectionInEditor","slateRange","newDomRange","leafEl","contentKey","onDOMSelectionChange","throttle","activeElement","anchorNodeSelectable","focusNodeSelectable","placeholder","role","spellCheck","autoCorrect","autoCapitalize","suppressContentEditableWarning","whiteSpace","wordWrap","onCopy","onCut","onFocus","onBlur","relatedTarget","onPaste","isComposing","isDraggingInternally","inputType","onBeforeInput","onClick","onCompositionEnd","onCompositionUpdate","onCompositionStart","onDragOver","onDragStart","onDrop","draggedRange","onDragEnd","onKeyDown","nativeEvent","isRTL","Hotkeys","maybeHistoryEditor","isPlainTextOnlyPaste","insertWithoutScoping","cache","serialized","inserted","sheet","registered","css","className","registeredStyles","rawClassName","getRegisteredStyles","classnames","cls","arg","toAdd","_createEmotion","createCache","speedy","isSpeedy","compat","_len","_key","serializeStyles","insertStyles","cx","_len4","_key4","injectGlobal","_len3","_key3","keyframes","_len2","_key2","animation","styles","hydrate","ids","createEmotion","isObjectObject","ctor","prot","freeGlobal","require","freeSelf","freeExports","global","regexSymbolWithCombiningMarks","regexSurrogatePair","esrever","$0","$1","$2","charAt","define","equal","b","RegExp","flags","valueOf","rtl","ltr","RTL","LTR","debounce","isObject","func","wait","leading","trailing","now","toNumber","nativeMax","nativeMin","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","maxing","invokeFunc","time","thisArg","leadingEdge","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","timeWaiting","remainingWait","debounced","isInvoking","cancel","Date","baseTrim","isSymbol","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","isBinary","trimmedEndIndex","reTrimStart","reWhitespace","baseGetTag","isObjectLike","getRawTag","objectToString","symToStringTag","toStringTag","objectProto","nativeObjectToString","isOwn","tag","unmasked"],"mappings":"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","file":"static/js/2.6eb32afc.chunk.js","sourcesContent":["const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtypeObject,\n\tArchtypeArray,\n\tArchtypeMap,\n\tArchtypeSet,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === ArchtypeObject) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? ArchtypeArray\n\t\t: isMap(thing)\n\t\t? ArchtypeMap\n\t\t: isSet(thing)\n\t\t? ArchtypeSet\n\t\t: ArchtypeObject\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchtypeMap\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\n\telse if (t === ArchtypeSet) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"../internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\n\nexport const ArchtypeObject = 0\nexport const ArchtypeArray = 1\nexport const ArchtypeMap = 2\nexport const ArchtypeSet = 3\n\nexport const ProxyTypeProxyObject = 0\nexport const ProxyTypeProxyArray = 1\nexport const ProxyTypeES5Object = 4\nexport const ProxyTypeES5Array = 5\nexport const ProxyTypeMap = 2\nexport const ProxyTypeSet = 3\n\nexport interface ImmerBaseState {\n\tparent_?: ImmerState\n\tscope_: ImmerScope\n\tmodified_: boolean\n\tfinalized_: boolean\n\tisManual_: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tProxyTypeMap,\n\tProxyTypeSet,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeMap\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeSet\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyTypeProxyObject ||\n\t\tstate.type_ === ProxyTypeProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyTypeES5Object,\n\tProxyTypeES5Array,\n\tProxyTypeSet,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumarable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyTypeSet ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existig to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (state.copy_![prop] === value && typeof value !== \"number\") return true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyTypeProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches.slice(i + 1))\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtypeMap,\n\tArchtypeSet,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === ArchtypeSet ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase ArchtypeMap:\n\t\t\treturn new Map(value)\n\t\tcase ArchtypeSet:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Node, Ancestor, Editor, Range } from 'slate'\n\nimport { Key } from './key'\n\n/**\n * Two weak maps that allow us rebuild a path given a node. They are populated\n * at render time such that after a render occurs we can always backtrack.\n */\n\nexport const NODE_TO_INDEX: WeakMap<Node, number> = new WeakMap()\nexport const NODE_TO_PARENT: WeakMap<Node, Ancestor> = new WeakMap()\n\n/**\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\n * are used to resolve DOM event-related logic into Slate actions.\n */\nexport const EDITOR_TO_WINDOW: WeakMap<Editor, Window> = new WeakMap()\nexport const EDITOR_TO_ELEMENT: WeakMap<Editor, HTMLElement> = new WeakMap()\nexport const EDITOR_TO_PLACEHOLDER: WeakMap<Editor, string> = new WeakMap()\nexport const ELEMENT_TO_NODE: WeakMap<HTMLElement, Node> = new WeakMap()\nexport const KEY_TO_ELEMENT: WeakMap<Key, HTMLElement> = new WeakMap()\nexport const NODE_TO_ELEMENT: WeakMap<Node, HTMLElement> = new WeakMap()\nexport const NODE_TO_KEY: WeakMap<Node, Key> = new WeakMap()\n\n/**\n * Weak maps for storing editor-related state.\n */\n\nexport const IS_READ_ONLY: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_FOCUSED: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_DRAGGING: WeakMap<Editor, boolean> = new WeakMap()\nexport const IS_CLICKING: WeakMap<Editor, boolean> = new WeakMap()\n\n/**\n * Weak map for associating the context `onChange` context with the plugin.\n */\n\nexport const EDITOR_TO_ON_CHANGE = new WeakMap<Editor, () => void>()\n\nexport const EDITOR_TO_RESTORE_DOM = new WeakMap<Editor, () => void>()\n\n/**\n * Symbols.\n */\n\nexport const PLACEHOLDER_SYMBOL = (Symbol('placeholder') as unknown) as string\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Transforms.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: (direction?: 'forward' | 'backward') => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, { reverse: direction === 'backward' })\n      }\n    },\n\n    getFragment: () => {\n      const { selection } = editor\n\n      if (selection) {\n        return Node.fragment(editor, selection)\n      }\n      return []\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const currentNode = Node.get(editor, path)\n        if (Text.isText(currentNode)) continue\n        const child = node.children[i] as Descendant\n        const prev = currentNode.children[n - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation): Path[] => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      const newParent = newAncestors[newAncestors.length - 1]\n      const newIndex = newPath[newPath.length - 1]\n      const resultPath = newParent.concat(newIndex)\n\n      return [...oldAncestors, ...newAncestors, resultPath]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path, Descendant, ExtendedType, Ancestor } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface BaseElement {\n  children: Descendant[]\n}\n\nexport type Element = ExtendedType<'Element', BaseElement>\n\nexport interface ElementInterface {\n  isAncestor: (value: any) => value is Ancestor\n  isElement: (value: any) => value is Element\n  isElementList: (value: any) => value is Element[]\n  isElementProps: (props: any) => props is Partial<Element>\n  matches: (element: Element, props: Partial<Element>) => boolean\n}\n\nexport const Element: ElementInterface = {\n  /**\n   * Check if a value implements the 'Ancestor' interface.\n   */\n\n  isAncestor(value: any): value is Ancestor {\n    return isPlainObject(value) && Node.isNodeList(value.children)\n  },\n\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return Array.isArray(value) && value.every(val => Element.isElement(val))\n  },\n\n  /**\n   * Check if a set of props is a partial of Element.\n   */\n\n  isElementProps(props: any): props is Partial<Element> {\n    return (props as Partial<Element>).children !== undefined\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import isPlainObject from 'is-plain-object'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  ExtendedType,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n  Transforms,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\nimport { Descendant } from './node'\nimport { Element } from './element'\n\nexport type BaseSelection = Range | null\n\nexport type Selection = ExtendedType<'Selection', BaseSelection>\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface BaseEditor {\n  children: Descendant[]\n  selection: Selection\n  operations: Operation[]\n  marks: Omit<Text, 'text'> | null\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: (direction?: 'forward' | 'backward') => void\n  getFragment: () => Descendant[]\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport type Editor = ExtendedType<'Editor', BaseEditor>\n\nexport interface EditorInterface {\n  above: <T extends Ancestor>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  addMark: (editor: Editor, key: string, value: any) => void\n  after: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  before: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  deleteBackward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteForward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteFragment: (\n    editor: Editor,\n    options?: {\n      direction?: 'forward' | 'backward'\n    }\n  ) => void\n  edges: (editor: Editor, at: Location) => [Point, Point]\n  end: (editor: Editor, at: Location) => Point\n  first: (editor: Editor, at: Location) => NodeEntry\n  fragment: (editor: Editor, at: Location) => Descendant[]\n  hasBlocks: (editor: Editor, element: Element) => boolean\n  hasInlines: (editor: Editor, element: Element) => boolean\n  hasPath: (editor: Editor, path: Path) => boolean\n  hasTexts: (editor: Editor, element: Element) => boolean\n  insertBreak: (editor: Editor) => void\n  insertFragment: (editor: Editor, fragment: Node[]) => void\n  insertNode: (editor: Editor, node: Node) => void\n  insertText: (editor: Editor, text: string) => void\n  isBlock: (editor: Editor, value: any) => value is Element\n  isEditor: (value: any) => value is Editor\n  isEnd: (editor: Editor, point: Point, at: Location) => boolean\n  isEdge: (editor: Editor, point: Point, at: Location) => boolean\n  isEmpty: (editor: Editor, element: Element) => boolean\n  isInline: (editor: Editor, value: any) => value is Element\n  isNormalizing: (editor: Editor) => boolean\n  isStart: (editor: Editor, point: Point, at: Location) => boolean\n  isVoid: (editor: Editor, value: any) => value is Element\n  last: (editor: Editor, at: Location) => NodeEntry\n  leaf: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Text>\n  levels: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  marks: (editor: Editor) => Omit<Text, 'text'> | null\n  next: <T extends Descendant>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  node: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry\n  nodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  normalize: (\n    editor: Editor,\n    options?: {\n      force?: boolean\n    }\n  ) => void\n  parent: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Ancestor>\n  path: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => Path\n  pathRef: (\n    editor: Editor,\n    path: Path,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PathRef\n  pathRefs: (editor: Editor) => Set<PathRef>\n  point: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      edge?: 'start' | 'end'\n    }\n  ) => Point\n  pointRef: (\n    editor: Editor,\n    point: Point,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PointRef\n  pointRefs: (editor: Editor) => Set<PointRef>\n  positions: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<Point, void, undefined>\n  previous: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  range: (editor: Editor, at: Location, to?: Location) => Range\n  rangeRef: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    }\n  ) => RangeRef\n  rangeRefs: (editor: Editor) => Set<RangeRef>\n  removeMark: (editor: Editor, key: string) => void\n  start: (editor: Editor, at: Location) => Point\n  string: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      voids?: boolean\n    }\n  ) => string\n  unhangRange: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      voids?: boolean\n    }\n  ) => Range\n  void: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<Element> | undefined\n  withoutNormalizing: (editor: Editor, fn: () => void) => void\n}\n\nconst IS_EDITOR_CACHE = new WeakMap<object, boolean>()\n\nexport const Editor: EditorInterface = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(\n    editor: Editor,\n    options: {\n      direction?: 'forward' | 'backward'\n    } = {}\n  ): void {\n    const { direction = 'forward' } = options\n    editor.deleteFragment(direction)\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    if (!isPlainObject(value)) return false\n    const cachedIsEditor = IS_EDITOR_CACHE.get(value)\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor\n    }\n    const isEditor =\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    IS_EDITOR_CACHE.set(value, isEditor)\n    return isEditor\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Omit<Text, 'text'> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Descendant>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointAfterLocation = Editor.after(editor, at, { voids })\n\n    if (!pointAfterLocation) return\n\n    const [, to] = Editor.last(editor, [])\n\n    const span: Span = [pointAfterLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of nodeEntries) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ): void {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      /*\n        Fix dirty elements with no children.\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n        Running an initial pass avoids the catch-22 race condition.\n      */\n      for (const dirtyPath of getDirtyPaths(editor)) {\n        if (Node.has(editor, dirtyPath)) {\n          const [node, _] = Editor.node(editor, dirtyPath)\n\n          // Add a text child to elements with no children.\n          // This is safe to do in any order, by definition it can't cause other paths to change.\n          if (Element.isElement(node) && node.children.length === 0) {\n            const child = { text: '' }\n            Transforms.insertNodes(editor, child, {\n              at: dirtyPath.concat(0),\n              voids: true,\n            })\n          }\n        }\n      }\n\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const dirtyPath = getDirtyPaths(editor).pop()!\n\n        // If the node doesn't exist in the tree, it does not need to be normalized.\n        if (Node.has(editor, dirtyPath)) {\n          const entry = Editor.node(editor, dirtyPath)\n          editor.normalizeNode(entry)\n        }\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  hasPath(editor: Editor, path: Path): boolean {\n    return Node.has(editor, path)\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Return all the positions in `at` range where a `Point` can be placed.\n   *\n   * By default, moves forward by individual offsets at a time, but\n   * the `unit` option can be used to to move by character, word, line, or block.\n   *\n   * The `reverse` option can be used to change iteration direction.\n   *\n   * Note: By default void nodes are treated as a single point and iteration\n   * will not happen inside their content unless you pass in true for the\n   * `voids` option, then iteration will occur.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<Point, void, undefined> {\n    const {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let isNewBlock = false\n    let blockText = ''\n    let distance = 0 // Distance for leafText to catch up to blockText.\n    let leafTextRemaining = 0\n    let leafTextOffset = 0\n\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    for (const [node, path] of Editor.nodes(editor, { at, reverse, voids })) {\n      /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n        if (editor.isInline(node)) continue\n\n        // Block element node - set `blockText` to its text content.\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          blockText = Editor.string(editor, { anchor: s, focus: e }, { voids })\n          blockText = reverse ? reverseText(blockText) : blockText\n          isNewBlock = true\n        }\n      }\n\n      /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n\n        // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n\n        // Reset `leafText` counters for new text node.\n        if (isFirst) {\n          leafTextRemaining = reverse\n            ? first.offset\n            : node.text.length - first.offset\n          leafTextOffset = first.offset // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length\n          leafTextOffset = reverse ? leafTextRemaining : 0\n        }\n\n        // Yield position at the start of node (potentially).\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset: leafTextOffset }\n          isNewBlock = false\n        }\n\n        // Yield positions every (dynamically calculated) `distance` offset.\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break\n            distance = calcDistance(blockText, unit)\n            blockText = blockText.slice(distance)\n          }\n\n          // Advance `leafText` by the current `distance`.\n          leafTextOffset = reverse\n            ? leafTextOffset - distance\n            : leafTextOffset + distance\n          leafTextRemaining = leafTextRemaining - distance\n\n          // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining\n            break\n          }\n\n          // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n          distance = 0\n          yield { path, offset: leafTextOffset }\n        }\n      }\n    }\n    // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text: string, unit: string) {\n      if (unit === 'character') {\n        return getCharacterDistance(text)\n      } else if (unit === 'word') {\n        return getWordDistance(text)\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length\n      }\n      return 1\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointBeforeLocation = Editor.before(editor, at, { voids })\n\n    if (!pointBeforeLocation) {\n      return\n    }\n\n    const [, to] = Editor.first(editor, [])\n\n    // The search location is from the start of the document to the path of\n    // the point before the location passed in\n    const span: Span = [pointBeforeLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: by default the text of void nodes is considered to be an empty\n   * string, regardless of content, unless you pass in true for the voids option\n   */\n\n  string(\n    editor: Editor,\n    at: Location,\n    options: {\n      voids?: boolean\n    } = {}\n  ): string {\n    const { voids = false } = options\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    try {\n      fn()\n    } finally {\n      NORMALIZING.set(editor, value)\n    }\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\nexport type NodeMatch<T extends Node> =\n  | ((node: Node, path: Path) => node is T)\n  | ((node: Node, path: Path) => boolean)\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport interface LocationInterface {\n  isLocation: (value: any) => value is Location\n}\n\nexport const Location: LocationInterface = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport interface SpanInterface {\n  isSpan: (value: any) => value is Span\n}\n\nexport const Span: SpanInterface = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Path, Range, Text } from '..'\nimport { Element, ElementEntry } from './element'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type BaseNode = Editor | Element | Text\nexport type Node = Editor | Element | Text\n\nexport interface NodeInterface {\n  ancestor: (root: Node, path: Path) => Ancestor\n  ancestors: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Ancestor>, void, undefined>\n  child: (root: Node, index: number) => Descendant\n  children: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  common: (root: Node, path: Path, another: Path) => NodeEntry\n  descendant: (root: Node, path: Path) => Descendant\n  descendants: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  elements: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<ElementEntry, void, undefined>\n  extractProps: (node: Node) => NodeProps\n  first: (root: Node, path: Path) => NodeEntry\n  fragment: (root: Node, range: Range) => Descendant[]\n  get: (root: Node, path: Path) => Node\n  has: (root: Node, path: Path) => boolean\n  isNode: (value: any) => value is Node\n  isNodeList: (value: any) => value is Node[]\n  last: (root: Node, path: Path) => NodeEntry\n  leaf: (root: Node, path: Path) => Text\n  levels: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  matches: (node: Node, props: Partial<Node>) => boolean\n  nodes: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  parent: (root: Node, path: Path) => Ancestor\n  string: (node: Node) => string\n  texts: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Text>, void, undefined>\n}\n\nconst IS_NODE_LIST_CACHE = new WeakMap<any[], boolean>()\n\nexport const Node: NodeInterface = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Ancestor>, void, undefined> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<ElementEntry, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Extract props from a Node.\n   */\n\n  extractProps(node: Node): NodeProps {\n    if (Element.isAncestor(node)) {\n      const { children, ...properties } = node\n\n      return properties\n    } else {\n      const { text, ...properties } = node\n\n      return properties\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce({ children: root.children }, r => {\n      const [start, end] = Range.edges(range)\n      const nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null\n      }\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    if (!Array.isArray(value)) {\n      return false\n    }\n    const cachedResult = IS_NODE_LIST_CACHE.get(value)\n    if (cachedResult !== undefined) {\n      return cachedResult\n    }\n    const isNodeList = value.every(val => Node.isNode(val))\n    IS_NODE_LIST_CACHE.set(value, isNodeList)\n    return isNodeList\n  },\n\n  /**\n   * Get the last node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) &&\n        Element.isElementProps(props) &&\n        Element.matches(node, props)) ||\n      (Text.isText(node) &&\n        Text.isTextProps(props) &&\n        Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't descended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Text>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n\n/**\n * Convenience type for returning the props of a node.\n */\nexport type NodeProps =\n  | Omit<Editor, 'children'>\n  | Omit<Element, 'children'>\n  | Omit<Text, 'text'>\n","import { ExtendedType, Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type BaseInsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n}\n\nexport type InsertNodeOperation = ExtendedType<\n  'InsertNodeOperation',\n  BaseInsertNodeOperation\n>\n\nexport type BaseInsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type InsertTextOperation = ExtendedType<\n  'InsertTextOperation',\n  BaseInsertTextOperation\n>\n\nexport type BaseMergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type MergeNodeOperation = ExtendedType<\n  'MergeNodeOperation',\n  BaseMergeNodeOperation\n>\n\nexport type BaseMoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n}\n\nexport type MoveNodeOperation = ExtendedType<\n  'MoveNodeOperation',\n  BaseMoveNodeOperation\n>\n\nexport type BaseRemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n}\n\nexport type RemoveNodeOperation = ExtendedType<\n  'RemoveNodeOperation',\n  BaseRemoveNodeOperation\n>\n\nexport type BaseRemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type RemoveTextOperation = ExtendedType<\n  'RemoveTextOperation',\n  BaseRemoveTextOperation\n>\n\nexport type BaseSetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n}\n\nexport type SetNodeOperation = ExtendedType<\n  'SetNodeOperation',\n  BaseSetNodeOperation\n>\n\nexport type BaseSetSelectionOperation =\n  | {\n      type: 'set_selection'\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      properties: Range\n      newProperties: null\n    }\n\nexport type SetSelectionOperation = ExtendedType<\n  'SetSelectionOperation',\n  BaseSetSelectionOperation\n>\n\nexport type BaseSplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type SplitNodeOperation = ExtendedType<\n  'SplitNodeOperation',\n  BaseSplitNodeOperation\n>\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport interface OperationInterface {\n  isNodeOperation: (value: any) => value is NodeOperation\n  isOperation: (value: any) => value is Operation\n  isOperationList: (value: any) => value is Operation[]\n  isSelectionOperation: (value: any) => value is SelectionOperation\n  isTextOperation: (value: any) => value is TextOperation\n  inverse: (op: Operation) => Operation\n}\n\nexport const Operation: OperationInterface = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) && value.every(val => Operation.isOperation(val))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport interface PathInterface {\n  ancestors: (path: Path, options?: { reverse?: boolean }) => Path[]\n  common: (path: Path, another: Path) => Path\n  compare: (path: Path, another: Path) => -1 | 0 | 1\n  endsAfter: (path: Path, another: Path) => boolean\n  endsAt: (path: Path, another: Path) => boolean\n  endsBefore: (path: Path, another: Path) => boolean\n  equals: (path: Path, another: Path) => boolean\n  hasPrevious: (path: Path) => boolean\n  isAfter: (path: Path, another: Path) => boolean\n  isAncestor: (path: Path, another: Path) => boolean\n  isBefore: (path: Path, another: Path) => boolean\n  isChild: (path: Path, another: Path) => boolean\n  isCommon: (path: Path, another: Path) => boolean\n  isDescendant: (path: Path, another: Path) => boolean\n  isParent: (path: Path, another: Path) => boolean\n  isPath: (value: any) => value is Path\n  isSibling: (path: Path, another: Path) => boolean\n  levels: (\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Path[]\n  next: (path: Path) => Path\n  parent: (path: Path) => Path\n  previous: (path: Path) => Path\n  relative: (path: Path, ancestor: Path) => Path\n  transform: (\n    path: Path,\n    operation: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Path | null\n}\n\nexport const Path: PathInterface = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if the path of previous sibling node exists\n   */\n\n  hasPrevious(path: Path): boolean {\n    return path[path.length - 1] > 0\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              copy[op.length - 1] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.isSibling(op, onp) &&\n            (Path.isAncestor(onp, p) || Path.equals(onp, p))\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            } else {\n              p[op.length - 1] += 1\n            }\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport interface PathRefInterface {\n  transform: (ref: PathRef, op: Operation) => void\n}\n\nexport const PathRef: PathRefInterface = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { ExtendedType, Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface BasePoint {\n  path: Path\n  offset: number\n}\n\nexport type Point = ExtendedType<'Point', BasePoint>\n\nexport interface PointInterface {\n  compare: (point: Point, another: Point) => -1 | 0 | 1\n  isAfter: (point: Point, another: Point) => boolean\n  isBefore: (point: Point, another: Point) => boolean\n  equals: (point: Point, another: Point) => boolean\n  isPoint: (value: any) => value is Point\n  transform: (\n    point: Point,\n    op: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Point | null\n}\n\nexport const Point: PointInterface = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport interface PointRefInterface {\n  transform: (ref: PointRef, op: Operation) => void\n}\n\nexport const PointRef: PointRefInterface = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { ExtendedType, Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface BaseRange {\n  anchor: Point\n  focus: Point\n}\n\nexport type Range = ExtendedType<'Range', BaseRange>\n\nexport interface RangeInterface {\n  edges: (\n    range: Range,\n    options?: {\n      reverse?: boolean\n    }\n  ) => [Point, Point]\n  end: (range: Range) => Point\n  equals: (range: Range, another: Range) => boolean\n  includes: (range: Range, target: Path | Point | Range) => boolean\n  intersection: (range: Range, another: Range) => Range | null\n  isBackward: (range: Range) => boolean\n  isCollapsed: (range: Range) => boolean\n  isExpanded: (range: Range) => boolean\n  isForward: (range: Range) => boolean\n  isRange: (value: any) => value is Range\n  points: (range: Range) => Generator<PointEntry, void, undefined>\n  start: (range: Range) => Point\n  transform: (\n    range: Range,\n    op: Operation,\n    options?: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    }\n  ) => Range | null\n}\n\nexport const Range: RangeInterface = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Generator<PointEntry, void, undefined> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    } = {}\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport interface RangeRefInterface {\n  transform: (ref: RangeRef, op: Operation) => void\n}\n\nexport const RangeRef: RangeRefInterface = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport isEqual from 'fast-deep-equal'\nimport { Range } from '..'\nimport { ExtendedType } from './custom-types'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface BaseText {\n  text: string\n}\n\nexport type Text = ExtendedType<'Text', BaseText>\n\nexport interface TextInterface {\n  equals: (text: Text, another: Text, options?: { loose?: boolean }) => boolean\n  isText: (value: any) => value is Text\n  isTextList: (value: any) => value is Text[]\n  isTextProps: (props: any) => props is Partial<Text>\n  matches: (text: Text, props: Partial<Text>) => boolean\n  decorations: (node: Text, decorations: Range[]) => Text[]\n}\n\nexport const Text: TextInterface = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    function omitText(obj: Record<any, any>) {\n      const { text, ...rest } = obj\n\n      return rest\n    }\n\n    return isEqual(\n      loose ? omitText(text) : text,\n      loose ? omitText(another) : another\n    )\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && value.every(val => Text.isText(val))\n  },\n\n  /**\n   * Check if some props are a partial of Text.\n   */\n\n  isTextProps(props: any): props is Partial<Text> {\n    return (props as Partial<Text>).text !== undefined\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= o) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (\n          (start.offset !== end.offset &&\n            (start.offset === o || end.offset === offset)) ||\n          start.offset > o ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < o) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n  NodeEntry,\n  Ancestor,\n} from '..'\nimport { NodeMatch } from '../interfaces/editor'\n\nexport interface NodeTransforms {\n  insertNodes: <T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    }\n  ) => void\n  liftNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => void\n  mergeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  moveNodes: <T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) => void\n  removeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  setNodes: <T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  splitNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    }\n  ) => void\n  unsetNodes: <T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  unwrapNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  wrapNodes: <T extends Node>(\n    editor: Editor,\n    element: Element,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const NodeTransforms: NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes<T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const parentNodeEntry = Editor.node(editor, Path.parent(path))\n        const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n),\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n\n        if (\n          toRef.current &&\n          Path.isSibling(newPath, path) &&\n          Path.isAfter(newPath, path)\n        ) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current)\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes<T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        const endAtEndOfNode = Editor.isEnd(editor, end, end.path)\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode,\n        })\n        const startAtStartOfNode = Editor.isStart(editor, start, start.path)\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            // Omit new properties from the old property list rather than set them to undefined\n            if (node.hasOwnProperty(k)) properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const properties = Node.extractProps(node)\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes<T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path)\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes<T extends Node>(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'lowest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const commonNodeEntry = Editor.node(editor, commonPath)\n          const [commonNode] = commonNodeEntry\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n =>\n              Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\nconst hasSingleChildNest = (editor: Editor, node: Node): boolean => {\n  if (Element.isElement(node)) {\n    const element = node as Element\n    if (Editor.isVoid(editor, node)) {\n      return true\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0])\n    } else {\n      return false\n    }\n  } else if (Editor.isEditor(node)) {\n    return false\n  } else {\n    return true\n  }\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport interface SelectionTransforms {\n  collapse: (\n    editor: Editor,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  deselect: (editor: Editor) => void\n  move: (\n    editor: Editor,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  select: (editor: Editor, target: Location) => void\n  setPoint: (\n    editor: Editor,\n    props: Partial<Point>,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  setSelection: (editor: Editor, props: Partial<Range>) => void\n}\n\nexport const SelectionTransforms: SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location): void {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n    })\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>): void {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport interface TextTransforms {\n  delete: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertFragment: (\n    editor: Editor,\n    fragment: Node[],\n    options?: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertText: (\n    editor: Editor,\n    text: string,\n    options?: {\n      at?: Location\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const TextTransforms: TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        const [, end] = Range.edges(at)\n        const endOfDoc = Editor.end(editor, [])\n\n        if (!Point.equals(end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, { voids })\n        }\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = reverse\n        ? startRef.unref() || endRef.unref()\n        : endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      if (text.length > 0)\n        editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms: GeneralTransforms &\n  NodeTransforms &\n  SelectionTransforms &\n  TextTransforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Selection,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Ancestor,\n} from '..'\n\nexport interface GeneralTransforms {\n  transform: (editor: Editor, op: Operation) => void\n}\n\nconst applyToDraft = (editor: Editor, selection: Selection, op: Operation) => {\n  switch (op.type) {\n    case 'insert_node': {\n      const { path, node } = op\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (index > parent.children.length) {\n        throw new Error(\n          `Cannot apply an \"insert_node\" operation at path [${path}] because the destination is past the end of the node.`\n        )\n      }\n\n      parent.children.splice(index, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'insert_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset)\n      node.text = before + text + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const node = Node.get(editor, path)\n      const prevPath = Path.previous(path)\n      const prev = Node.get(editor, prevPath)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (Text.isText(node) && Text.isText(prev)) {\n        prev.text += node.text\n      } else if (!Text.isText(node) && !Text.isText(prev)) {\n        prev.children.push(...node.children)\n      } else {\n        throw new Error(\n          `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interfaces: ${node} ${prev}`\n        )\n      }\n\n      parent.children.splice(index, 1)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.isAncestor(path, newPath)) {\n        throw new Error(\n          `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      // This is tricky, but since the `path` and `newPath` both refer to\n      // the same snapshot in time, there's a mismatch. After either\n      // removing the original position, the second step's path can be out\n      // of date. So instead of using the `op.newPath` directly, we\n      // transform `op.path` to ascertain what the `newPath` would be after\n      // the operation was applied.\n      parent.children.splice(index, 1)\n      const truePath = Path.transform(path, op)!\n      const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n      const newIndex = truePath[truePath.length - 1]\n\n      newParent.children.splice(newIndex, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const index = path[path.length - 1]\n      const parent = Node.parent(editor, path)\n      parent.children.splice(index, 1)\n\n      // Transform all of the points in the value, but if the point was in the\n      // node that was removed we need to update the range or remove it.\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          const result = Point.transform(point, op)\n\n          if (selection != null && result != null) {\n            selection[key] = result\n          } else {\n            let prev: NodeEntry<Text> | undefined\n            let next: NodeEntry<Text> | undefined\n\n            for (const [n, p] of Node.texts(editor)) {\n              if (Path.compare(p, path) === -1) {\n                prev = [n, p]\n              } else {\n                next = [n, p]\n                break\n              }\n            }\n\n            if (prev) {\n              point.path = prev[1]\n              point.offset = prev[0].text.length\n            } else if (next) {\n              point.path = next[1]\n              point.offset = 0\n            } else {\n              selection = null\n            }\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset + text.length)\n      node.text = before + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'set_node': {\n      const { path, properties, newProperties } = op\n\n      if (path.length === 0) {\n        throw new Error(`Cannot set properties on the root node!`)\n      }\n\n      const node = Node.get(editor, path)\n\n      for (const key in newProperties) {\n        if (key === 'children' || key === 'text') {\n          throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n        }\n\n        const value = newProperties[key]\n\n        if (value == null) {\n          delete node[key]\n        } else {\n          node[key] = value\n        }\n      }\n\n      // properties that were previously defined, but are now missing, must be deleted\n      for (const key in properties) {\n        if (!newProperties.hasOwnProperty(key)) {\n          delete node[key]\n        }\n      }\n\n      break\n    }\n\n    case 'set_selection': {\n      const { newProperties } = op\n\n      if (newProperties == null) {\n        selection = newProperties\n      } else {\n        if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = { ...newProperties }\n        }\n\n        for (const key in newProperties) {\n          const value = newProperties[key]\n\n          if (value == null) {\n            if (key === 'anchor' || key === 'focus') {\n              throw new Error(`Cannot remove the \"${key}\" selection property`)\n            }\n\n            delete selection[key]\n          } else {\n            selection[key] = value\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n\n      if (path.length === 0) {\n        throw new Error(\n          `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n      let newNode: Descendant\n\n      if (Text.isText(node)) {\n        const before = node.text.slice(0, position)\n        const after = node.text.slice(position)\n        node.text = before\n        newNode = {\n          ...(properties as Partial<Text>),\n          text: after,\n        }\n      } else {\n        const before = node.children.slice(0, position)\n        const after = node.children.slice(position)\n        node.children = before\n\n        newNode = {\n          ...(properties as Partial<Element>),\n          children: after,\n        }\n      }\n\n      parent.children.splice(index + 1, 0, newNode)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n  }\n  return selection\n}\n\nexport const GeneralTransforms: GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation): void {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    try {\n      selection = applyToDraft(editor, selection, op)\n    } finally {\n      editor.children = finishDraft(editor.children)\n\n      if (selection) {\n        editor.selection = isDraft(selection)\n          ? (finishDraft(selection) as Range)\n          : selection\n      } else {\n        editor.selection = null\n      }\n    }\n  },\n}\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\nexports.default = isHotkey;\nexports.isHotkey = isHotkey;\nexports.isCodeHotkey = isCodeHotkey;\nexports.isKeyHotkey = isKeyHotkey;\nexports.parseHotkey = parseHotkey;\nexports.compareHotkey = compareHotkey;\nexports.toKeyCode = toKeyCode;\nexports.toKeyName = toKeyName;","/*!\n * escape-html\n * Copyright(c) 2012-2013 TJ Holowaychuk\n * Copyright(c) 2015 Andreas Lubbe\n * Copyright(c) 2015 Tiancheng \"Timothy\" Gu\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module variables.\n * @private\n */\n\nvar matchHtmlRegExp = /[\"'&<>]/;\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = escapeHtml;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @param  {string} string The string to escape for inserting into HTML\n * @return {string}\n * @public\n */\n\nfunction escapeHtml(string) {\n  var str = '' + string;\n  var match = matchHtmlRegExp.exec(str);\n\n  if (!match) {\n    return str;\n  }\n\n  var escape;\n  var html = '';\n  var index = 0;\n  var lastIndex = 0;\n\n  for (index = match.index; index < str.length; index++) {\n    switch (str.charCodeAt(index)) {\n      case 34: // \"\n        escape = '&quot;';\n        break;\n      case 38: // &\n        escape = '&amp;';\n        break;\n      case 39: // '\n        escape = '&#39;';\n        break;\n      case 60: // <\n        escape = '&lt;';\n        break;\n      case 62: // >\n        escape = '&gt;';\n        break;\n      default:\n        continue;\n    }\n\n    if (lastIndex !== index) {\n      html += str.substring(lastIndex, index);\n    }\n\n    lastIndex = index + 1;\n    html += escape;\n  }\n\n  return lastIndex !== index\n    ? html + str.substring(lastIndex, index)\n    : html;\n}\n","import isPlainObject from 'is-plain-object'\nimport { Operation } from 'slate'\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Operation[][]\n  undos: Operation[][]\n}\n\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) &&\n      (value.undos.length === 0 || Operation.isOperationList(value.undos[0]))\n    )\n  },\n}\n","import { BaseEditor, Editor } from 'slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends BaseEditor {\n  history: History\n  undo: () => void\n  redo: () => void\n}\n\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return History.isHistory(value.history) && Editor.isEditor(value)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Redo to the previous saved state.\n   */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo()\n  },\n\n  /**\n   * Undo to the previous saved state.\n   */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo()\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    fn()\n    SAVING.set(editor, prev)\n  },\n}\n","import { Editor, Operation, Path } from 'slate'\n\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor\n  const { apply } = e\n  e.history = { undos: [], redos: [] }\n\n  e.redo = () => {\n    const { history } = e\n    const { redos } = history\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.pop()\n      history.undos.push(batch)\n    }\n  }\n\n  e.undo = () => {\n    const { history } = e\n    const { undos } = history\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.map(Operation.inverse).reverse()\n\n          for (const op of inverseOps) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.push(batch)\n      history.undos.pop()\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e\n    const { undos } = history\n    const lastBatch = undos[undos.length - 1]\n    const lastOp = lastBatch && lastBatch[lastBatch.length - 1]\n    const overwrite = shouldOverwrite(op, lastOp)\n    let save = HistoryEditor.isSaving(e)\n    let merge = HistoryEditor.isMerging(e)\n\n    if (save == null) {\n      save = shouldSave(op, lastOp)\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false\n        } else if (operations.length !== 0) {\n          merge = true\n        } else {\n          merge = shouldMerge(op, lastOp) || overwrite\n        }\n      }\n\n      if (lastBatch && merge) {\n        if (overwrite) {\n          lastBatch.pop()\n        }\n\n        lastBatch.push(op)\n      } else {\n        const batch = [op]\n        undos.push(batch)\n      }\n\n      while (undos.length > 100) {\n        undos.shift()\n      }\n\n      if (shouldClear(op)) {\n        history.redos = []\n      }\n    }\n\n    apply(op)\n  }\n\n  return e\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    op.type === 'set_selection' &&\n    (op.properties == null || op.newProperties == null)\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an operation should overwrite the previous one.\n */\n\nconst shouldOverwrite = (\n  op: Operation,\n  prev: Operation | undefined\n): boolean => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation should clear the redos stack.\n */\n\nconst shouldClear = (op: Operation): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n","import { Node, Path, Text } from 'slate'\n\n/**\n * A weak map to hold anchor tokens.\n */\n\nconst ANCHOR: WeakMap<Node, [number, AnchorToken]> = new WeakMap()\n\n/**\n * A weak map to hold focus tokens.\n */\n\nconst FOCUS: WeakMap<Node, [number, FocusToken]> = new WeakMap()\n\n/**\n * All tokens inherit from a single constructor for `instanceof` checking.\n */\n\nexport class Token {}\n\n/**\n * Anchor tokens represent the selection's anchor point.\n */\n\nexport class AnchorToken extends Token {\n  offset?: number\n  path?: Path\n\n  constructor(\n    props: {\n      offset?: number\n      path?: Path\n    } = {}\n  ) {\n    super()\n    const { offset, path } = props\n    this.offset = offset\n    this.path = path\n  }\n}\n\n/**\n * Focus tokens represent the selection's focus point.\n */\n\nexport class FocusToken extends Token {\n  offset?: number\n  path?: Path\n\n  constructor(\n    props: {\n      offset?: number\n      path?: Path\n    } = {}\n  ) {\n    super()\n    const { offset, path } = props\n    this.offset = offset\n    this.path = path\n  }\n}\n\n/**\n * Add an anchor token to the end of a text node.\n */\n\nexport const addAnchorToken = (text: Text, token: AnchorToken) => {\n  const offset = text.text.length\n  ANCHOR.set(text, [offset, token])\n}\n\n/**\n * Get the offset if a text node has an associated anchor token.\n */\n\nexport const getAnchorOffset = (\n  text: Text\n): [number, AnchorToken] | undefined => {\n  return ANCHOR.get(text)\n}\n\n/**\n * Add a focus token to the end of a text node.\n */\n\nexport const addFocusToken = (text: Text, token: FocusToken) => {\n  const offset = text.text.length\n  FOCUS.set(text, [offset, token])\n}\n\n/**\n * Get the offset if a text node has an associated focus token.\n */\n\nexport const getFocusOffset = (\n  text: Text\n): [number, FocusToken] | undefined => {\n  return FOCUS.get(text)\n}\n","import {\n  Element,\n  Descendant,\n  Node,\n  Range,\n  Text,\n  Editor,\n  createEditor as makeEditor,\n} from 'slate'\nimport {\n  AnchorToken,\n  FocusToken,\n  Token,\n  addAnchorToken,\n  addFocusToken,\n  getAnchorOffset,\n  getFocusOffset,\n} from './tokens'\n\n/**\n * Resolve the descedants of a node by normalizing the children that can be\n * passed into a hyperscript creator function.\n */\n\nconst STRINGS: WeakSet<Text> = new WeakSet()\n\nconst resolveDescendants = (children: any[]): Descendant[] => {\n  const nodes: Node[] = []\n\n  const addChild = (child: Node | Token): void => {\n    if (child == null) {\n      return\n    }\n\n    const prev = nodes[nodes.length - 1]\n\n    if (typeof child === 'string') {\n      const text = { text: child }\n      STRINGS.add(text)\n      child = text\n    }\n\n    if (Text.isText(child)) {\n      const c = child // HACK: fix typescript complaining\n\n      if (\n        Text.isText(prev) &&\n        STRINGS.has(prev) &&\n        STRINGS.has(c) &&\n        Text.equals(prev, c, { loose: true })\n      ) {\n        prev.text += c.text\n      } else {\n        nodes.push(c)\n      }\n    } else if (Element.isElement(child)) {\n      nodes.push(child)\n    } else if (child instanceof Token) {\n      let n = nodes[nodes.length - 1]\n\n      if (!Text.isText(n)) {\n        addChild('')\n        n = nodes[nodes.length - 1] as Text\n      }\n\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child)\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child)\n      }\n    } else {\n      throw new Error(`Unexpected hyperscript child object: ${child}`)\n    }\n  }\n\n  for (const child of children.flat(Infinity)) {\n    addChild(child)\n  }\n\n  return nodes\n}\n\n/**\n * Create an anchor token.\n */\n\nexport function createAnchor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): AnchorToken {\n  return new AnchorToken(attributes)\n}\n\n/**\n * Create an anchor and a focus token.\n */\n\nexport function createCursor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Token[] {\n  return [new AnchorToken(attributes), new FocusToken(attributes)]\n}\n\n/**\n * Create an `Element` object.\n */\n\nexport function createElement(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Element {\n  return { ...attributes, children: resolveDescendants(children) }\n}\n\n/**\n * Create a focus token.\n */\n\nexport function createFocus(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): FocusToken {\n  return new FocusToken(attributes)\n}\n\n/**\n * Create a fragment.\n */\n\nexport function createFragment(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Descendant[] {\n  return resolveDescendants(children)\n}\n\n/**\n * Create a `Selection` object.\n */\n\nexport function createSelection(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Range {\n  const anchor: AnchorToken = children.find(c => c instanceof AnchorToken)\n  const focus: FocusToken = children.find(c => c instanceof FocusToken)\n\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\n      `The <selection> hyperscript tag must have an <anchor> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    )\n  }\n\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\n      `The <selection> hyperscript tag must have a <focus> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    )\n  }\n\n  return {\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path,\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path,\n    },\n    ...attributes,\n  }\n}\n\n/**\n * Create a `Text` object.\n */\n\nexport function createText(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Text {\n  const nodes = resolveDescendants(children)\n\n  if (nodes.length > 1) {\n    throw new Error(\n      `The <text> hyperscript tag must only contain a single node's worth of children.`\n    )\n  }\n\n  let [node] = nodes\n\n  if (node == null) {\n    node = { text: '' }\n  }\n\n  if (!Text.isText(node)) {\n    throw new Error(`\n    The <text> hyperscript tag can only contain text content as children.`)\n  }\n\n  // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n  STRINGS.delete(node)\n\n  Object.assign(node, attributes)\n  return node\n}\n\n/**\n * Create a top-level `Editor` object.\n */\n\nexport function createEditor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Editor {\n  const otherChildren: any[] = []\n  let selectionChild: Range | undefined\n\n  for (const child of children) {\n    if (Range.isRange(child)) {\n      selectionChild = child\n    } else {\n      otherChildren.push(child)\n    }\n  }\n\n  const descendants = resolveDescendants(otherChildren)\n  const selection: Partial<Range> = {}\n  const editor = makeEditor()\n  Object.assign(editor, attributes)\n  editor.children = descendants as Element[]\n\n  // Search the document's texts to see if any of them have tokens associated\n  // that need incorporated into the selection.\n  for (const [node, path] of Node.texts(editor)) {\n    const anchor = getAnchorOffset(node)\n    const focus = getFocusOffset(node)\n\n    if (anchor != null) {\n      const [offset] = anchor\n      selection.anchor = { path, offset }\n    }\n\n    if (focus != null) {\n      const [offset] = focus\n      selection.focus = { path, offset }\n    }\n  }\n\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\n      `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<anchor />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n    )\n  }\n\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\n      `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<focus />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n    )\n  }\n\n  if (selectionChild != null) {\n    editor.selection = selectionChild\n  } else if (Range.isRange(selection)) {\n    editor.selection = selection\n  }\n\n  return editor\n}\n","import isPlainObject from 'is-plain-object'\nimport { Element } from 'slate'\nimport {\n  createAnchor,\n  createCursor,\n  createEditor,\n  createElement,\n  createFocus,\n  createFragment,\n  createSelection,\n  createText,\n} from './creators'\n\n/**\n * The default creators for Slate objects.\n */\n\nconst DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor,\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText,\n}\n\n/**\n * `HyperscriptCreators` are dictionaries of `HyperscriptCreator` functions\n * keyed by tag name.\n */\n\ntype HyperscriptCreators<T = any> = Record<\n  string,\n  (tagName: string, attributes: { [key: string]: any }, children: any[]) => T\n>\n\n/**\n * `HyperscriptShorthands` are dictionaries of properties applied to specific\n * kind of object, keyed by tag name. They allow you to easily define custom\n * hyperscript tags for your domain.\n */\n\ntype HyperscriptShorthands = Record<string, Record<string, any>>\n\n/**\n * Create a Slate hyperscript function with `options`.\n */\n\nconst createHyperscript = (\n  options: {\n    creators?: HyperscriptCreators\n    elements?: HyperscriptShorthands\n  } = {}\n) => {\n  const { elements = {} } = options\n  const elementCreators = normalizeElements(elements)\n  const creators = {\n    ...DEFAULT_CREATORS,\n    ...elementCreators,\n    ...options.creators,\n  }\n\n  const jsx = createFactory(creators)\n  return jsx\n}\n\n/**\n * Create a Slate hyperscript function with `options`.\n */\n\nconst createFactory = <T extends HyperscriptCreators>(creators: T) => {\n  const jsx = <S extends keyof T & string>(\n    tagName: S,\n    attributes?: Object,\n    ...children: any[]\n  ): ReturnType<T[S]> => {\n    const creator = creators[tagName]\n\n    if (!creator) {\n      throw new Error(`No hyperscript creator found for tag: <${tagName}>`)\n    }\n\n    if (attributes == null) {\n      attributes = {}\n    }\n\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children)\n      attributes = {}\n    }\n\n    children = children.filter(child => Boolean(child)).flat()\n    const ret = creator(tagName, attributes, children)\n    return ret\n  }\n\n  return jsx\n}\n\n/**\n * Normalize a dictionary of element shorthands into creator functions.\n */\n\nconst normalizeElements = (elements: HyperscriptShorthands) => {\n  const creators: HyperscriptCreators<Element> = {}\n\n  for (const tagName in elements) {\n    const props = elements[tagName]\n\n    if (typeof props !== 'object') {\n      throw new Error(\n        `Properties specified for a hyperscript shorthand should be an object, but for the custom element <${tagName}>  tag you passed: ${props}`\n      )\n    }\n\n    creators[tagName] = (\n      tagName: string,\n      attributes: { [key: string]: any },\n      children: any[]\n    ) => {\n      return createElement('element', { ...props, ...attributes }, children)\n    }\n  }\n\n  return creators\n}\n\nexport { createHyperscript, HyperscriptCreators, HyperscriptShorthands }\n","// Components\n// Environment-dependent Editable\nimport { Editable as DefaultEditable } from './components/editable'\nimport { AndroidEditable } from './components/android/android-editable'\nimport { IS_ANDROID } from './utils/environment'\n\nexport const Editable = IS_ANDROID ? AndroidEditable : DefaultEditable\nexport {\n  Editable as DefaultEditable,\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n  DefaultPlaceholder,\n} from './components/editable'\nexport { AndroidEditable } from './components/android/android-editable'\nexport { DefaultElement } from './components/element'\nexport { DefaultLeaf } from './components/leaf'\nexport { Slate } from './components/slate'\n\n// Hooks\nexport { useEditor } from './hooks/use-editor'\nexport { useSlateStatic } from './hooks/use-slate-static'\nexport { useFocused } from './hooks/use-focused'\nexport { useReadOnly } from './hooks/use-read-only'\nexport { useSelected } from './hooks/use-selected'\nexport { useSlate } from './hooks/use-slate'\n\n// Plugin\nexport { ReactEditor } from './plugin/react-editor'\nexport { withReact } from './plugin/with-react'\n","import compute from 'compute-scroll-into-view';\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\n\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n\n  var canSmoothScroll = ('scrollBehavior' in document.body.style);\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n        top = _ref.top,\n        left = _ref.left;\n\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\n\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n\n  if (isOptionsObject(options)) {\n    return options;\n  }\n\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\n\nfunction scrollIntoView(target, options) {\n  var targetIsDetached = !target.ownerDocument.documentElement.contains(target);\n\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(targetIsDetached ? [] : compute(target, options));\n  }\n\n  if (targetIsDetached) {\n    return;\n  }\n\n  var computeOptions = getOptions(options);\n  return defaultBehavior(compute(target, computeOptions), computeOptions.behavior);\n}\n\nexport default scrollIntoView;","var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nfunction invariant(condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n}\n\nexport default invariant;\n","import React from 'react'\nimport { Editor, Text, Path, Element, Node } from 'slate'\n\nimport { ReactEditor, useSlateStatic } from '..'\n\n/**\n * Leaf content strings.\n */\n\nconst String = (props: {\n  isLast: boolean\n  leaf: Text\n  parent: Element\n  text: Text\n}) => {\n  const { isLast, leaf, parent, text } = props\n  const editor = useSlateStatic()\n  const path = ReactEditor.findPath(editor, text)\n  const parentPath = Path.parent(path)\n\n  // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n  if (editor.isVoid(parent)) {\n    return <ZeroWidthString length={Node.string(parent).length} />\n  }\n\n  // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n  if (\n    leaf.text === '' &&\n    parent.children[parent.children.length - 1] === text &&\n    !editor.isInline(parent) &&\n    Editor.string(editor, parentPath) === ''\n  ) {\n    return <ZeroWidthString isLineBreak />\n  }\n\n  // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n  if (leaf.text === '') {\n    return <ZeroWidthString />\n  }\n\n  // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return <TextString isTrailing text={leaf.text} />\n  }\n\n  return <TextString text={leaf.text} />\n}\n\n/**\n * Leaf strings with text in them.\n */\n\nconst TextString = (props: { text: string; isTrailing?: boolean }) => {\n  const { text, isTrailing = false } = props\n  return (\n    <span data-slate-string>\n      {text}\n      {isTrailing ? '\\n' : null}\n    </span>\n  )\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n */\n\nconst ZeroWidthString = (props: { length?: number; isLineBreak?: boolean }) => {\n  const { length = 0, isLineBreak = false } = props\n  return (\n    <span\n      data-slate-zero-width={isLineBreak ? 'n' : 'z'}\n      data-slate-length={length}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\nexport default String\n","import React, { useRef, useEffect } from 'react'\nimport { Element, Text } from 'slate'\nimport String from './string'\nimport { PLACEHOLDER_SYMBOL } from '../utils/weak-maps'\nimport { RenderLeafProps, RenderPlaceholderProps } from './editable'\n\n// auto-incrementing key for String component, force it refresh to\n// prevent inconsistent rendering by React with IME input\nlet keyForString = 0\n/**\n * Individual leaves in a text node with unique formatting.\n */\n\nconst Leaf = (props: {\n  isLast: boolean\n  leaf: Text\n  parent: Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  text: Text\n}) => {\n  const {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = (props: RenderLeafProps) => <DefaultLeaf {...props} />,\n  } = props\n\n  const placeholderRef = useRef<HTMLSpanElement | null>(null)\n\n  useEffect(() => {\n    const placeholderEl = placeholderRef?.current\n    const editorEl = document.querySelector<HTMLDivElement>(\n      '[data-slate-editor=\"true\"]'\n    )\n\n    if (!placeholderEl || !editorEl) {\n      return\n    }\n\n    editorEl.style.minHeight = `${placeholderEl.clientHeight}px`\n\n    return () => {\n      editorEl.style.minHeight = 'auto'\n    }\n  }, [placeholderRef, leaf])\n\n  let children = (\n    <String\n      key={keyForString++}\n      isLast={isLast}\n      leaf={leaf}\n      parent={parent}\n      text={text}\n    />\n  )\n\n  if (leaf[PLACEHOLDER_SYMBOL]) {\n    const placeholderProps: RenderPlaceholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none',\n        },\n        contentEditable: false,\n        ref: placeholderRef,\n      },\n    }\n\n    children = (\n      <React.Fragment>\n        {renderPlaceholder(placeholderProps)}\n        {children}\n      </React.Fragment>\n    )\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  const attributes: {\n    'data-slate-leaf': true\n  } = {\n    'data-slate-leaf': true,\n  }\n\n  return renderLeaf({ attributes, children, leaf, text })\n}\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.renderLeaf === prev.renderLeaf &&\n    next.renderPlaceholder === prev.renderPlaceholder &&\n    next.text === prev.text &&\n    next.leaf.text === prev.leaf.text &&\n    Text.matches(next.leaf, prev.leaf) &&\n    next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL]\n  )\n})\n\nexport const DefaultLeaf = (props: RenderLeafProps) => {\n  const { attributes, children } = props\n  return <span {...attributes}>{children}</span>\n}\n\nexport default MemoizedLeaf\n","export const IS_IOS =\n  typeof navigator !== 'undefined' &&\n  typeof window !== 'undefined' &&\n  /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n  !window.MSStream\n\nexport const IS_APPLE =\n  typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent)\n\nexport const IS_ANDROID =\n  typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent)\n\nexport const IS_FIREFOX =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent)\n\nexport const IS_SAFARI =\n  typeof navigator !== 'undefined' &&\n  /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent)\n\n// \"modern\" Edge was released at 79.x\nexport const IS_EDGE_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])/i.test(navigator.userAgent)\n\nexport const IS_CHROME =\n  typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent)\n\n// Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\nexport const IS_CHROME_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])/i.test(navigator.userAgent)\n\n// Firefox did not support `beforeInput` until `v87`.\nexport const IS_FIREFOX_LEGACY =\n  typeof navigator !== 'undefined' &&\n  /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])).*/i.test(\n    navigator.userAgent\n  )\n\n// Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\nexport const CAN_USE_DOM = !!(\n  typeof window !== 'undefined' &&\n  typeof window.document !== 'undefined' &&\n  typeof window.document.createElement !== 'undefined'\n)\n\n// COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\nexport const HAS_BEFORE_INPUT_SUPPORT =\n  !IS_CHROME_LEGACY &&\n  !IS_EDGE_LEGACY &&\n  // globalThis is undefined in older browsers\n  typeof globalThis !== 'undefined' &&\n  globalThis.InputEvent &&\n  // @ts-ignore The `getTargetRanges` property isn't recognized.\n  typeof globalThis.InputEvent.prototype.getTargetRanges === 'function'\n","import { useLayoutEffect, useEffect } from 'react'\nimport { CAN_USE_DOM } from '../utils/environment'\n\n/**\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\n */\n\nexport const useIsomorphicLayoutEffect = CAN_USE_DOM\n  ? useLayoutEffect\n  : useEffect\n","import { Range } from 'slate'\nimport { PLACEHOLDER_SYMBOL } from './weak-maps'\n\nexport const shallowCompare = (obj1: {}, obj2: {}) =>\n  Object.keys(obj1).length === Object.keys(obj2).length &&\n  Object.keys(obj1).every(\n    key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]\n  )\n\n/**\n * Check if a list of decorator ranges are equal to another.\n *\n * PERF: this requires the two lists to also have the ranges inside them in the\n * same order, but this is an okay constraint for us since decorations are\n * kept in order, and the odd case where they aren't is okay to re-render for.\n */\n\nexport const isDecoratorRangeListEqual = (\n  list: Range[],\n  another: Range[]\n): boolean => {\n  if (list.length !== another.length) {\n    return false\n  }\n\n  for (let i = 0; i < list.length; i++) {\n    const range = list[i]\n    const other = another[i]\n\n    const { anchor: rangeAnchor, focus: rangeFocus, ...rangeOwnProps } = range\n    const { anchor: otherAnchor, focus: otherFocus, ...otherOwnProps } = other\n\n    if (\n      !Range.equals(range, other) ||\n      range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] ||\n      !shallowCompare(rangeOwnProps, otherOwnProps)\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n","import React, { useRef } from 'react'\nimport { Range, Element, Text as SlateText } from 'slate'\n\nimport Leaf from './leaf'\nimport { ReactEditor, useSlateStatic } from '..'\nimport { RenderLeafProps, RenderPlaceholderProps } from './editable'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport {\n  KEY_TO_ELEMENT,\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n} from '../utils/weak-maps'\nimport { isDecoratorRangeListEqual } from '../utils/range-list'\n\n/**\n * Text.\n */\n\nconst Text = (props: {\n  decorations: Range[]\n  isLast: boolean\n  parent: Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  text: SlateText\n}) => {\n  const {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text,\n  } = props\n  const editor = useSlateStatic()\n  const ref = useRef<HTMLSpanElement>(null)\n  const leaves = SlateText.decorations(text, decorations)\n  const key = ReactEditor.findKey(editor, text)\n  const children = []\n\n  for (let i = 0; i < leaves.length; i++) {\n    const leaf = leaves[i]\n\n    children.push(\n      <Leaf\n        isLast={isLast && i === leaves.length - 1}\n        key={`${key.id}-${i}`}\n        renderPlaceholder={renderPlaceholder}\n        leaf={leaf}\n        text={text}\n        parent={parent}\n        renderLeaf={renderLeaf}\n      />\n    )\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current)\n      NODE_TO_ELEMENT.set(text, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, text)\n    } else {\n      KEY_TO_ELEMENT.delete(key)\n      NODE_TO_ELEMENT.delete(text)\n    }\n  })\n\n  return (\n    <span data-slate-node=\"text\" ref={ref}>\n      {children}\n    </span>\n  )\n}\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    next.parent === prev.parent &&\n    next.isLast === prev.isLast &&\n    next.renderLeaf === prev.renderLeaf &&\n    next.text === prev.text &&\n    isDecoratorRangeListEqual(next.decorations, prev.decorations)\n  )\n})\n\nexport default MemoizedText\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `selected` state of an element.\n */\n\nexport const SelectedContext = createContext(false)\n\n/**\n * Get the current `selected` state of an element.\n */\n\nexport const useSelected = (): boolean => {\n  return useContext(SelectedContext)\n}\n","import React, { useRef } from 'react'\nimport getDirection from 'direction'\nimport { Editor, Node, Range, NodeEntry, Element as SlateElement } from 'slate'\n\nimport Text from './text'\nimport useChildren from '../hooks/use-children'\nimport { ReactEditor, useSlateStatic, useReadOnly } from '..'\nimport { SelectedContext } from '../hooks/use-selected'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport {\n  NODE_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  NODE_TO_PARENT,\n  NODE_TO_INDEX,\n  KEY_TO_ELEMENT,\n} from '../utils/weak-maps'\nimport { isDecoratorRangeListEqual } from '../utils/range-list'\nimport {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n} from './editable'\n\n/**\n * Element.\n */\n\nconst Element = (props: {\n  decorations: Range[]\n  element: SlateElement\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  selection: Range | null\n}) => {\n  const {\n    decorations,\n    element,\n    renderElement = (p: RenderElementProps) => <DefaultElement {...p} />,\n    renderPlaceholder,\n    renderLeaf,\n    selection,\n  } = props\n  const ref = useRef<HTMLElement>(null)\n  const editor = useSlateStatic()\n  const readOnly = useReadOnly()\n  const isInline = editor.isInline(element)\n  const key = ReactEditor.findKey(editor, element)\n  let children: React.ReactNode = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection,\n  })\n\n  // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n  const attributes: {\n    'data-slate-node': 'element'\n    'data-slate-void'?: true\n    'data-slate-inline'?: true\n    contentEditable?: false\n    dir?: 'rtl'\n    ref: any\n  } = {\n    'data-slate-node': 'element',\n    ref,\n  }\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true\n  }\n\n  // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    const text = Node.string(element)\n    const dir = getDirection(text)\n\n    if (dir === 'rtl') {\n      attributes.dir = dir\n    }\n  }\n\n  // If it's a void node, wrap the children in extra void-specific elements.\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false\n    }\n\n    const Tag = isInline ? 'span' : 'div'\n    const [[text]] = Node.texts(element)\n\n    children = readOnly ? null : (\n      <Tag\n        data-slate-spacer\n        style={{\n          height: '0',\n          color: 'transparent',\n          outline: 'none',\n          position: 'absolute',\n        }}\n      >\n        <Text\n          renderPlaceholder={renderPlaceholder}\n          decorations={[]}\n          isLast={false}\n          parent={element}\n          text={text}\n        />\n      </Tag>\n    )\n\n    NODE_TO_INDEX.set(text, 0)\n    NODE_TO_PARENT.set(text, element)\n  }\n\n  // Update element-related weak maps with the DOM element ref.\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current) {\n      KEY_TO_ELEMENT.set(key, ref.current)\n      NODE_TO_ELEMENT.set(element, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, element)\n    } else {\n      KEY_TO_ELEMENT.delete(key)\n      NODE_TO_ELEMENT.delete(element)\n    }\n  })\n\n  return (\n    <SelectedContext.Provider value={!!selection}>\n      {renderElement({ attributes, children, element })}\n    </SelectedContext.Provider>\n  )\n}\n\nconst MemoizedElement = React.memo(Element, (prev, next) => {\n  return (\n    prev.element === next.element &&\n    prev.renderElement === next.renderElement &&\n    prev.renderLeaf === next.renderLeaf &&\n    isDecoratorRangeListEqual(prev.decorations, next.decorations) &&\n    (prev.selection === next.selection ||\n      (!!prev.selection &&\n        !!next.selection &&\n        Range.equals(prev.selection, next.selection)))\n  )\n})\n\n/**\n * The default element renderer.\n */\n\nexport const DefaultElement = (props: RenderElementProps) => {\n  const { attributes, children, element } = props\n  const editor = useSlateStatic()\n  const Tag = editor.isInline(element) ? 'span' : 'div'\n  return (\n    <Tag {...attributes} style={{ position: 'relative' }}>\n      {children}\n    </Tag>\n  )\n}\n\nexport default MemoizedElement\n","import { createContext, useContext } from 'react'\nimport { ReactEditor } from '../plugin/react-editor'\nimport { Editor } from 'slate'\n\n/**\n * A React context for sharing the editor object.\n */\n\nexport const EditorContext = createContext<ReactEditor | null>(null)\n\n/**\n * Get the current editor object from the React context.\n */\n\nexport const useSlateStatic = (): Editor => {\n  const editor = useContext(EditorContext)\n\n  if (!editor) {\n    throw new Error(\n      `The \\`useSlateStatic\\` hook must be used inside the <Slate> component's context.`\n    )\n  }\n\n  return editor\n}\n","import { createContext, useContext } from 'react'\nimport { Range, NodeEntry } from 'slate'\n\n/**\n * A React context for sharing the `decorate` prop of the editable.\n */\n\nexport const DecorateContext = createContext<(entry: NodeEntry) => Range[]>(\n  () => []\n)\n\n/**\n * Get the current `decorate` prop of the editable.\n */\n\nexport const useDecorate = (): ((entry: NodeEntry) => Range[]) => {\n  return useContext(DecorateContext)\n}\n","import React from 'react'\nimport { Editor, Range, Element, NodeEntry, Ancestor, Descendant } from 'slate'\n\nimport ElementComponent from '../components/element'\nimport TextComponent from '../components/text'\nimport { ReactEditor } from '..'\nimport { useSlateStatic } from './use-slate-static'\nimport { useDecorate } from './use-decorate'\nimport { NODE_TO_INDEX, NODE_TO_PARENT } from '../utils/weak-maps'\nimport {\n  RenderElementProps,\n  RenderLeafProps,\n  RenderPlaceholderProps,\n} from '../components/editable'\n\n/**\n * Children.\n */\n\nconst useChildren = (props: {\n  decorations: Range[]\n  node: Ancestor\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderPlaceholder: (props: RenderPlaceholderProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  selection: Range | null\n}) => {\n  const {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection,\n  } = props\n  const decorate = useDecorate()\n  const editor = useSlateStatic()\n  const path = ReactEditor.findPath(editor, node)\n  const children = []\n  const isLeafBlock =\n    Element.isElement(node) &&\n    !editor.isInline(node) &&\n    Editor.hasInlines(editor, node)\n\n  for (let i = 0; i < node.children.length; i++) {\n    const p = path.concat(i)\n    const n = node.children[i] as Descendant\n    const key = ReactEditor.findKey(editor, n)\n    const range = Editor.range(editor, p)\n    const sel = selection && Range.intersection(range, selection)\n    const ds = decorate([n, p])\n\n    for (const dec of decorations) {\n      const d = Range.intersection(dec, range)\n\n      if (d) {\n        ds.push(d)\n      }\n    }\n\n    if (Element.isElement(n)) {\n      children.push(\n        <ElementComponent\n          decorations={ds}\n          element={n}\n          key={key.id}\n          renderElement={renderElement}\n          renderPlaceholder={renderPlaceholder}\n          renderLeaf={renderLeaf}\n          selection={sel}\n        />\n      )\n    } else {\n      children.push(\n        <TextComponent\n          decorations={ds}\n          key={key.id}\n          isLast={isLeafBlock && i === node.children.length - 1}\n          parent={node}\n          renderPlaceholder={renderPlaceholder}\n          renderLeaf={renderLeaf}\n          text={n}\n        />\n      )\n    }\n\n    NODE_TO_INDEX.set(n, i)\n    NODE_TO_PARENT.set(n, node)\n  }\n\n  return children\n}\n\nexport default useChildren\n","import { isKeyHotkey } from 'is-hotkey'\nimport { IS_APPLE } from './environment'\n\n/**\n * Hotkey mappings for each platform.\n */\n\nconst HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  splitBlock: 'shift?+enter',\n  undo: 'mod+z',\n}\n\nconst APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t',\n}\n\nconst WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z'],\n}\n\n/**\n * Create a platform-aware hotkey checker.\n */\n\nconst create = (key: string) => {\n  const generic = HOTKEYS[key]\n  const apple = APPLE_HOTKEYS[key]\n  const windows = WINDOWS_HOTKEYS[key]\n  const isGeneric = generic && isKeyHotkey(generic)\n  const isApple = apple && isKeyHotkey(apple)\n  const isWindows = windows && isKeyHotkey(windows)\n\n  return (event: KeyboardEvent) => {\n    if (isGeneric && isGeneric(event)) return true\n    if (IS_APPLE && isApple && isApple(event)) return true\n    if (!IS_APPLE && isWindows && isWindows(event)) return true\n    return false\n  }\n}\n\n/**\n * Hotkeys.\n */\n\nexport default {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo'),\n}\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `readOnly` state of the editor.\n */\n\nexport const ReadOnlyContext = createContext(false)\n\n/**\n * Get the current `readOnly` state of the editor.\n */\n\nexport const useReadOnly = (): boolean => {\n  return useContext(ReadOnlyContext)\n}\n","import { createContext, useContext } from 'react'\nimport { Editor } from 'slate'\nimport { ReactEditor } from '../plugin/react-editor'\n\n/**\n * A React context for sharing the editor object, in a way that re-renders the\n * context whenever changes occur.\n */\n\nexport const SlateContext = createContext<[ReactEditor] | null>(null)\n\n/**\n * Get the current editor object from the React context.\n */\n\nexport const useSlate = (): Editor => {\n  const context = useContext(SlateContext)\n\n  if (!context) {\n    throw new Error(\n      `The \\`useSlate\\` hook must be used inside the <SlateProvider> component's context.`\n    )\n  }\n\n  const [editor] = context\n  return editor\n}\n","/**\n * Types.\n */\n\n// COMPAT: This is required to prevent TypeScript aliases from doing some very\n// weird things for Slate's types with the same name as globals. (2019/11/27)\n// https://github.com/microsoft/TypeScript/issues/35002\nimport DOMNode = globalThis.Node\nimport DOMComment = globalThis.Comment\nimport DOMElement = globalThis.Element\nimport DOMText = globalThis.Text\nimport DOMRange = globalThis.Range\nimport DOMSelection = globalThis.Selection\nimport DOMStaticRange = globalThis.StaticRange\n\nexport {\n  DOMNode,\n  DOMComment,\n  DOMElement,\n  DOMText,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n}\n\ndeclare global {\n  interface Window {\n    Selection: typeof Selection['constructor']\n    DataTransfer: typeof DataTransfer['constructor']\n    Node: typeof Node['constructor']\n  }\n}\n\nexport type DOMPoint = [Node, number]\n\n/**\n * Returns the host window of a DOM node\n */\n\nexport const getDefaultView = (value: any): Window | null => {\n  return (\n    (value && value.ownerDocument && value.ownerDocument.defaultView) || null\n  )\n}\n\n/**\n * Check if a DOM node is a comment node.\n */\n\nexport const isDOMComment = (value: any): value is DOMComment => {\n  return isDOMNode(value) && value.nodeType === 8\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMElement = (value: any): value is DOMElement => {\n  return isDOMNode(value) && value.nodeType === 1\n}\n\n/**\n * Check if a value is a DOM node.\n */\n\nexport const isDOMNode = (value: any): value is DOMNode => {\n  const window = getDefaultView(value)\n  return !!window && value instanceof window.Node\n}\n\n/**\n * Check if a value is a DOM selection.\n */\n\nexport const isDOMSelection = (value: any): value is DOMSelection => {\n  const window = value && value.anchorNode && getDefaultView(value.anchorNode)\n  return !!window && value instanceof window.Selection\n}\n\n/**\n * Check if a DOM node is an element node.\n */\n\nexport const isDOMText = (value: any): value is DOMText => {\n  return isDOMNode(value) && value.nodeType === 3\n}\n\n/**\n * Checks whether a paste event is a plaintext-only event.\n */\n\nexport const isPlainTextOnlyPaste = (event: ClipboardEvent) => {\n  return (\n    event.clipboardData &&\n    event.clipboardData.getData('text/plain') !== '' &&\n    event.clipboardData.types.length === 1\n  )\n}\n\n/**\n * Normalize a DOM point so that it always refers to a text node.\n */\n\nexport const normalizeDOMPoint = (domPoint: DOMPoint): DOMPoint => {\n  let [node, offset] = domPoint\n\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (isDOMElement(node) && node.childNodes.length) {\n    let isLast = offset === node.childNodes.length\n    let index = isLast ? offset - 1 : offset\n    ;[node, index] = getEditableChildAndIndex(\n      node,\n      index,\n      isLast ? 'backward' : 'forward'\n    )\n    // If the editable child found is in front of input offset, we instead seek to its end\n    isLast = index < offset\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (isDOMElement(node) && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward')\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast && node.textContent != null ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return [node, offset]\n}\n\n/**\n * Determines wether the active element is nested within a shadowRoot\n */\n\nexport const hasShadowRoot = () => {\n  return !!(\n    window.document.activeElement && window.document.activeElement.shadowRoot\n  )\n}\n\n/**\n * Get the nearest editable child and index at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChildAndIndex = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward'\n): [DOMNode, number] => {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    isDOMComment(child) ||\n    (isDOMElement(child) && child.childNodes.length === 0) ||\n    (isDOMElement(child) && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) {\n      break\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    index = i\n    i += direction === 'forward' ? 1 : -1\n  }\n\n  return [child, index]\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n */\n\nexport const getEditableChild = (\n  parent: DOMElement,\n  index: number,\n  direction: 'forward' | 'backward'\n): DOMNode => {\n  const [child] = getEditableChildAndIndex(parent, index, direction)\n  return child\n}\n\n/**\n * Get a plaintext representation of the content of a node, accounting for block\n * elements which get a newline appended.\n *\n * The domNode must be attached to the DOM.\n */\n\nexport const getPlainText = (domNode: DOMNode) => {\n  let text = ''\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue\n  }\n\n  if (isDOMElement(domNode)) {\n    for (const childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode)\n    }\n\n    const display = getComputedStyle(domNode).getPropertyValue('display')\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n'\n    }\n  }\n\n  return text\n}\n","import React, { useEffect, useRef, useMemo, useCallback } from 'react'\nimport {\n  Editor,\n  Element,\n  NodeEntry,\n  Node,\n  Range,\n  Text,\n  Transforms,\n  Path,\n} from 'slate'\nimport getDirection from 'direction'\nimport throttle from 'lodash/throttle'\nimport scrollIntoView from 'scroll-into-view-if-needed'\n\nimport useChildren from '../hooks/use-children'\nimport Hotkeys from '../utils/hotkeys'\nimport {\n  HAS_BEFORE_INPUT_SUPPORT,\n  IS_CHROME,\n  IS_FIREFOX,\n  IS_FIREFOX_LEGACY,\n  IS_SAFARI,\n} from '../utils/environment'\nimport { ReactEditor } from '..'\nimport { ReadOnlyContext } from '../hooks/use-read-only'\nimport { useSlate } from '../hooks/use-slate'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\nimport { DecorateContext } from '../hooks/use-decorate'\nimport {\n  DOMElement,\n  DOMNode,\n  DOMRange,\n  getDefaultView,\n  isDOMElement,\n  isDOMNode,\n  isPlainTextOnlyPaste,\n} from '../utils/dom'\n\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  IS_READ_ONLY,\n  NODE_TO_ELEMENT,\n  IS_FOCUSED,\n  PLACEHOLDER_SYMBOL,\n  EDITOR_TO_WINDOW,\n} from '../utils/weak-maps'\n\n/**\n * `RenderElementProps` are passed to the `renderElement` handler.\n */\n\nexport interface RenderElementProps {\n  children: any\n  element: Element\n  attributes: {\n    'data-slate-node': 'element'\n    'data-slate-inline'?: true\n    'data-slate-void'?: true\n    dir?: 'rtl'\n    ref: any\n  }\n}\n\n/**\n * `RenderLeafProps` are passed to the `renderLeaf` handler.\n */\n\nexport interface RenderLeafProps {\n  children: any\n  leaf: Text\n  text: Text\n  attributes: {\n    'data-slate-leaf': true\n  }\n}\n\n/**\n * `EditableProps` are passed to the `<Editable>` component.\n */\n\nexport type EditableProps = {\n  decorate?: (entry: NodeEntry) => Range[]\n  onDOMBeforeInput?: (event: InputEvent) => void\n  placeholder?: string\n  readOnly?: boolean\n  role?: string\n  style?: React.CSSProperties\n  renderElement?: (props: RenderElementProps) => JSX.Element\n  renderLeaf?: (props: RenderLeafProps) => JSX.Element\n  renderPlaceholder?: (props: RenderPlaceholderProps) => JSX.Element\n  as?: React.ElementType\n} & React.TextareaHTMLAttributes<HTMLDivElement>\n\n/**\n * Editable.\n */\n\nexport const Editable = (props: EditableProps) => {\n  const {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = props => <DefaultPlaceholder {...props} />,\n    style = {},\n    as: Component = 'div',\n    ...attributes\n  } = props\n  const editor = useSlate()\n  const ref = useRef<HTMLDivElement>(null)\n\n  // Update internal state on each render.\n  IS_READ_ONLY.set(editor, readOnly)\n\n  // Keep track of some state for the event handler logic.\n  const state = useMemo(\n    () => ({\n      isComposing: false,\n      isDraggingInternally: false,\n      isUpdatingSelection: false,\n      latestElement: null as DOMElement | null,\n    }),\n    []\n  )\n\n  // Whenever the editor updates...\n  useIsomorphicLayoutEffect(() => {\n    // Update element-related weak maps with the DOM element ref.\n    let window\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window)\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n    }\n\n    // Make sure the DOM selection state is in sync.\n    const { selection } = editor\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    const domSelection = root.getSelection()\n\n    if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {\n      return\n    }\n\n    const hasDomSelection = domSelection.type !== 'None'\n\n    // If the DOM selection is properly unset, we're done.\n    if (!selection && !hasDomSelection) {\n      return\n    }\n\n    // verify that the dom selection is in the editor\n    const editorElement = EDITOR_TO_ELEMENT.get(editor)!\n    let hasDomSelectionInEditor = false\n    if (\n      editorElement.contains(domSelection.anchorNode) &&\n      editorElement.contains(domSelection.focusNode)\n    ) {\n      hasDomSelectionInEditor = true\n    }\n\n    // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n    if (hasDomSelection && hasDomSelectionInEditor && selection) {\n      const slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: true,\n      })\n      if (slateRange && Range.equals(slateRange, selection)) {\n        return\n      }\n    }\n\n    // when <Editable/> is being controlled through external value\n    // then its children might just change - DOM responds to it on its own\n    // but Slate's value is not being updated through any operation\n    // and thus it doesn't transform selection on its own\n    if (selection && !ReactEditor.hasRange(editor, selection)) {\n      editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n      })\n      return\n    }\n\n    // Otherwise the DOM selection is out of sync, so update it.\n    const el = ReactEditor.toDOMNode(editor, editor)\n    state.isUpdatingSelection = true\n\n    const newDomRange = selection && ReactEditor.toDOMRange(editor, selection)\n\n    if (newDomRange) {\n      if (Range.isBackward(selection!)) {\n        domSelection.setBaseAndExtent(\n          newDomRange.endContainer,\n          newDomRange.endOffset,\n          newDomRange.startContainer,\n          newDomRange.startOffset\n        )\n      } else {\n        domSelection.setBaseAndExtent(\n          newDomRange.startContainer,\n          newDomRange.startOffset,\n          newDomRange.endContainer,\n          newDomRange.endOffset\n        )\n      }\n      const leafEl = newDomRange.startContainer.parentElement!\n      leafEl.getBoundingClientRect = newDomRange.getBoundingClientRect.bind(\n        newDomRange\n      )\n      scrollIntoView(leafEl, {\n        scrollMode: 'if-needed',\n        boundary: el,\n      })\n      // @ts-ignore\n      delete leafEl.getBoundingClientRect\n    } else {\n      domSelection.removeAllRanges()\n    }\n\n    setTimeout(() => {\n      // COMPAT: In Firefox, it's not enough to create a range, you also need\n      // to focus the contenteditable element too. (2016/11/16)\n      if (newDomRange && IS_FIREFOX) {\n        el.focus()\n      }\n\n      state.isUpdatingSelection = false\n    })\n  })\n\n  // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n  useEffect(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus()\n    }\n  }, [autoFocus])\n\n  // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n  const onDOMBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (\n        !readOnly &&\n        hasEditableTarget(editor, event.target) &&\n        !isDOMEventHandled(event, propsOnDOMBeforeInput)\n      ) {\n        const { selection } = editor\n        const { inputType: type } = event\n        const data = (event as any).dataTransfer || event.data || undefined\n\n        // These two types occur while a user is composing text and can't be\n        // cancelled. Let them through and wait for the composition to end.\n        if (\n          type === 'insertCompositionText' ||\n          type === 'deleteCompositionText'\n        ) {\n          return\n        }\n\n        event.preventDefault()\n\n        // COMPAT: For the deleting forward/backward input types we don't want\n        // to change the selection because it is the range that will be deleted,\n        // and those commands determine that for themselves.\n        if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n          const [targetRange] = (event as any).getTargetRanges()\n\n          if (targetRange) {\n            const range = ReactEditor.toSlateRange(editor, targetRange, {\n              exactMatch: false,\n            })\n\n            if (!selection || !Range.equals(selection, range)) {\n              Transforms.select(editor, range)\n            }\n          }\n        }\n\n        // COMPAT: If the selection is expanded, even if the command seems like\n        // a delete forward/backward command it should delete the selection.\n        if (\n          selection &&\n          Range.isExpanded(selection) &&\n          type.startsWith('delete')\n        ) {\n          const direction = type.endsWith('Backward') ? 'backward' : 'forward'\n          Editor.deleteFragment(editor, { direction })\n          return\n        }\n\n        switch (type) {\n          case 'deleteByComposition':\n          case 'deleteByCut':\n          case 'deleteByDrag': {\n            Editor.deleteFragment(editor)\n            break\n          }\n\n          case 'deleteContent':\n          case 'deleteContentForward': {\n            Editor.deleteForward(editor)\n            break\n          }\n\n          case 'deleteContentBackward': {\n            Editor.deleteBackward(editor)\n            break\n          }\n\n          case 'deleteEntireSoftLine': {\n            Editor.deleteBackward(editor, { unit: 'line' })\n            Editor.deleteForward(editor, { unit: 'line' })\n            break\n          }\n\n          case 'deleteHardLineBackward': {\n            Editor.deleteBackward(editor, { unit: 'block' })\n            break\n          }\n\n          case 'deleteSoftLineBackward': {\n            Editor.deleteBackward(editor, { unit: 'line' })\n            break\n          }\n\n          case 'deleteHardLineForward': {\n            Editor.deleteForward(editor, { unit: 'block' })\n            break\n          }\n\n          case 'deleteSoftLineForward': {\n            Editor.deleteForward(editor, { unit: 'line' })\n            break\n          }\n\n          case 'deleteWordBackward': {\n            Editor.deleteBackward(editor, { unit: 'word' })\n            break\n          }\n\n          case 'deleteWordForward': {\n            Editor.deleteForward(editor, { unit: 'word' })\n            break\n          }\n\n          case 'insertLineBreak':\n          case 'insertParagraph': {\n            Editor.insertBreak(editor)\n            break\n          }\n\n          case 'insertFromComposition':\n          case 'insertFromDrop':\n          case 'insertFromPaste':\n          case 'insertFromYank':\n          case 'insertReplacementText':\n          case 'insertText': {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              state.isComposing = false\n            }\n\n            const window = ReactEditor.getWindow(editor)\n            if (data instanceof window.DataTransfer) {\n              ReactEditor.insertData(editor, data as DataTransfer)\n            } else if (typeof data === 'string') {\n              Editor.insertText(editor, data)\n            }\n\n            break\n          }\n        }\n      }\n    },\n    [readOnly, propsOnDOMBeforeInput]\n  )\n\n  // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  // https://github.com/facebook/react/issues/11211\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n      // @ts-ignore The `beforeinput` event isn't recognized.\n      ref.current.addEventListener('beforeinput', onDOMBeforeInput)\n    }\n\n    return () => {\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput)\n      }\n    }\n  }, [onDOMBeforeInput])\n\n  // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n  const onDOMSelectionChange = useCallback(\n    throttle(() => {\n      if (\n        !readOnly &&\n        !state.isComposing &&\n        !state.isUpdatingSelection &&\n        !state.isDraggingInternally\n      ) {\n        const root = ReactEditor.findDocumentOrShadowRoot(editor)\n        const { activeElement } = root\n        const el = ReactEditor.toDOMNode(editor, editor)\n        const domSelection = root.getSelection()\n\n        if (activeElement === el) {\n          state.latestElement = activeElement\n          IS_FOCUSED.set(editor, true)\n        } else {\n          IS_FOCUSED.delete(editor)\n        }\n\n        if (!domSelection) {\n          return Transforms.deselect(editor)\n        }\n\n        const { anchorNode, focusNode } = domSelection\n\n        const anchorNodeSelectable =\n          hasEditableTarget(editor, anchorNode) ||\n          isTargetInsideVoid(editor, anchorNode)\n\n        const focusNodeSelectable =\n          hasEditableTarget(editor, focusNode) ||\n          isTargetInsideVoid(editor, focusNode)\n\n        if (anchorNodeSelectable && focusNodeSelectable) {\n          const range = ReactEditor.toSlateRange(editor, domSelection, {\n            exactMatch: false,\n          })\n          Transforms.select(editor, range)\n        } else {\n          Transforms.deselect(editor)\n        }\n      }\n    }, 100),\n    [readOnly]\n  )\n\n  // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n  useIsomorphicLayoutEffect(() => {\n    const window = ReactEditor.getWindow(editor)\n    window.document.addEventListener('selectionchange', onDOMSelectionChange)\n\n    return () => {\n      window.document.removeEventListener(\n        'selectionchange',\n        onDOMSelectionChange\n      )\n    }\n  }, [onDOMSelectionChange])\n\n  const decorations = decorate([editor, []])\n\n  if (\n    placeholder &&\n    editor.children.length === 1 &&\n    Array.from(Node.texts(editor)).length === 1 &&\n    Node.string(editor) === ''\n  ) {\n    const start = Editor.start(editor, [])\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start,\n      focus: start,\n    })\n  }\n\n  return (\n    <ReadOnlyContext.Provider value={readOnly}>\n      <DecorateContext.Provider value={decorate}>\n        <Component\n          // COMPAT: The Grammarly Chrome extension works by changing the DOM\n          // out from under `contenteditable` elements, which leads to weird\n          // behaviors so we have to disable it like editor. (2017/04/24)\n          data-gramm={false}\n          role={readOnly ? undefined : 'textbox'}\n          {...attributes}\n          // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n          // have to use hacks to make these replacement-based features work.\n          spellCheck={!HAS_BEFORE_INPUT_SUPPORT ? false : attributes.spellCheck}\n          autoCorrect={\n            !HAS_BEFORE_INPUT_SUPPORT ? 'false' : attributes.autoCorrect\n          }\n          autoCapitalize={\n            !HAS_BEFORE_INPUT_SUPPORT ? 'false' : attributes.autoCapitalize\n          }\n          data-slate-editor\n          data-slate-node=\"value\"\n          contentEditable={readOnly ? undefined : true}\n          suppressContentEditableWarning\n          ref={ref}\n          style={{\n            // Allow positioning relative to the editable element.\n            position: 'relative',\n            // Prevent the default outline styles.\n            outline: 'none',\n            // Preserve adjacent whitespace and new lines.\n            whiteSpace: 'pre-wrap',\n            // Allow words to break if they are too long.\n            wordWrap: 'break-word',\n            // Allow for passed-in styles to override anything.\n            ...style,\n          }}\n          onBeforeInput={useCallback(\n            (event: React.FormEvent<HTMLDivElement>) => {\n              // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n              // fall back to React's leaky polyfill instead just for it. It\n              // only works for the `insertText` input type.\n              if (\n                !HAS_BEFORE_INPUT_SUPPORT &&\n                !readOnly &&\n                !isEventHandled(event, attributes.onBeforeInput) &&\n                hasEditableTarget(editor, event.target)\n              ) {\n                event.preventDefault()\n                if (!state.isComposing) {\n                  const text = (event as any).data as string\n                  Editor.insertText(editor, text)\n                }\n              }\n            },\n            [readOnly]\n          )}\n          onBlur={useCallback(\n            (event: React.FocusEvent<HTMLDivElement>) => {\n              if (\n                readOnly ||\n                state.isUpdatingSelection ||\n                !hasEditableTarget(editor, event.target) ||\n                isEventHandled(event, attributes.onBlur)\n              ) {\n                return\n              }\n\n              // COMPAT: If the current `activeElement` is still the previous\n              // one, this is due to the window being blurred when the tab\n              // itself becomes unfocused, so we want to abort early to allow to\n              // editor to stay focused when the tab becomes focused again.\n              const root = ReactEditor.findDocumentOrShadowRoot(editor)\n              if (state.latestElement === root.activeElement) {\n                return\n              }\n\n              const { relatedTarget } = event\n              const el = ReactEditor.toDOMNode(editor, editor)\n\n              // COMPAT: The event should be ignored if the focus is returning\n              // to the editor from an embedded editable element (eg. an <input>\n              // element inside a void node).\n              if (relatedTarget === el) {\n                return\n              }\n\n              // COMPAT: The event should be ignored if the focus is moving from\n              // the editor to inside a void node's spacer element.\n              if (\n                isDOMElement(relatedTarget) &&\n                relatedTarget.hasAttribute('data-slate-spacer')\n              ) {\n                return\n              }\n\n              // COMPAT: The event should be ignored if the focus is moving to a\n              // non- editable section of an element that isn't a void node (eg.\n              // a list item of the check list example).\n              if (\n                relatedTarget != null &&\n                isDOMNode(relatedTarget) &&\n                ReactEditor.hasDOMNode(editor, relatedTarget)\n              ) {\n                const node = ReactEditor.toSlateNode(editor, relatedTarget)\n\n                if (Element.isElement(node) && !editor.isVoid(node)) {\n                  return\n                }\n              }\n\n              // COMPAT: Safari doesn't always remove the selection even if the content-\n              // editable element no longer has focus. Refer to:\n              // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n              if (IS_SAFARI) {\n                const domSelection = root.getSelection()\n                domSelection?.removeAllRanges()\n              }\n\n              IS_FOCUSED.delete(editor)\n            },\n            [readOnly, attributes.onBlur]\n          )}\n          onClick={useCallback(\n            (event: React.MouseEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                hasTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onClick) &&\n                isDOMNode(event.target)\n              ) {\n                const node = ReactEditor.toSlateNode(editor, event.target)\n                const path = ReactEditor.findPath(editor, node)\n                const start = Editor.start(editor, path)\n                const end = Editor.end(editor, path)\n\n                const startVoid = Editor.void(editor, { at: start })\n                const endVoid = Editor.void(editor, { at: end })\n\n                if (\n                  startVoid &&\n                  endVoid &&\n                  Path.equals(startVoid[1], endVoid[1])\n                ) {\n                  const range = Editor.range(editor, start)\n                  Transforms.select(editor, range)\n                }\n              }\n            },\n            [readOnly, attributes.onClick]\n          )}\n          onCompositionEnd={useCallback(\n            (event: React.CompositionEvent<HTMLDivElement>) => {\n              if (\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onCompositionEnd)\n              ) {\n                state.isComposing = false\n\n                // COMPAT: In Chrome, `beforeinput` events for compositions\n                // aren't correct and never fire the \"insertFromComposition\"\n                // type that we need. So instead, insert whenever a composition\n                // ends since it will already have been committed to the DOM.\n                if (!IS_SAFARI && !IS_FIREFOX_LEGACY && event.data) {\n                  Editor.insertText(editor, event.data)\n                }\n              }\n            },\n            [attributes.onCompositionEnd]\n          )}\n          onCompositionUpdate={useCallback(\n            (event: React.CompositionEvent<HTMLDivElement>) => {\n              if (\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onCompositionUpdate)\n              ) {\n                state.isComposing = true\n              }\n            },\n            [attributes.onCompositionUpdate]\n          )}\n          onCompositionStart={useCallback(\n            (event: React.CompositionEvent<HTMLDivElement>) => {\n              if (\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onCompositionStart)\n              ) {\n                const { selection } = editor\n                if (selection && Range.isExpanded(selection)) {\n                  Editor.deleteFragment(editor)\n                }\n              }\n            },\n            [attributes.onCompositionStart]\n          )}\n          onCopy={useCallback(\n            (event: React.ClipboardEvent<HTMLDivElement>) => {\n              if (\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onCopy)\n              ) {\n                event.preventDefault()\n                ReactEditor.setFragmentData(editor, event.clipboardData)\n              }\n            },\n            [attributes.onCopy]\n          )}\n          onCut={useCallback(\n            (event: React.ClipboardEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onCut)\n              ) {\n                event.preventDefault()\n                ReactEditor.setFragmentData(editor, event.clipboardData)\n                const { selection } = editor\n\n                if (selection) {\n                  if (Range.isExpanded(selection)) {\n                    Editor.deleteFragment(editor)\n                  } else {\n                    const node = Node.parent(editor, selection.anchor.path)\n                    if (Editor.isVoid(editor, node)) {\n                      Transforms.delete(editor)\n                    }\n                  }\n                }\n              }\n            },\n            [readOnly, attributes.onCut]\n          )}\n          onDragOver={useCallback(\n            (event: React.DragEvent<HTMLDivElement>) => {\n              if (\n                hasTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onDragOver)\n              ) {\n                // Only when the target is void, call `preventDefault` to signal\n                // that drops are allowed. Editable content is droppable by\n                // default, and calling `preventDefault` hides the cursor.\n                const node = ReactEditor.toSlateNode(editor, event.target)\n\n                if (Editor.isVoid(editor, node)) {\n                  event.preventDefault()\n                }\n              }\n            },\n            [attributes.onDragOver]\n          )}\n          onDragStart={useCallback(\n            (event: React.DragEvent<HTMLDivElement>) => {\n              if (\n                hasTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onDragStart)\n              ) {\n                const node = ReactEditor.toSlateNode(editor, event.target)\n                const path = ReactEditor.findPath(editor, node)\n                const voidMatch =\n                  Editor.isVoid(editor, node) ||\n                  Editor.void(editor, { at: path, voids: true })\n\n                // If starting a drag on a void node, make sure it is selected\n                // so that it shows up in the selection's fragment.\n                if (voidMatch) {\n                  const range = Editor.range(editor, path)\n                  Transforms.select(editor, range)\n                }\n\n                state.isDraggingInternally = true\n\n                ReactEditor.setFragmentData(editor, event.dataTransfer)\n              }\n            },\n            [attributes.onDragStart]\n          )}\n          onDrop={useCallback(\n            (event: React.DragEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                hasTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onDrop)\n              ) {\n                event.preventDefault()\n\n                // Keep a reference to the dragged range before updating selection\n                const draggedRange = editor.selection\n\n                // Find the range where the drop happened\n                const range = ReactEditor.findEventRange(editor, event)\n                const data = event.dataTransfer\n\n                Transforms.select(editor, range)\n\n                if (state.isDraggingInternally) {\n                  if (draggedRange) {\n                    Transforms.delete(editor, {\n                      at: draggedRange,\n                    })\n                  }\n\n                  state.isDraggingInternally = false\n                }\n\n                ReactEditor.insertData(editor, data)\n\n                // When dragging from another source into the editor, it's possible\n                // that the current editor does not have focus.\n                if (!ReactEditor.isFocused(editor)) {\n                  ReactEditor.focus(editor)\n                }\n              }\n            },\n            [readOnly, attributes.onDrop]\n          )}\n          onDragEnd={useCallback(\n            (event: React.DragEvent<HTMLDivElement>) => {\n              // When dropping on a different droppable element than the current editor,\n              // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n              // Note: `onDragEnd` is only called when `onDrop` is not called\n              if (\n                !readOnly &&\n                state.isDraggingInternally &&\n                hasTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onDragEnd)\n              ) {\n                state.isDraggingInternally = false\n              }\n            },\n            [readOnly, attributes.onDragEnd]\n          )}\n          onFocus={useCallback(\n            (event: React.FocusEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                !state.isUpdatingSelection &&\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onFocus)\n              ) {\n                const el = ReactEditor.toDOMNode(editor, editor)\n                const root = ReactEditor.findDocumentOrShadowRoot(editor)\n                state.latestElement = root.activeElement\n\n                // COMPAT: If the editor has nested editable elements, the focus\n                // can go to them. In Firefox, this must be prevented because it\n                // results in issues with keyboard navigation. (2017/03/30)\n                if (IS_FIREFOX && event.target !== el) {\n                  el.focus()\n                  return\n                }\n\n                IS_FOCUSED.set(editor, true)\n              }\n            },\n            [readOnly, attributes.onFocus]\n          )}\n          onKeyDown={useCallback(\n            (event: React.KeyboardEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onKeyDown)\n              ) {\n                const { nativeEvent } = event\n                const { selection } = editor\n\n                const element =\n                  editor.children[\n                    selection !== null ? selection.focus.path[0] : 0\n                  ]\n                const isRTL = getDirection(Node.string(element)) === 'rtl'\n\n                // COMPAT: Since we prevent the default behavior on\n                // `beforeinput` events, the browser doesn't think there's ever\n                // any history stack to undo or redo, so we have to manage these\n                // hotkeys ourselves. (2019/11/06)\n                if (Hotkeys.isRedo(nativeEvent)) {\n                  event.preventDefault()\n                  const maybeHistoryEditor: any = editor\n\n                  if (typeof maybeHistoryEditor.redo === 'function') {\n                    maybeHistoryEditor.redo()\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isUndo(nativeEvent)) {\n                  event.preventDefault()\n                  const maybeHistoryEditor: any = editor\n\n                  if (typeof maybeHistoryEditor.undo === 'function') {\n                    maybeHistoryEditor.undo()\n                  }\n\n                  return\n                }\n\n                // COMPAT: Certain browsers don't handle the selection updates\n                // properly. In Chrome, the selection isn't properly extended.\n                // And in Firefox, the selection isn't properly collapsed.\n                // (2017/10/17)\n                if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n                  event.preventDefault()\n                  Transforms.move(editor, { unit: 'line', reverse: true })\n                  return\n                }\n\n                if (Hotkeys.isMoveLineForward(nativeEvent)) {\n                  event.preventDefault()\n                  Transforms.move(editor, { unit: 'line' })\n                  return\n                }\n\n                if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n                  event.preventDefault()\n                  Transforms.move(editor, {\n                    unit: 'line',\n                    edge: 'focus',\n                    reverse: true,\n                  })\n                  return\n                }\n\n                if (Hotkeys.isExtendLineForward(nativeEvent)) {\n                  event.preventDefault()\n                  Transforms.move(editor, { unit: 'line', edge: 'focus' })\n                  return\n                }\n\n                // COMPAT: If a void node is selected, or a zero-width text node\n                // adjacent to an inline is selected, we need to handle these\n                // hotkeys manually because browsers won't be able to skip over\n                // the void node with the zero-width space not being an empty\n                // string.\n                if (Hotkeys.isMoveBackward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isCollapsed(selection)) {\n                    Transforms.move(editor, { reverse: !isRTL })\n                  } else {\n                    Transforms.collapse(editor, { edge: 'start' })\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isMoveForward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isCollapsed(selection)) {\n                    Transforms.move(editor, { reverse: isRTL })\n                  } else {\n                    Transforms.collapse(editor, { edge: 'end' })\n                  }\n\n                  return\n                }\n\n                if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    Transforms.collapse(editor, { edge: 'focus' })\n                  }\n\n                  Transforms.move(editor, { unit: 'word', reverse: !isRTL })\n                  return\n                }\n\n                if (Hotkeys.isMoveWordForward(nativeEvent)) {\n                  event.preventDefault()\n\n                  if (selection && Range.isExpanded(selection)) {\n                    Transforms.collapse(editor, { edge: 'focus' })\n                  }\n\n                  Transforms.move(editor, { unit: 'word', reverse: isRTL })\n                  return\n                }\n\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to guessing at the input intention for hotkeys.\n                // COMPAT: In iOS, some of these hotkeys are handled in the\n                if (!HAS_BEFORE_INPUT_SUPPORT) {\n                  // We don't have a core behavior for these, but they change the\n                  // DOM if we don't prevent them, so we have to.\n                  if (\n                    Hotkeys.isBold(nativeEvent) ||\n                    Hotkeys.isItalic(nativeEvent) ||\n                    Hotkeys.isTransposeCharacter(nativeEvent)\n                  ) {\n                    event.preventDefault()\n                    return\n                  }\n\n                  if (Hotkeys.isSplitBlock(nativeEvent)) {\n                    event.preventDefault()\n                    Editor.insertBreak(editor)\n                    return\n                  }\n\n                  if (Hotkeys.isDeleteBackward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor, { direction: 'backward' })\n                    } else {\n                      Editor.deleteBackward(editor)\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isDeleteForward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor, { direction: 'forward' })\n                    } else {\n                      Editor.deleteForward(editor)\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor, { direction: 'backward' })\n                    } else {\n                      Editor.deleteBackward(editor, { unit: 'line' })\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor, { direction: 'forward' })\n                    } else {\n                      Editor.deleteForward(editor, { unit: 'line' })\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor, { direction: 'backward' })\n                    } else {\n                      Editor.deleteBackward(editor, { unit: 'word' })\n                    }\n\n                    return\n                  }\n\n                  if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n                    event.preventDefault()\n\n                    if (selection && Range.isExpanded(selection)) {\n                      Editor.deleteFragment(editor, { direction: 'forward' })\n                    } else {\n                      Editor.deleteForward(editor, { unit: 'word' })\n                    }\n\n                    return\n                  }\n                } else {\n                  if (IS_CHROME || IS_SAFARI) {\n                    // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n                    // an event when deleting backwards in a selected void inline node\n                    if (\n                      selection &&\n                      (Hotkeys.isDeleteBackward(nativeEvent) ||\n                        Hotkeys.isDeleteForward(nativeEvent)) &&\n                      Range.isCollapsed(selection)\n                    ) {\n                      const currentNode = Node.parent(\n                        editor,\n                        selection.anchor.path\n                      )\n\n                      if (\n                        Element.isElement(currentNode) &&\n                        Editor.isVoid(editor, currentNode) &&\n                        Editor.isInline(editor, currentNode)\n                      ) {\n                        event.preventDefault()\n                        Transforms.delete(editor, { unit: 'block' })\n\n                        return\n                      }\n                    }\n                  }\n                }\n              }\n            },\n            [readOnly, attributes.onKeyDown]\n          )}\n          onPaste={useCallback(\n            (event: React.ClipboardEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onPaste)\n              ) {\n                // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n                // fall back to React's `onPaste` here instead.\n                // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n                // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n                if (\n                  !HAS_BEFORE_INPUT_SUPPORT ||\n                  isPlainTextOnlyPaste(event.nativeEvent)\n                ) {\n                  event.preventDefault()\n                  ReactEditor.insertData(editor, event.clipboardData)\n                }\n              }\n            },\n            [readOnly, attributes.onPaste]\n          )}\n        >\n          {useChildren({\n            decorations,\n            node: editor,\n            renderElement,\n            renderPlaceholder,\n            renderLeaf,\n            selection: editor.selection,\n          })}\n        </Component>\n      </DecorateContext.Provider>\n    </ReadOnlyContext.Provider>\n  )\n}\n\n/**\n * The props that get passed to renderPlaceholder\n */\nexport type RenderPlaceholderProps = {\n  children: any\n  attributes: {\n    'data-slate-placeholder': boolean\n    dir?: 'rtl'\n    contentEditable: boolean\n    ref: React.RefObject<any>\n    style: React.CSSProperties\n  }\n}\n\n/**\n * The default placeholder element\n */\n\nexport const DefaultPlaceholder = ({\n  attributes,\n  children,\n}: RenderPlaceholderProps) => <span {...attributes}>{children}</span>\n\n/**\n * A default memoized decorate function.\n */\n\nexport const defaultDecorate: (entry: NodeEntry) => Range[] = () => []\n\n/**\n * Check if two DOM range objects are equal.\n */\n\nexport const isRangeEqual = (a: DOMRange, b: DOMRange) => {\n  return (\n    (a.startContainer === b.startContainer &&\n      a.startOffset === b.startOffset &&\n      a.endContainer === b.endContainer &&\n      a.endOffset === b.endOffset) ||\n    (a.startContainer === b.endContainer &&\n      a.startOffset === b.endOffset &&\n      a.endContainer === b.startContainer &&\n      a.endOffset === b.startOffset)\n  )\n}\n\n/**\n * Check if the target is in the editor.\n */\n\nexport const hasTarget = (\n  editor: ReactEditor,\n  target: EventTarget | null\n): target is DOMNode => {\n  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target)\n}\n\n/**\n * Check if the target is editable and in the editor.\n */\n\nexport const hasEditableTarget = (\n  editor: ReactEditor,\n  target: EventTarget | null\n): target is DOMNode => {\n  return (\n    isDOMNode(target) &&\n    ReactEditor.hasDOMNode(editor, target, { editable: true })\n  )\n}\n\n/**\n * Check if the target is inside void and in the editor.\n */\n\nexport const isTargetInsideVoid = (\n  editor: ReactEditor,\n  target: EventTarget | null\n): boolean => {\n  const slateNode =\n    hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target)\n  return Editor.isVoid(editor, slateNode)\n}\n\n/**\n * Check if an event is overrided by a handler.\n */\n\nexport const isEventHandled = <\n  EventType extends React.SyntheticEvent<unknown, unknown>\n>(\n  event: EventType,\n  handler?: (event: EventType) => void | boolean\n) => {\n  if (!handler) {\n    return false\n  }\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  const shouldTreatEventAsHandled = handler(event)\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled\n  }\n\n  return event.isDefaultPrevented() || event.isPropagationStopped()\n}\n\n/**\n * Check if a DOM event is overrided by a handler.\n */\n\nexport const isDOMEventHandled = <E extends Event>(\n  event: E,\n  handler?: (event: E) => void | boolean\n) => {\n  if (!handler) {\n    return false\n  }\n\n  // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n  const shouldTreatEventAsHandled = handler(event)\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled\n  }\n\n  return event.defaultPrevented\n}\n","/**\n * An auto-incrementing identifier for keys.\n */\n\nlet n = 0\n\n/**\n * A class that keeps track of a key string. We use a full class here because we\n * want to be able to use them as keys in `WeakMap` objects.\n */\n\nexport class Key {\n  id: string\n\n  constructor() {\n    this.id = `${n++}`\n  }\n}\n","import { Editor, Node, Path, Point, Range, Transforms, BaseEditor } from 'slate'\n\nimport { Key } from '../utils/key'\nimport {\n  EDITOR_TO_ELEMENT,\n  ELEMENT_TO_NODE,\n  IS_FOCUSED,\n  IS_READ_ONLY,\n  KEY_TO_ELEMENT,\n  NODE_TO_INDEX,\n  NODE_TO_KEY,\n  NODE_TO_PARENT,\n  EDITOR_TO_WINDOW,\n} from '../utils/weak-maps'\nimport {\n  DOMElement,\n  DOMNode,\n  DOMPoint,\n  DOMRange,\n  DOMSelection,\n  DOMStaticRange,\n  isDOMElement,\n  isDOMSelection,\n  normalizeDOMPoint,\n  hasShadowRoot,\n} from '../utils/dom'\nimport { IS_CHROME } from '../utils/environment'\n\n/**\n * A React and DOM-specific version of the `Editor` interface.\n */\n\nexport interface ReactEditor extends BaseEditor {\n  insertData: (data: DataTransfer) => void\n  setFragmentData: (data: DataTransfer) => void\n  hasRange: (editor: ReactEditor, range: Range) => boolean\n}\n\nexport const ReactEditor = {\n  /**\n   * Return the host window of the current editor.\n   */\n\n  getWindow(editor: ReactEditor): Window {\n    const window = EDITOR_TO_WINDOW.get(editor)\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor')\n    }\n    return window\n  },\n\n  /**\n   * Find a key for a Slate node.\n   */\n\n  findKey(editor: ReactEditor, node: Node): Key {\n    let key = NODE_TO_KEY.get(node)\n\n    if (!key) {\n      key = new Key()\n      NODE_TO_KEY.set(node, key)\n    }\n\n    return key\n  },\n\n  /**\n   * Find the path of Slate node.\n   */\n\n  findPath(editor: ReactEditor, node: Node): Path {\n    const path: Path = []\n    let child = node\n\n    while (true) {\n      const parent = NODE_TO_PARENT.get(child)\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path\n        } else {\n          break\n        }\n      }\n\n      const i = NODE_TO_INDEX.get(child)\n\n      if (i == null) {\n        break\n      }\n\n      path.unshift(i)\n      child = parent\n    }\n\n    throw new Error(\n      `Unable to find the path for Slate node: ${JSON.stringify(node)}`\n    )\n  },\n\n  /**\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\n   */\n\n  findDocumentOrShadowRoot(editor: ReactEditor): Document | ShadowRoot {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    const root = el.getRootNode()\n\n    // The below exception will always be thrown for iframes because the document inside an iframe\n    // does not inherit it's prototype from the parent document, therefore we return early\n    if (el.ownerDocument !== document) return el.ownerDocument\n\n    if (!(root instanceof Document || root instanceof ShadowRoot))\n      throw new Error(\n        `Unable to find DocumentOrShadowRoot for editor element: ${el}`\n      )\n\n    // COMPAT: Only Chrome implements the DocumentOrShadowRoot mixin for\n    // ShadowRoot; other browsers still implement it on the Document\n    // interface. (2020/08/08)\n    // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot#Properties\n    if (root.getSelection === undefined && el.ownerDocument !== null)\n      return el.ownerDocument\n\n    return root\n  },\n\n  /**\n   * Check if the editor is focused.\n   */\n\n  isFocused(editor: ReactEditor): boolean {\n    return !!IS_FOCUSED.get(editor)\n  },\n\n  /**\n   * Check if the editor is in read-only mode.\n   */\n\n  isReadOnly(editor: ReactEditor): boolean {\n    return !!IS_READ_ONLY.get(editor)\n  },\n\n  /**\n   * Blur the editor.\n   */\n\n  blur(editor: ReactEditor): void {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    IS_FOCUSED.set(editor, false)\n\n    if (root.activeElement === el) {\n      el.blur()\n    }\n  },\n\n  /**\n   * Focus the editor.\n   */\n\n  focus(editor: ReactEditor): void {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    IS_FOCUSED.set(editor, true)\n\n    if (root.activeElement !== el) {\n      el.focus({ preventScroll: true })\n    }\n  },\n\n  /**\n   * Deselect the editor.\n   */\n\n  deselect(editor: ReactEditor): void {\n    const el = ReactEditor.toDOMNode(editor, editor)\n    const { selection } = editor\n    const root = ReactEditor.findDocumentOrShadowRoot(editor)\n    const domSelection = root.getSelection()\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges()\n    }\n\n    if (selection) {\n      Transforms.deselect(editor)\n    }\n  },\n\n  /**\n   * Check if a DOM node is within the editor.\n   */\n\n  hasDOMNode(\n    editor: ReactEditor,\n    target: DOMNode,\n    options: { editable?: boolean } = {}\n  ): boolean {\n    const { editable = false } = options\n    const editorEl = ReactEditor.toDOMNode(editor, editor)\n    let targetEl\n\n    // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n    try {\n      targetEl = (isDOMElement(target)\n        ? target\n        : target.parentElement) as HTMLElement\n    } catch (err) {\n      if (\n        !err.message.includes('Permission denied to access property \"nodeType\"')\n      ) {\n        throw err\n      }\n    }\n\n    if (!targetEl) {\n      return false\n    }\n\n    return (\n      targetEl.closest(`[data-slate-editor]`) === editorEl &&\n      (!editable ||\n        targetEl.isContentEditable ||\n        !!targetEl.getAttribute('data-slate-zero-width'))\n    )\n  },\n\n  /**\n   * Insert data from a `DataTransfer` into the editor.\n   */\n\n  insertData(editor: ReactEditor, data: DataTransfer): void {\n    editor.insertData(data)\n  },\n\n  /**\n   * Sets data from the currently selected fragment on a `DataTransfer`.\n   */\n\n  setFragmentData(editor: ReactEditor, data: DataTransfer): void {\n    editor.setFragmentData(data)\n  },\n\n  /**\n   * Find the native DOM element from a Slate node.\n   */\n\n  toDOMNode(editor: ReactEditor, node: Node): HTMLElement {\n    const domNode = Editor.isEditor(node)\n      ? EDITOR_TO_ELEMENT.get(editor)\n      : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node))\n\n    if (!domNode) {\n      throw new Error(\n        `Cannot resolve a DOM node from Slate node: ${JSON.stringify(node)}`\n      )\n    }\n\n    return domNode\n  },\n\n  /**\n   * Find a native DOM selection point from a Slate point.\n   */\n\n  toDOMPoint(editor: ReactEditor, point: Point): DOMPoint {\n    const [node] = Editor.node(editor, point.path)\n    const el = ReactEditor.toDOMNode(editor, node)\n    let domPoint: DOMPoint | undefined\n\n    // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n    if (Editor.void(editor, { at: point })) {\n      point = { path: point.path, offset: 0 }\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n    const selector = `[data-slate-string], [data-slate-zero-width]`\n    const texts = Array.from(el.querySelectorAll(selector))\n    let start = 0\n\n    for (const text of texts) {\n      const domNode = text.childNodes[0] as HTMLElement\n\n      if (domNode == null || domNode.textContent == null) {\n        continue\n      }\n\n      const { length } = domNode.textContent\n      const attr = text.getAttribute('data-slate-length')\n      const trueLength = attr == null ? length : parseInt(attr, 10)\n      const end = start + trueLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(length, Math.max(0, point.offset - start))\n        domPoint = [domNode, offset]\n        break\n      }\n\n      start = end\n    }\n\n    if (!domPoint) {\n      throw new Error(\n        `Cannot resolve a DOM point from Slate point: ${JSON.stringify(point)}`\n      )\n    }\n\n    return domPoint\n  },\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\n   *\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\n   */\n\n  toDOMRange(editor: ReactEditor, range: Range): DOMRange {\n    const { anchor, focus } = range\n    const isBackward = Range.isBackward(range)\n    const domAnchor = ReactEditor.toDOMPoint(editor, anchor)\n    const domFocus = Range.isCollapsed(range)\n      ? domAnchor\n      : ReactEditor.toDOMPoint(editor, focus)\n\n    const window = ReactEditor.getWindow(editor)\n    const domRange = window.document.createRange()\n    const [startNode, startOffset] = isBackward ? domFocus : domAnchor\n    const [endNode, endOffset] = isBackward ? domAnchor : domFocus\n\n    // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n    const startEl = (isDOMElement(startNode)\n      ? startNode\n      : startNode.parentElement) as HTMLElement\n    const isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width')\n    const endEl = (isDOMElement(endNode)\n      ? endNode\n      : endNode.parentElement) as HTMLElement\n    const isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width')\n\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset)\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset)\n    return domRange\n  },\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   */\n\n  toSlateNode(editor: ReactEditor, domNode: DOMNode): Node {\n    let domEl = isDOMElement(domNode) ? domNode : domNode.parentElement\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(`[data-slate-node]`)\n    }\n\n    const node = domEl ? ELEMENT_TO_NODE.get(domEl as HTMLElement) : null\n\n    if (!node) {\n      throw new Error(`Cannot resolve a Slate node from DOM node: ${domEl}`)\n    }\n\n    return node\n  },\n\n  /**\n   * Get the target range from a DOM `event`.\n   */\n\n  findEventRange(editor: ReactEditor, event: any): Range {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent\n    }\n\n    const { clientX: x, clientY: y, target } = event\n\n    if (x == null || y == null) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    const node = ReactEditor.toSlateNode(editor, event.target)\n    const path = ReactEditor.findPath(editor, node)\n\n    // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n    if (Editor.isVoid(editor, node)) {\n      const rect = target.getBoundingClientRect()\n      const isPrev = editor.isInline(node)\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n      const edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end',\n      })\n      const point = isPrev\n        ? Editor.before(editor, edge)\n        : Editor.after(editor, edge)\n\n      if (point) {\n        const range = Editor.range(editor, point)\n        return range\n      }\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    let domRange\n    const { document } = window\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y)\n    } else {\n      const position = document.caretPositionFromPoint(x, y)\n\n      if (position) {\n        domRange = document.createRange()\n        domRange.setStart(position.offsetNode, position.offset)\n        domRange.setEnd(position.offsetNode, position.offset)\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(`Cannot resolve a Slate range from a DOM event: ${event}`)\n    }\n\n    // Resolve a Slate range from the DOM range.\n    const range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n    })\n    return range\n  },\n\n  /**\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\n   */\n\n  toSlatePoint<T extends boolean>(\n    editor: ReactEditor,\n    domPoint: DOMPoint,\n    exactMatch: T\n  ): T extends true ? Point | null : Point {\n    const [nearestNode, nearestOffset] = exactMatch\n      ? domPoint\n      : normalizeDOMPoint(domPoint)\n    const parentNode = nearestNode.parentNode as DOMElement\n    let textNode: DOMElement | null = null\n    let offset = 0\n\n    if (parentNode) {\n      const voidNode = parentNode.closest('[data-slate-void=\"true\"]')\n      let leafNode = parentNode.closest('[data-slate-leaf]')\n      let domNode: DOMElement | null = null\n\n      // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]')!\n        const window = ReactEditor.getWindow(editor)\n        const range = window.document.createRange()\n        range.setStart(textNode, 0)\n        range.setEnd(nearestNode, nearestOffset)\n        const contents = range.cloneContents()\n        const removals = [\n          ...Array.prototype.slice.call(\n            contents.querySelectorAll('[data-slate-zero-width]')\n          ),\n          ...Array.prototype.slice.call(\n            contents.querySelectorAll('[contenteditable=false]')\n          ),\n        ]\n\n        removals.forEach(el => {\n          el!.parentNode!.removeChild(el)\n        })\n\n        // COMPAT: Edge has a bug where Range.prototype.toString() will\n        // convert \\n into \\r\\n. The bug causes a loop when slate-react\n        // attempts to reposition its cursor to match the native position. Use\n        // textContent.length instead.\n        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n        offset = contents.textContent!.length\n        domNode = textNode\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent.\n        leafNode = voidNode.querySelector('[data-slate-leaf]')!\n\n        // COMPAT: In read-only editors the leaf is not rendered.\n        if (!leafNode) {\n          offset = 1\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]')!\n          domNode = leafNode\n          offset = domNode.textContent!.length\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent!.length\n          })\n        }\n      }\n\n      // COMPAT: If the parent node is a Slate zero-width space, editor is\n      // because the text node should have no characters. However, during IME\n      // composition the ASCII characters will be prepended to the zero-width\n      // space, so subtract 1 from the offset to account for the zero-width\n      // space character.\n      if (\n        domNode &&\n        offset === domNode.textContent!.length &&\n        parentNode.hasAttribute('data-slate-zero-width')\n      ) {\n        offset--\n      }\n    }\n\n    if (!textNode) {\n      if (exactMatch) {\n        return null as T extends true ? Point | null : Point\n      }\n      throw new Error(\n        `Cannot resolve a Slate point from DOM point: ${domPoint}`\n      )\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n    const slateNode = ReactEditor.toSlateNode(editor, textNode!)\n    const path = ReactEditor.findPath(editor, slateNode)\n    return { path, offset } as T extends true ? Point | null : Point\n  },\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   */\n\n  toSlateRange<T extends boolean>(\n    editor: ReactEditor,\n    domRange: DOMRange | DOMStaticRange | DOMSelection,\n    options: {\n      exactMatch: T\n    }\n  ): T extends true ? Range | null : Range {\n    const { exactMatch } = options\n    const el = isDOMSelection(domRange)\n      ? domRange.anchorNode\n      : domRange.startContainer\n    let anchorNode\n    let anchorOffset\n    let focusNode\n    let focusOffset\n    let isCollapsed\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode\n        anchorOffset = domRange.anchorOffset\n        focusNode = domRange.focusNode\n        focusOffset = domRange.focusOffset\n        // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed =\n            domRange.anchorNode === domRange.focusNode &&\n            domRange.anchorOffset === domRange.focusOffset\n        } else {\n          isCollapsed = domRange.isCollapsed\n        }\n      } else {\n        anchorNode = domRange.startContainer\n        anchorOffset = domRange.startOffset\n        focusNode = domRange.endContainer\n        focusOffset = domRange.endOffset\n        isCollapsed = domRange.collapsed\n      }\n    }\n\n    if (\n      anchorNode == null ||\n      focusNode == null ||\n      anchorOffset == null ||\n      focusOffset == null\n    ) {\n      throw new Error(\n        `Cannot resolve a Slate range from DOM range: ${domRange}`\n      )\n    }\n\n    const anchor = ReactEditor.toSlatePoint(\n      editor,\n      [anchorNode, anchorOffset],\n      exactMatch\n    )\n    if (!anchor) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    const focus = isCollapsed\n      ? anchor\n      : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], exactMatch)\n    if (!focus) {\n      return null as T extends true ? Range | null : Range\n    }\n\n    return ({ anchor, focus } as unknown) as T extends true\n      ? Range | null\n      : Range\n  },\n\n  hasRange(editor: ReactEditor, range: Range): boolean {\n    const { anchor, focus } = range\n    return (\n      Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path)\n    )\n  },\n}\n","import { Editor, Path, Range, Text } from 'slate'\n\nimport { ReactEditor } from '../../'\nimport { DOMNode } from '../../utils/dom'\n\nexport type Diff = {\n  start: number\n  end: number\n  insertText: string\n  removeText: string\n}\n\nexport interface TextInsertion {\n  text: Diff\n  path: Path\n}\n\ntype TextRange = {\n  start: number\n  end: number\n}\n\n/**\n * Returns the number of characters that are the same at the beginning of the\n * String.\n *\n * @param prev  the previous text\n * @param next  the next text\n * @returns the offset of the start of the difference; null if there is no difference\n */\nfunction getDiffStart(prev: string, next: string): number | null {\n  const length = Math.min(prev.length, next.length)\n\n  for (let i = 0; i < length; i++) {\n    if (prev.charAt(i) !== next.charAt(i)) return i\n  }\n\n  if (prev.length !== next.length) return length\n  return null\n}\n\n/**\n * Returns the number of characters that are the same at the end of the String\n * up to `max`. Max prevents double-counting characters when there are\n * multiple duplicate characters around the diff area.\n *\n * @param prev  the previous text\n * @param next  the next text\n * @param max  the max length to test.\n * @returns number of characters that are the same at the end of the string\n */\nfunction getDiffEnd(prev: string, next: string, max: number): number | null {\n  const prevLength = prev.length\n  const nextLength = next.length\n  const length = Math.min(prevLength, nextLength, max)\n\n  for (let i = 0; i < length; i++) {\n    const prevChar = prev.charAt(prevLength - i - 1)\n    const nextChar = next.charAt(nextLength - i - 1)\n    if (prevChar !== nextChar) return i\n  }\n\n  if (prev.length !== next.length) return length\n  return null\n}\n\n/**\n * Takes two strings and returns an object representing two offsets. The\n * first, `start` represents the number of characters that are the same at\n * the front of the String. The `end` represents the number of characters\n * that are the same at the end of the String.\n *\n * Returns null if they are identical.\n *\n * @param prev  the previous text\n * @param next  the next text\n * @returns the difference text range; null if there are no differences.\n */\nfunction getDiffOffsets(prev: string, next: string): TextRange | null {\n  if (prev === next) return null\n  const start = getDiffStart(prev, next)\n  if (start === null) return null\n  const maxEnd = Math.min(prev.length - start, next.length - start)\n  const end = getDiffEnd(prev, next, maxEnd)!\n  if (end === null) return null\n  return { start, end }\n}\n\n/**\n * Takes a text string and returns a slice from the string at the given text range\n *\n * @param text  the text\n * @param offsets  the text range\n * @returns the text slice at text range\n */\nfunction sliceText(text: string, offsets: TextRange): string {\n  return text.slice(offsets.start, text.length - offsets.end)\n}\n\n/**\n * Takes two strings and returns a smart diff that can be used to describe the\n * change in a way that can be used as operations like inserting, removing or\n * replacing text.\n *\n * @param prev the previous text\n * @param next the next text\n * @returns the text difference\n */\nexport function diffText(prev?: string, next?: string): Diff | null {\n  if (prev === undefined || next === undefined) return null\n  const offsets = getDiffOffsets(prev, next)\n  if (offsets == null) return null\n  const insertText = sliceText(next, offsets)\n  const removeText = sliceText(prev, offsets)\n  return {\n    start: offsets.start,\n    end: prev.length - offsets.end,\n    insertText,\n    removeText,\n  }\n}\n\nexport function combineInsertedText(insertedText: TextInsertion[]): string {\n  return insertedText.reduce((acc, { text }) => `${acc}${text.insertText}`, '')\n}\n\nexport function getTextInsertion<T extends Editor>(\n  editor: T,\n  domNode: DOMNode\n): TextInsertion | undefined {\n  const node = ReactEditor.toSlateNode(editor, domNode)\n\n  if (!Text.isText(node)) {\n    return undefined\n  }\n\n  const prevText = node.text\n  let nextText = domNode.textContent!\n\n  // textContent will pad an extra \\n when the textContent ends with an \\n\n  if (nextText.endsWith('\\n')) {\n    nextText = nextText.slice(0, nextText.length - 1)\n  }\n\n  // If the text is no different, there is no diff.\n  if (nextText !== prevText) {\n    const textDiff = diffText(prevText, nextText)\n    if (textDiff !== null) {\n      const textPath = ReactEditor.findPath(editor, node)\n\n      return {\n        text: textDiff,\n        path: textPath,\n      }\n    }\n  }\n\n  return undefined\n}\n\nexport function normalizeTextInsertionRange(\n  editor: Editor,\n  range: Range | null,\n  { path, text }: TextInsertion\n) {\n  const insertionRange = {\n    anchor: { path, offset: text.start },\n    focus: { path, offset: text.end },\n  }\n\n  if (!range || !Range.isCollapsed(range)) {\n    return insertionRange\n  }\n\n  const { insertText, removeText } = text\n  const isSingleCharacterInsertion =\n    insertText.length === 1 || removeText.length === 1\n\n  /**\n   * This code handles edge cases that arise from text diffing when the\n   * inserted or removed character is a single character, and the character\n   * right before or after the anchor is the same as the one being inserted or\n   * removed.\n   *\n   * Take this example: hello|o\n   *\n   * If another `o` is inserted at the selection's anchor in the example above,\n   * it should be inserted at the anchor, but using text diffing, we actually\n   * detect that the character was inserted after the second `o`:\n   *\n   * helloo[o]|\n   *\n   * Instead, in these very specific edge cases, we assume that the character\n   * needs to be inserted after the anchor rather than where the diff was found:\n   *\n   * hello[o]|o\n   */\n  if (isSingleCharacterInsertion && Path.equals(range.anchor.path, path)) {\n    const [text] = Array.from(\n      Editor.nodes(editor, { at: range, match: Text.isText })\n    )\n\n    if (text) {\n      const [node] = text\n      const { anchor } = range\n      const characterBeforeAnchor = node.text[anchor.offset - 1]\n      const characterAfterAnchor = node.text[anchor.offset]\n\n      if (insertText.length === 1 && insertText === characterAfterAnchor) {\n        // Assume text should be inserted at the anchor\n        return range\n      }\n\n      if (removeText.length === 1 && removeText === characterBeforeAnchor) {\n        // Assume text should be removed right before the anchor\n        return {\n          anchor: { path, offset: anchor.offset - 1 },\n          focus: { path, offset: anchor.offset },\n        }\n      }\n    }\n  }\n\n  return insertionRange\n}\n","import { ReactEditor } from '../..'\nimport { EDITOR_TO_RESTORE_DOM } from '../../utils/weak-maps'\n\nexport function restoreDOM(editor: ReactEditor) {\n  try {\n    const onRestoreDOM = EDITOR_TO_RESTORE_DOM.get(editor)\n    if (onRestoreDOM) {\n      onRestoreDOM()\n    }\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err)\n  }\n}\n","import { ReactEditor } from '../../plugin/react-editor'\nimport { Editor, Range, Transforms } from 'slate'\n\nimport { DOMNode } from '../../utils/dom'\n\nimport {\n  normalizeTextInsertionRange,\n  combineInsertedText,\n  TextInsertion,\n} from './diff-text'\nimport {\n  gatherMutationData,\n  isDeletion,\n  isLineBreak,\n  isRemoveLeafNodes,\n  isReplaceExpandedSelection,\n  isTextInsertion,\n} from './mutation-detection'\nimport { restoreDOM } from './restore-dom'\n\n// Replace with `const debug = console.log` to debug\nconst debug = (...message: any[]) => {}\n\n/**\n * Based loosely on:\n *\n * https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js\n * https://github.com/ProseMirror/prosemirror-view/blob/master/src/domobserver.js\n *\n * The input manager attempts to map observed mutations on the document to a\n * set of operations in order to reconcile Slate's internal value with the DOM.\n *\n * Mutations are processed synchronously as they come in. Only mutations that occur\n * during a user input loop are processed, as other mutations can occur within the\n * document that were not initiated by user input.\n *\n * The mutation reconciliation process attempts to match mutations to the following\n * patterns:\n *\n * - Text updates\n * - Deletions\n * - Line breaks\n *\n * @param editor\n */\n\nexport class AndroidInputManager {\n  constructor(private editor: ReactEditor) {\n    this.editor = editor\n  }\n\n  /**\n   * Handle MutationObserver flush\n   *\n   * @param mutations\n   */\n\n  flush = (mutations: MutationRecord[]) => {\n    debug('flush')\n\n    try {\n      this.reconcileMutations(mutations)\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error(err)\n\n      // Failed to reconcile mutations, restore DOM to its previous state\n      restoreDOM(this.editor)\n    }\n  }\n\n  /**\n   * Reconcile a batch of mutations\n   *\n   * @param mutations\n   */\n\n  private reconcileMutations = (mutations: MutationRecord[]) => {\n    const mutationData = gatherMutationData(this.editor, mutations)\n    const { insertedText, removedNodes } = mutationData\n\n    debug('processMutations', mutations, mutationData)\n\n    if (isReplaceExpandedSelection(this.editor, mutationData)) {\n      const text = combineInsertedText(insertedText)\n      this.replaceExpandedSelection(text)\n    } else if (isLineBreak(this.editor, mutationData)) {\n      this.insertBreak()\n    } else if (isRemoveLeafNodes(this.editor, mutationData)) {\n      this.removeLeafNodes(removedNodes)\n    } else if (isDeletion(this.editor, mutationData)) {\n      this.deleteBackward()\n    } else if (isTextInsertion(this.editor, mutationData)) {\n      this.insertText(insertedText)\n    }\n  }\n\n  /**\n   * Apply text diff\n   */\n\n  private insertText = (insertedText: TextInsertion[]) => {\n    debug('insertText')\n\n    const { selection } = this.editor\n\n    // Insert the batched text diffs\n    insertedText.forEach(insertion => {\n      Transforms.insertText(this.editor, insertion.text.insertText, {\n        at: normalizeTextInsertionRange(this.editor, selection, insertion),\n      })\n    })\n  }\n\n  /**\n   * Handle line breaks\n   */\n\n  private insertBreak = () => {\n    debug('insertBreak')\n\n    const { selection } = this.editor\n\n    Editor.insertBreak(this.editor)\n\n    // To-do: Need a more granular solution to restoring only a specific portion\n    // of the document. Restoring the entire document is expensive.\n    restoreDOM(this.editor)\n\n    if (selection) {\n      // Compat: Move selection to the newly inserted block if it has not moved\n      setTimeout(() => {\n        if (\n          this.editor.selection &&\n          Range.equals(selection, this.editor.selection)\n        ) {\n          Transforms.move(this.editor)\n        }\n      }, 100)\n    }\n  }\n\n  /**\n   * Handle expanded selection being deleted or replaced by text\n   */\n\n  private replaceExpandedSelection = (text: string) => {\n    debug('replaceExpandedSelection')\n\n    // Delete expanded selection\n    Editor.deleteFragment(this.editor)\n\n    if (text.length) {\n      // Selection was replaced by text, insert the entire text diff\n      Editor.insertText(this.editor, text)\n    }\n\n    restoreDOM(this.editor)\n  }\n\n  /**\n   * Handle `backspace` that merges blocks\n   */\n\n  private deleteBackward = () => {\n    debug('deleteBackward')\n\n    Editor.deleteBackward(this.editor)\n    ReactEditor.focus(this.editor)\n\n    restoreDOM(this.editor)\n  }\n\n  /**\n   * Handle mutations that remove specific leaves\n   */\n  private removeLeafNodes = (nodes: DOMNode[]) => {\n    for (const node of nodes) {\n      const slateNode = ReactEditor.toSlateNode(this.editor, node)\n\n      if (slateNode) {\n        const path = ReactEditor.findPath(this.editor, slateNode)\n\n        Transforms.delete(this.editor, { at: path })\n        restoreDOM(this.editor)\n      }\n    }\n  }\n}\n\nexport default AndroidInputManager\n","import { Editor, Node, Path, Range } from 'slate'\n\nimport { DOMNode } from '../../utils/dom'\nimport { ReactEditor } from '../..'\nimport { TextInsertion, getTextInsertion } from './diff-text'\n\ninterface MutationData {\n  addedNodes: DOMNode[]\n  removedNodes: DOMNode[]\n  insertedText: TextInsertion[]\n  characterDataMutations: MutationRecord[]\n}\n\ntype MutationDetection = (editor: Editor, mutationData: MutationData) => boolean\n\nexport function gatherMutationData(\n  editor: Editor,\n  mutations: MutationRecord[]\n): MutationData {\n  const addedNodes: DOMNode[] = []\n  const removedNodes: DOMNode[] = []\n  const insertedText: TextInsertion[] = []\n  const characterDataMutations: MutationRecord[] = []\n\n  mutations.forEach(mutation => {\n    switch (mutation.type) {\n      case 'childList': {\n        if (mutation.addedNodes.length) {\n          mutation.addedNodes.forEach(addedNode => {\n            addedNodes.push(addedNode)\n          })\n        }\n\n        mutation.removedNodes.forEach(removedNode => {\n          removedNodes.push(removedNode)\n        })\n\n        break\n      }\n      case 'characterData': {\n        characterDataMutations.push(mutation)\n\n        // Changes to text nodes should consider the parent element\n        const { parentNode } = mutation.target\n\n        if (!parentNode) {\n          return\n        }\n\n        const textInsertion = getTextInsertion(editor, parentNode)\n\n        if (!textInsertion) {\n          return\n        }\n\n        // If we've already detected a diff at that path, we can return early\n        if (\n          insertedText.some(({ path }) => Path.equals(path, textInsertion.path))\n        ) {\n          return\n        }\n\n        // Add the text diff to the array of detected text insertions that need to be reconciled\n        insertedText.push(textInsertion)\n      }\n    }\n  })\n\n  return { addedNodes, removedNodes, insertedText, characterDataMutations }\n}\n\n/**\n * In general, when a line break occurs, there will be more `addedNodes` than `removedNodes`.\n *\n * This isn't always the case however. In some cases, there will be more `removedNodes` than\n * `addedNodes`.\n *\n * To account for these edge cases, the most reliable strategy to detect line break mutations\n * is to check whether a new block was inserted of the same type as the current block.\n */\nexport const isLineBreak: MutationDetection = (editor, { addedNodes }) => {\n  const { selection } = editor\n  const parentNode = selection\n    ? Node.parent(editor, selection.anchor.path)\n    : null\n  const parentDOMNode = parentNode\n    ? ReactEditor.toDOMNode(editor, parentNode)\n    : null\n\n  if (!parentDOMNode) {\n    return false\n  }\n\n  return addedNodes.some(\n    addedNode =>\n      addedNode instanceof HTMLElement &&\n      addedNode.tagName === parentDOMNode?.tagName\n  )\n}\n\n/**\n * So long as we check for line break mutations before deletion mutations,\n * we can safely assume that a set of mutations was a deletion if there are\n * removed nodes.\n */\nexport const isDeletion: MutationDetection = (_, { removedNodes }) => {\n  return removedNodes.length > 0\n}\n\n/**\n * If the selection was expanded and there are removed nodes,\n * the contents of the selection need to be replaced with the diff\n */\nexport const isReplaceExpandedSelection: MutationDetection = (\n  { selection },\n  { removedNodes }\n) => {\n  return selection\n    ? Range.isExpanded(selection) && removedNodes.length > 0\n    : false\n}\n\n/**\n * Plain text insertion\n */\nexport const isTextInsertion: MutationDetection = (_, { insertedText }) => {\n  return insertedText.length > 0\n}\n\n/**\n * Edge case. Detect mutations that remove leaf nodes and also update character data\n */\nexport const isRemoveLeafNodes: MutationDetection = (\n  _,\n  { addedNodes, characterDataMutations, removedNodes }\n) => {\n  return (\n    removedNodes.length > 0 &&\n    addedNodes.length === 0 &&\n    characterDataMutations.length > 0\n  )\n}\n","import { RefObject, useCallback, useRef, useState } from 'react'\n\nimport { useSlateStatic } from '../../hooks/use-slate-static'\n\nimport { AndroidInputManager } from './android-input-manager'\nimport { useMutationObserver } from './use-mutation-observer'\nimport { useTrackUserInput } from './use-track-user-input'\n\nconst MUTATION_OBSERVER_CONFIG: MutationObserverInit = {\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true,\n  subtree: true,\n}\n\nexport function useAndroidInputManager(node: RefObject<HTMLElement>) {\n  const editor = useSlateStatic()\n  const [inputManager] = useState(() => new AndroidInputManager(editor))\n  const { receivedUserInput, onUserInput } = useTrackUserInput()\n  const timeoutId = useRef<NodeJS.Timeout | null>(null)\n  const isReconciling = useRef(false)\n  const flush = useCallback((mutations: MutationRecord[]) => {\n    if (!receivedUserInput.current) {\n      return\n    }\n\n    isReconciling.current = true\n    inputManager.flush(mutations)\n\n    if (timeoutId.current) {\n      clearTimeout(timeoutId.current)\n    }\n\n    timeoutId.current = setTimeout(() => {\n      isReconciling.current = false\n      timeoutId.current = null\n    }, 250)\n  }, [])\n\n  useMutationObserver(node, flush, MUTATION_OBSERVER_CONFIG)\n\n  return {\n    isReconciling,\n    onUserInput,\n  }\n}\n","import { useCallback, useEffect, useRef } from 'react'\n\nimport { ReactEditor } from '../..'\nimport { useSlateStatic } from '../../hooks/use-slate-static'\n\nexport function useTrackUserInput() {\n  const editor = useSlateStatic()\n  const receivedUserInput = useRef<boolean>(false)\n  const animationFrameRef = useRef<number | null>(null)\n  const onUserInput = useCallback(() => {\n    if (receivedUserInput.current === false) {\n      const window = ReactEditor.getWindow(editor)\n\n      receivedUserInput.current = true\n\n      if (animationFrameRef.current) {\n        window.cancelAnimationFrame(animationFrameRef.current)\n      }\n\n      animationFrameRef.current = window.requestAnimationFrame(() => {\n        receivedUserInput.current = false\n        animationFrameRef.current = null\n      })\n    }\n  }, [])\n\n  useEffect(() => {\n    // Reset user input tracking on every render\n    if (receivedUserInput.current) {\n      receivedUserInput.current = false\n    }\n  })\n\n  return {\n    receivedUserInput,\n    onUserInput,\n  }\n}\n","import { RefObject, useEffect, useState } from 'react'\nimport { useIsomorphicLayoutEffect } from '../../hooks/use-isomorphic-layout-effect'\n\nexport function useMutationObserver(\n  node: RefObject<HTMLElement>,\n  callback: MutationCallback,\n  options: MutationObserverInit\n) {\n  const [mutationObserver] = useState(() => new MutationObserver(callback))\n\n  useIsomorphicLayoutEffect(() => {\n    // Disconnect mutation observer during render phase\n    mutationObserver.disconnect()\n  })\n\n  useEffect(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined')\n    }\n\n    // Attach mutation observer after render phase has finished\n    mutationObserver.observe(node.current, options)\n\n    // Clean up after effect\n    return mutationObserver.disconnect.bind(mutationObserver)\n  })\n}\n","import { createContext, useContext } from 'react'\n\n/**\n * A React context for sharing the `focused` state of the editor.\n */\n\nexport const FocusedContext = createContext(false)\n\n/**\n * Get the current `focused` state of the editor.\n */\n\nexport const useFocused = (): boolean => {\n  return useContext(FocusedContext)\n}\n","import React, { useMemo, useState, useCallback, useEffect } from 'react'\nimport { Editor, Node, Element, Descendant } from 'slate'\nimport invariant from 'tiny-invariant'\n\nimport { ReactEditor } from '../plugin/react-editor'\nimport { FocusedContext } from '../hooks/use-focused'\nimport { EditorContext } from '../hooks/use-slate-static'\nimport { SlateContext } from '../hooks/use-slate'\nimport { EDITOR_TO_ON_CHANGE } from '../utils/weak-maps'\nimport { useIsomorphicLayoutEffect } from '../hooks/use-isomorphic-layout-effect'\n\n/**\n * A wrapper around the provider to handle `onChange` events, because the editor\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\n */\n\nexport const Slate = (props: {\n  editor: ReactEditor\n  value: Descendant[]\n  children: React.ReactNode\n  onChange: (value: Descendant[]) => void\n}) => {\n  const { editor, children, onChange, value, ...rest } = props\n  const [key, setKey] = useState(0)\n  const context: [ReactEditor] = useMemo(() => {\n    invariant(\n      Node.isNodeList(value),\n      `[Slate] value is invalid! Expected a list of elements but got: ${JSON.stringify(\n        value\n      )}`\n    )\n    invariant(\n      Editor.isEditor(editor),\n      `[Slate] editor is invalid! you passed: ${JSON.stringify(editor)}`\n    )\n\n    editor.children = value\n    Object.assign(editor, rest)\n    return [editor]\n  }, [key, value, ...Object.values(rest)])\n\n  const onContextChange = useCallback(() => {\n    onChange(editor.children)\n    setKey(key + 1)\n  }, [key, onChange])\n\n  EDITOR_TO_ON_CHANGE.set(editor, onContextChange)\n\n  useEffect(() => {\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {})\n    }\n  }, [])\n\n  const [isFocused, setIsFocused] = useState(ReactEditor.isFocused(editor))\n\n  useEffect(() => {\n    setIsFocused(ReactEditor.isFocused(editor))\n  })\n\n  useIsomorphicLayoutEffect(() => {\n    const fn = () => setIsFocused(ReactEditor.isFocused(editor))\n    document.addEventListener('focus', fn, true)\n    return () => document.removeEventListener('focus', fn, true)\n  }, [])\n\n  useIsomorphicLayoutEffect(() => {\n    const fn = () => setIsFocused(ReactEditor.isFocused(editor))\n    document.addEventListener('blur', fn, true)\n    return () => document.removeEventListener('blur', fn, true)\n  }, [])\n\n  return (\n    <SlateContext.Provider value={context}>\n      <EditorContext.Provider value={editor}>\n        <FocusedContext.Provider value={isFocused}>\n          {children}\n        </FocusedContext.Provider>\n      </EditorContext.Provider>\n    </SlateContext.Provider>\n  )\n}\n","/**\n * Utilities for single-line deletion\n */\n\nimport { Range, Editor } from 'slate'\nimport { ReactEditor } from '..'\n\nconst doRectsIntersect = (rect: DOMRect, compareRect: DOMRect) => {\n  const middle = (compareRect.top + compareRect.bottom) / 2\n\n  return rect.top <= middle && rect.bottom >= middle\n}\n\nconst areRangesSameLine = (\n  editor: ReactEditor,\n  range1: Range,\n  range2: Range\n) => {\n  const rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect()\n  const rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect()\n\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1)\n}\n\n/**\n * A helper utility that returns the end portion of a `Range`\n * which is located on a single line.\n *\n * @param {Editor} editor The editor object to compare against\n * @param {Range} parentRange The parent range to compare against\n * @returns {Range} A valid portion of the parentRange which is one a single line\n */\nexport const findCurrentLineRange = (\n  editor: ReactEditor,\n  parentRange: Range\n): Range => {\n  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange))\n  const positions = Array.from(Editor.positions(editor, { at: parentRange }))\n\n  let left = 0\n  let right = positions.length\n  let middle = Math.floor(right / 2)\n\n  if (\n    areRangesSameLine(\n      editor,\n      Editor.range(editor, positions[left]),\n      parentRangeBoundary\n    )\n  ) {\n    return Editor.range(editor, positions[left], parentRangeBoundary)\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(\n      editor,\n      positions[positions.length - 1],\n      parentRangeBoundary\n    )\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (\n      areRangesSameLine(\n        editor,\n        Editor.range(editor, positions[middle]),\n        parentRangeBoundary\n      )\n    ) {\n      right = middle\n    } else {\n      left = middle\n    }\n\n    middle = Math.floor((left + right) / 2)\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary)\n}\n","import ReactDOM from 'react-dom'\nimport { Editor, Node, Path, Operation, Transforms, Range } from 'slate'\n\nimport { ReactEditor } from './react-editor'\nimport { Key } from '../utils/key'\nimport { EDITOR_TO_ON_CHANGE, NODE_TO_KEY } from '../utils/weak-maps'\nimport { isDOMText, getPlainText } from '../utils/dom'\nimport { findCurrentLineRange } from '../utils/lines'\n\n/**\n * `withReact` adds React and DOM specific behaviors to the editor.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withReact = <T extends Editor>(editor: T) => {\n  const e = editor as T & ReactEditor\n  const { apply, onChange, deleteBackward } = e\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit)\n    }\n\n    if (editor.selection && Range.isCollapsed(editor.selection)) {\n      const parentBlockEntry = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: editor.selection,\n      })\n\n      if (parentBlockEntry) {\n        const [, parentBlockPath] = parentBlockEntry\n        const parentElementRange = Editor.range(\n          editor,\n          parentBlockPath,\n          editor.selection.anchor\n        )\n\n        const currentLineRange = findCurrentLineRange(e, parentElementRange)\n\n        if (!Range.isCollapsed(currentLineRange)) {\n          Transforms.delete(editor, { at: currentLineRange })\n        }\n      }\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const matches: [Path, Key][] = []\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node': {\n        for (const [node, path] of Editor.levels(e, { at: op.path })) {\n          const key = ReactEditor.findKey(e, node)\n          matches.push([path, key])\n        }\n\n        break\n      }\n\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node': {\n        for (const [node, path] of Editor.levels(e, {\n          at: Path.parent(op.path),\n        })) {\n          const key = ReactEditor.findKey(e, node)\n          matches.push([path, key])\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        for (const [node, path] of Editor.levels(e, {\n          at: Path.common(Path.parent(op.path), Path.parent(op.newPath)),\n        })) {\n          const key = ReactEditor.findKey(e, node)\n          matches.push([path, key])\n        }\n        break\n      }\n    }\n\n    apply(op)\n\n    for (const [path, key] of matches) {\n      const [node] = Editor.node(e, path)\n      NODE_TO_KEY.set(node, key)\n    }\n  }\n\n  e.setFragmentData = (data: DataTransfer) => {\n    const { selection } = e\n\n    if (!selection) {\n      return\n    }\n\n    const [start, end] = Range.edges(selection)\n    const startVoid = Editor.void(e, { at: start.path })\n    const endVoid = Editor.void(e, { at: end.path })\n\n    if (Range.isCollapsed(selection) && !startVoid) {\n      return\n    }\n\n    // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n    const domRange = ReactEditor.toDOMRange(e, selection)\n    let contents = domRange.cloneContents()\n    let attach = contents.childNodes[0] as HTMLElement\n\n    // Make sure attach is non-empty, since empty nodes will not get copied.\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node as HTMLElement\n      }\n    })\n\n    // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n    if (endVoid) {\n      const [voidNode] = endVoid\n      const r = domRange.cloneRange()\n      const domNode = ReactEditor.toDOMNode(e, voidNode)\n      r.setEndAfter(domNode)\n      contents = r.cloneContents()\n    }\n\n    // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]')! as HTMLElement\n    }\n\n    // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(\n      zw => {\n        const isNewline = zw.getAttribute('data-slate-zero-width') === 'n'\n        zw.textContent = isNewline ? '\\n' : ''\n      }\n    )\n\n    // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n    if (isDOMText(attach)) {\n      const span = document.createElement('span')\n      // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n      span.style.whiteSpace = 'pre'\n      span.appendChild(attach)\n      contents.appendChild(span)\n      attach = span\n    }\n\n    const fragment = e.getFragment()\n    const string = JSON.stringify(fragment)\n    const encoded = window.btoa(encodeURIComponent(string))\n    attach.setAttribute('data-slate-fragment', encoded)\n    data.setData('application/x-slate-fragment', encoded)\n\n    // Add the content to a <div> so that we can get its inner HTML.\n    const div = document.createElement('div')\n    div.appendChild(contents)\n    div.setAttribute('hidden', 'true')\n    document.body.appendChild(div)\n    data.setData('text/html', div.innerHTML)\n    data.setData('text/plain', getPlainText(div))\n    document.body.removeChild(div)\n  }\n\n  e.insertData = (data: DataTransfer) => {\n    const fragment = data.getData('application/x-slate-fragment')\n\n    if (fragment) {\n      const decoded = decodeURIComponent(window.atob(fragment))\n      const parsed = JSON.parse(decoded) as Node[]\n      e.insertFragment(parsed)\n      return\n    }\n\n    const text = data.getData('text/plain')\n\n    if (text) {\n      const lines = text.split(/\\r\\n|\\r|\\n/)\n      let split = false\n\n      for (const line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, { always: true })\n        }\n\n        e.insertText(line)\n        split = true\n      }\n    }\n  }\n\n  e.onChange = () => {\n    // COMPAT: React doesn't batch `setState` hook calls, which means that the\n    // children and selection can get out of sync for one render pass. So we\n    // have to use this unstable API to ensure it batches them. (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    ReactDOM.unstable_batchedUpdates(() => {\n      const onContextChange = EDITOR_TO_ON_CHANGE.get(e)\n\n      if (onContextChange) {\n        onContextChange()\n      }\n\n      onChange()\n    })\n  }\n\n  return e\n}\n","import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react'\nimport { Descendant, Editor, Element, Node, Range, Transforms } from 'slate'\nimport throttle from 'lodash/throttle'\nimport scrollIntoView from 'scroll-into-view-if-needed'\n\nimport { DefaultPlaceholder, ReactEditor } from '../..'\nimport { ReadOnlyContext } from '../../hooks/use-read-only'\nimport { useSlate } from '../../hooks/use-slate'\nimport { useIsomorphicLayoutEffect } from '../../hooks/use-isomorphic-layout-effect'\nimport { DecorateContext } from '../../hooks/use-decorate'\nimport {\n  DOMElement,\n  isDOMElement,\n  isDOMNode,\n  getDefaultView,\n  isPlainTextOnlyPaste,\n} from '../../utils/dom'\nimport {\n  EDITOR_TO_ELEMENT,\n  EDITOR_TO_RESTORE_DOM,\n  EDITOR_TO_WINDOW,\n  ELEMENT_TO_NODE,\n  IS_FOCUSED,\n  IS_READ_ONLY,\n  NODE_TO_ELEMENT,\n  PLACEHOLDER_SYMBOL,\n} from '../../utils/weak-maps'\nimport { EditableProps } from '../editable'\nimport useChildren from '../../hooks/use-children'\nimport {\n  defaultDecorate,\n  hasEditableTarget,\n  isEventHandled,\n  isDOMEventHandled,\n  isTargetInsideVoid,\n} from '../editable'\n\nimport { useAndroidInputManager } from './use-android-input-manager'\n\n/**\n * Editable.\n */\n\nexport const AndroidEditable = (props: EditableProps): JSX.Element => {\n  const {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = props => <DefaultPlaceholder {...props} />,\n    style = {},\n    as: Component = 'div',\n    ...attributes\n  } = props\n  const editor = useSlate()\n  const ref = useRef<HTMLDivElement>(null)\n  const inputManager = useAndroidInputManager(ref)\n\n  // Update internal state on each render.\n  IS_READ_ONLY.set(editor, readOnly)\n\n  // Keep track of some state for the event handler logic.\n  const state = useMemo(\n    () => ({\n      isUpdatingSelection: false,\n      latestElement: null as DOMElement | null,\n    }),\n    []\n  )\n\n  const [contentKey, setContentKey] = useState(0)\n  const onRestoreDOM = useCallback(() => {\n    setContentKey(prev => prev + 1)\n  }, [contentKey])\n\n  // Whenever the editor updates...\n  useIsomorphicLayoutEffect(() => {\n    // Update element-related weak maps with the DOM element ref.\n    let window\n\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window)\n      EDITOR_TO_ELEMENT.set(editor, ref.current)\n      NODE_TO_ELEMENT.set(editor, ref.current)\n      ELEMENT_TO_NODE.set(ref.current, editor)\n      EDITOR_TO_RESTORE_DOM.set(editor, onRestoreDOM)\n    } else {\n      NODE_TO_ELEMENT.delete(editor)\n      EDITOR_TO_RESTORE_DOM.delete(editor)\n    }\n\n    try {\n      // Make sure the DOM selection state is in sync.\n      const { selection } = editor\n      const root = ReactEditor.findDocumentOrShadowRoot(editor)\n      const domSelection = root.getSelection()\n\n      if (!domSelection || !ReactEditor.isFocused(editor)) {\n        return\n      }\n\n      const hasDomSelection = domSelection.type !== 'None'\n\n      // If the DOM selection is properly unset, we're done.\n      if (!selection && !hasDomSelection) {\n        return\n      }\n\n      // verify that the dom selection is in the editor\n      const editorElement = EDITOR_TO_ELEMENT.get(editor)!\n      let hasDomSelectionInEditor = false\n      if (\n        editorElement.contains(domSelection.anchorNode) &&\n        editorElement.contains(domSelection.focusNode)\n      ) {\n        hasDomSelectionInEditor = true\n      }\n\n      // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n      if (hasDomSelection && hasDomSelectionInEditor && selection) {\n        const slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n        })\n        if (slateRange && Range.equals(slateRange, selection)) {\n          return\n        }\n      }\n\n      // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n        })\n        return\n      }\n\n      // Otherwise the DOM selection is out of sync, so update it.\n      const el = ReactEditor.toDOMNode(editor, editor)\n      state.isUpdatingSelection = true\n\n      const newDomRange = selection && ReactEditor.toDOMRange(editor, selection)\n\n      if (newDomRange) {\n        if (Range.isBackward(selection!)) {\n          domSelection.setBaseAndExtent(\n            newDomRange.endContainer,\n            newDomRange.endOffset,\n            newDomRange.startContainer,\n            newDomRange.startOffset\n          )\n        } else {\n          domSelection.setBaseAndExtent(\n            newDomRange.startContainer,\n            newDomRange.startOffset,\n            newDomRange.endContainer,\n            newDomRange.endOffset\n          )\n        }\n        const leafEl = newDomRange.startContainer.parentElement!\n        leafEl.getBoundingClientRect = newDomRange.getBoundingClientRect.bind(\n          newDomRange\n        )\n        scrollIntoView(leafEl, {\n          scrollMode: 'if-needed',\n          boundary: el,\n        })\n        // @ts-ignore\n        delete leafEl.getBoundingClientRect\n      } else {\n        domSelection.removeAllRanges()\n      }\n\n      setTimeout(() => {\n        state.isUpdatingSelection = false\n      })\n    } catch {\n      // Failed to update selection, likely due to reconciliation error\n      state.isUpdatingSelection = false\n    }\n  })\n\n  // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n  useEffect(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus()\n    }\n  }, [autoFocus])\n\n  // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n  const onDOMBeforeInput = useCallback(\n    (event: InputEvent) => {\n      if (\n        !readOnly &&\n        hasEditableTarget(editor, event.target) &&\n        !isDOMEventHandled(event, propsOnDOMBeforeInput)\n      ) {\n        inputManager.onUserInput()\n      }\n    },\n    [readOnly, propsOnDOMBeforeInput]\n  )\n\n  // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  useIsomorphicLayoutEffect(() => {\n    const node = ref.current\n\n    // @ts-ignore The `beforeinput` event isn't recognized.\n    node?.addEventListener('beforeinput', onDOMBeforeInput)\n\n    // @ts-ignore The `beforeinput` event isn't recognized.\n    return () => node?.removeEventListener('beforeinput', onDOMBeforeInput)\n  }, [contentKey, propsOnDOMBeforeInput])\n\n  // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n  const onDOMSelectionChange = useCallback(\n    throttle(() => {\n      try {\n        if (\n          !readOnly &&\n          !state.isUpdatingSelection &&\n          !inputManager.isReconciling.current\n        ) {\n          const root = ReactEditor.findDocumentOrShadowRoot(editor)\n          const { activeElement } = root\n          const el = ReactEditor.toDOMNode(editor, editor)\n          const domSelection = root.getSelection()\n\n          if (activeElement === el) {\n            state.latestElement = activeElement\n            IS_FOCUSED.set(editor, true)\n          } else {\n            IS_FOCUSED.delete(editor)\n          }\n\n          if (!domSelection) {\n            return Transforms.deselect(editor)\n          }\n\n          const { anchorNode, focusNode } = domSelection\n\n          const anchorNodeSelectable =\n            hasEditableTarget(editor, anchorNode) ||\n            isTargetInsideVoid(editor, anchorNode)\n\n          const focusNodeSelectable =\n            hasEditableTarget(editor, focusNode) ||\n            isTargetInsideVoid(editor, focusNode)\n\n          if (anchorNodeSelectable && focusNodeSelectable) {\n            const range = ReactEditor.toSlateRange(editor, domSelection, {\n              exactMatch: false,\n            })\n            Transforms.select(editor, range)\n          } else {\n            Transforms.deselect(editor)\n          }\n        }\n      } catch {\n        // Failed to update selection, likely due to reconciliation error\n      }\n    }, 100),\n    [readOnly]\n  )\n\n  // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n  useIsomorphicLayoutEffect(() => {\n    const window = ReactEditor.getWindow(editor)\n    window.document.addEventListener('selectionchange', onDOMSelectionChange)\n\n    return () => {\n      window.document.removeEventListener(\n        'selectionchange',\n        onDOMSelectionChange\n      )\n    }\n  })\n\n  const decorations = decorate([editor, []])\n\n  if (\n    placeholder &&\n    editor.children.length === 1 &&\n    Array.from(Node.texts(editor)).length === 1 &&\n    Node.string(editor) === ''\n  ) {\n    const start = Editor.start(editor, [])\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start,\n      focus: start,\n    })\n  }\n\n  return (\n    <ReadOnlyContext.Provider value={readOnly}>\n      <DecorateContext.Provider value={decorate}>\n        <Component\n          key={contentKey}\n          role={readOnly ? undefined : 'textbox'}\n          {...attributes}\n          spellCheck={attributes.spellCheck}\n          autoCorrect={attributes.autoCorrect}\n          autoCapitalize={attributes.autoCapitalize}\n          data-slate-editor\n          data-slate-node=\"value\"\n          contentEditable={readOnly ? undefined : true}\n          suppressContentEditableWarning\n          ref={ref}\n          style={{\n            // Allow positioning relative to the editable element.\n            position: 'relative',\n            // Prevent the default outline styles.\n            outline: 'none',\n            // Preserve adjacent whitespace and new lines.\n            whiteSpace: 'pre-wrap',\n            // Allow words to break if they are too long.\n            wordWrap: 'break-word',\n            // Allow for passed-in styles to override anything.\n            ...style,\n          }}\n          onCopy={useCallback(\n            (event: React.ClipboardEvent<HTMLDivElement>) => {\n              if (\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onCopy)\n              ) {\n                event.preventDefault()\n                ReactEditor.setFragmentData(editor, event.clipboardData)\n              }\n            },\n            [attributes.onCopy]\n          )}\n          onCut={useCallback(\n            (event: React.ClipboardEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onCut)\n              ) {\n                event.preventDefault()\n                ReactEditor.setFragmentData(editor, event.clipboardData)\n                const { selection } = editor\n\n                if (selection) {\n                  if (Range.isExpanded(selection)) {\n                    Editor.deleteFragment(editor)\n                  } else {\n                    const node = Node.parent(editor, selection.anchor.path)\n                    if (Editor.isVoid(editor, node)) {\n                      Transforms.delete(editor)\n                    }\n                  }\n                }\n              }\n            },\n            [readOnly, attributes.onCut]\n          )}\n          onFocus={useCallback(\n            (event: React.FocusEvent<HTMLDivElement>) => {\n              if (\n                !readOnly &&\n                !state.isUpdatingSelection &&\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onFocus)\n              ) {\n                const root = ReactEditor.findDocumentOrShadowRoot(editor)\n                state.latestElement = root.activeElement\n\n                IS_FOCUSED.set(editor, true)\n              }\n            },\n            [readOnly, attributes.onFocus]\n          )}\n          onBlur={useCallback(\n            (event: React.FocusEvent<HTMLDivElement>) => {\n              if (\n                readOnly ||\n                state.isUpdatingSelection ||\n                !hasEditableTarget(editor, event.target) ||\n                isEventHandled(event, attributes.onBlur)\n              ) {\n                return\n              }\n\n              // COMPAT: If the current `activeElement` is still the previous\n              // one, this is due to the window being blurred when the tab\n              // itself becomes unfocused, so we want to abort early to allow to\n              // editor to stay focused when the tab becomes focused again.\n              const root = ReactEditor.findDocumentOrShadowRoot(editor)\n              if (state.latestElement === root.activeElement) {\n                return\n              }\n\n              const { relatedTarget } = event\n              const el = ReactEditor.toDOMNode(editor, editor)\n\n              // COMPAT: The event should be ignored if the focus is returning\n              // to the editor from an embedded editable element (eg. an <input>\n              // element inside a void node).\n              if (relatedTarget === el) {\n                return\n              }\n\n              // COMPAT: The event should be ignored if the focus is moving from\n              // the editor to inside a void node's spacer element.\n              if (\n                isDOMElement(relatedTarget) &&\n                relatedTarget.hasAttribute('data-slate-spacer')\n              ) {\n                return\n              }\n\n              // COMPAT: The event should be ignored if the focus is moving to a\n              // non- editable section of an element that isn't a void node (eg.\n              // a list item of the check list example).\n              if (\n                relatedTarget != null &&\n                isDOMNode(relatedTarget) &&\n                ReactEditor.hasDOMNode(editor, relatedTarget)\n              ) {\n                const node = ReactEditor.toSlateNode(editor, relatedTarget)\n\n                if (Element.isElement(node) && !editor.isVoid(node)) {\n                  return\n                }\n              }\n\n              IS_FOCUSED.delete(editor)\n            },\n            [readOnly, attributes.onBlur]\n          )}\n          onPaste={useCallback(\n            (event: React.ClipboardEvent<HTMLDivElement>) => {\n              // This unfortunately needs to be handled with paste events instead.\n              if (\n                hasEditableTarget(editor, event.target) &&\n                !isEventHandled(event, attributes.onPaste) &&\n                !readOnly\n              ) {\n                event.preventDefault()\n                ReactEditor.insertData(editor, event.clipboardData)\n              }\n            },\n            [readOnly, attributes.onPaste]\n          )}\n        >\n          {useChildren({\n            decorations,\n            node: editor,\n            renderElement,\n            renderPlaceholder,\n            renderLeaf,\n            selection: editor.selection,\n          })}\n        </Component>\n      </DecorateContext.Provider>\n    </ReadOnlyContext.Provider>\n  )\n}\n","import createCache from '@emotion/cache';\nimport { serializeStyles } from '@emotion/serialize';\nimport { getRegisteredStyles, insertStyles } from '@emotion/utils';\n\nfunction insertWithoutScoping(cache, serialized) {\n  if (cache.inserted[serialized.name] === undefined) {\n    return cache.insert('', serialized, cache.sheet, true);\n  }\n}\n\nfunction merge(registered, css, className) {\n  var registeredStyles = [];\n  var rawClassName = getRegisteredStyles(registered, registeredStyles, className);\n\n  if (registeredStyles.length < 2) {\n    return className;\n  }\n\n  return rawClassName + css(registeredStyles);\n}\n\nvar createEmotion = function createEmotion(options) {\n  var cache = createCache(options); // $FlowFixMe\n\n  cache.sheet.speedy = function (value) {\n    if (process.env.NODE_ENV !== 'production' && this.ctr !== 0) {\n      throw new Error('speedy must be changed before any rules are inserted');\n    }\n\n    this.isSpeedy = value;\n  };\n\n  cache.compat = true;\n\n  var css = function css() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var serialized = serializeStyles(args, cache.registered, undefined);\n    insertStyles(cache, serialized, false);\n    return cache.key + \"-\" + serialized.name;\n  };\n\n  var keyframes = function keyframes() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    var serialized = serializeStyles(args, cache.registered);\n    var animation = \"animation-\" + serialized.name;\n    insertWithoutScoping(cache, {\n      name: serialized.name,\n      styles: \"@keyframes \" + animation + \"{\" + serialized.styles + \"}\"\n    });\n    return animation;\n  };\n\n  var injectGlobal = function injectGlobal() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    var serialized = serializeStyles(args, cache.registered);\n    insertWithoutScoping(cache, serialized);\n  };\n\n  var cx = function cx() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n\n    return merge(cache.registered, css, classnames(args));\n  };\n\n  return {\n    css: css,\n    cx: cx,\n    injectGlobal: injectGlobal,\n    keyframes: keyframes,\n    hydrate: function hydrate(ids) {\n      ids.forEach(function (key) {\n        cache.inserted[key] = true;\n      });\n    },\n    flush: function flush() {\n      cache.registered = {};\n      cache.inserted = {};\n      cache.sheet.flush();\n    },\n    // $FlowFixMe\n    sheet: cache.sheet,\n    cache: cache,\n    getRegisteredStyles: getRegisteredStyles.bind(null, cache.registered),\n    merge: merge.bind(null, cache.registered, css)\n  };\n};\n\nvar classnames = function classnames(args) {\n  var cls = '';\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    if (arg == null) continue;\n    var toAdd = void 0;\n\n    switch (typeof arg) {\n      case 'boolean':\n        break;\n\n      case 'object':\n        {\n          if (Array.isArray(arg)) {\n            toAdd = classnames(arg);\n          } else {\n            toAdd = '';\n\n            for (var k in arg) {\n              if (arg[k] && k) {\n                toAdd && (toAdd += ' ');\n                toAdd += k;\n              }\n            }\n          }\n\n          break;\n        }\n\n      default:\n        {\n          toAdd = arg;\n        }\n    }\n\n    if (toAdd) {\n      cls && (cls += ' ');\n      cls += toAdd;\n    }\n  }\n\n  return cls;\n};\n\nexport default createEmotion;\n","import '@emotion/cache';\nimport '@emotion/serialize';\nimport '@emotion/utils';\nimport createEmotion from '../create-instance/dist/emotion-css-create-instance.esm.js';\n\nvar _createEmotion = createEmotion({\n  key: 'css'\n}),\n    flush = _createEmotion.flush,\n    hydrate = _createEmotion.hydrate,\n    cx = _createEmotion.cx,\n    merge = _createEmotion.merge,\n    getRegisteredStyles = _createEmotion.getRegisteredStyles,\n    injectGlobal = _createEmotion.injectGlobal,\n    keyframes = _createEmotion.keyframes,\n    css = _createEmotion.css,\n    sheet = _createEmotion.sheet,\n    cache = _createEmotion.cache;\n\nexport { cache, css, cx, flush, getRegisteredStyles, hydrate, injectGlobal, keyframes, merge, sheet };\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n}\n\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\nexport default isPlainObject;\n","/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n","var freeGlobal = require('./_freeGlobal');\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n","var root = require('./_root');\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n","/*! https://mths.be/esrever v0.2.0 by @mathias */\n;(function(root) {\n\n\t// Detect free variables `exports`\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar regexSymbolWithCombiningMarks = /([\\0-\\u02FF\\u0370-\\u1AAF\\u1B00-\\u1DBF\\u1E00-\\u20CF\\u2100-\\uD7FF\\uE000-\\uFE1F\\uFE30-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])([\\u0300-\\u036F\\u1AB0-\\u1AFF\\u1DC0-\\u1DFF\\u20D0-\\u20FF\\uFE20-\\uFE2F]+)/g;\n\tvar regexSurrogatePair = /([\\uD800-\\uDBFF])([\\uDC00-\\uDFFF])/g;\n\n\tvar reverse = function(string) {\n\t\t// Step 1: deal with combining marks and astral symbols (surrogate pairs)\n\t\tstring = string\n\t\t\t// Swap symbols with their combining marks so the combining marks go first\n\t\t\t.replace(regexSymbolWithCombiningMarks, function($0, $1, $2) {\n\t\t\t\t// Reverse the combining marks so they will end up in the same order\n\t\t\t\t// later on (after another round of reversing)\n\t\t\t\treturn reverse($2) + $1;\n\t\t\t})\n\t\t\t// Swap high and low surrogates so the low surrogates go first\n\t\t\t.replace(regexSurrogatePair, '$2$1');\n\t\t// Step 2: reverse the code units in the string\n\t\tvar result = '';\n\t\tvar index = string.length;\n\t\twhile (index--) {\n\t\t\tresult += string.charAt(index);\n\t\t}\n\t\treturn result;\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar esrever = {\n\t\t'version': '0.2.0',\n\t\t'reverse': reverse\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(function() {\n\t\t\treturn esrever;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = esrever;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in esrever) {\n\t\t\t\tesrever.hasOwnProperty(key) && (freeExports[key] = esrever[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.esrever = esrever;\n\t}\n\n}(this));\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict'\n\nmodule.exports = direction\n\nvar RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nvar LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\nvar rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\nvar ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nfunction direction(value) {\n  value = String(value || '')\n\n  if (rtl.test(value)) {\n    return 'rtl'\n  }\n\n  if (ltr.test(value)) {\n    return 'ltr'\n  }\n\n  return 'neutral'\n}\n","var debounce = require('./debounce'),\n    isObject = require('./isObject');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n","var isObject = require('./isObject'),\n    now = require('./now'),\n    toNumber = require('./toNumber');\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n","var root = require('./_root');\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n","var baseTrim = require('./_baseTrim'),\n    isObject = require('./isObject'),\n    isSymbol = require('./isSymbol');\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n","var trimmedEndIndex = require('./_trimmedEndIndex');\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n","/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n","var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n","var Symbol = require('./_Symbol'),\n    getRawTag = require('./_getRawTag'),\n    objectToString = require('./_objectToString');\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n","var Symbol = require('./_Symbol');\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n"],"sourceRoot":""}
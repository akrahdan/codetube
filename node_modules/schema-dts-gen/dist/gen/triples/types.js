"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rdfs = exports.SchemaString = exports.UrlNode = void 0;
const url_1 = require("url");
function fromString(urlString) {
    const url = new url_1.URL(urlString);
    return {
        href: url.href,
        protocol: url.protocol,
        hostname: url.hostname,
        path: url.pathname.slice(1).split('/'),
        search: url.search,
    };
}
function pathEqual(first, second) {
    if (first.length !== second.length)
        return false;
    for (let i = 0; i < first.length; ++i) {
        if (first[i] !== second[i])
            return false;
    }
    return true;
}
/**
 * In-memory representation of a node in a Triple corresponding to a URL.
 *
 * @example <http://schema.org/domainIncludes>
 */
class UrlNode {
    constructor(name, context, href) {
        this.name = name;
        this.context = context;
        this.href = href;
        this.type = 'UrlNode';
    }
    toString() {
        return this.href;
    }
    matchesContext(contextIn) {
        const context = typeof contextIn === 'string' ? fromString(contextIn) : contextIn;
        if (this.context.protocol !== context.protocol) {
            // Schema.org schema uses 'http:' as protocol, but increasingly Schema.org
            // recommends using https: instead.
            //
            // If UrlNode is http and provided context is https, consider this a match
            // still...
            if (this.context.protocol === 'http:' && context.protocol === 'https:') {
                // Ignore.
            }
            else {
                return false;
            }
        }
        return (this.context.hostname === context.hostname &&
            pathEqual(this.context.path, context.path) &&
            this.context.search === context.search);
    }
    equivTo(other) {
        return (this.href === other.href ||
            (this.matchesContext(other.context) && this.name === other.name));
    }
    static Parse(urlString) {
        const url = new url_1.URL(urlString);
        if (url.hash) {
            return new UrlNode(
            /*name=*/ url.hash.slice(1), 
            /*context=*/ fromString(url.origin + url.pathname + url.search), 
            /*href=*/ url.href);
        }
        if (url.search) {
            throw new Error(`Can't handle Search string in ${url.search} in ${url.href}`);
        }
        const split = url.pathname.split('/');
        const name = split.pop();
        if (!name) {
            throw new Error(`Unexpected URL ${url.href} with no room for 'name'.`);
        }
        const context = url.origin + split.join('/');
        return new UrlNode(name, fromString(context), url.href);
    }
}
exports.UrlNode = UrlNode;
/**
 * In-memory representation of a node in a Triple corresponding to a string
 * literal.
 *
 * @example "BodyOfWater"
 * @example "BodyOfWater"@en
 */
class SchemaString {
    constructor(value, language) {
        this.value = value;
        this.language = language;
        this.type = 'SchemaString';
    }
    toString() {
        return this.language
            ? `"${this.value}@${this.language}`
            : `"${this.value}"`;
    }
    static Parse(content) {
        const result = /^"(([^"]|(\\"))+)"(?:@([a-zA-Z]+))?$/.exec(content);
        if (result) {
            return new SchemaString(result[1].replace(/\\"/g, '"'), result[4]);
        }
        return null;
    }
}
exports.SchemaString = SchemaString;
/**
 * In-memory representation of a compact Node corresponding to a relative RDFS
 * reference.
 *
 * @example <rdfs:label>
 */
class Rdfs {
    constructor(label) {
        this.label = label;
        this.type = 'Rdfs';
    }
    toString() {
        return `rdfs:${this.label}`;
    }
    static Parse(content) {
        const result = /^rdfs:(.+)$/.exec(content);
        return result && new Rdfs(result[1]);
    }
}
exports.Rdfs = Rdfs;
//# sourceMappingURL=types.js.map
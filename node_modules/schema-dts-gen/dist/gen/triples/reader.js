"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.process = exports.loadFile = exports.load = exports.toTripleStrings = void 0;
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const https_1 = __importDefault(require("https"));
const fs_1 = __importDefault(require("fs"));
const readline_1 = __importDefault(require("readline"));
const rxjs_1 = require("rxjs");
const logging_1 = require("../logging");
const assert_1 = require("../util/assert");
const types_1 = require("./types");
function unWrap(maker) {
    return (content) => {
        const result = /^<([^<>]+)>$/.exec(content);
        if (result)
            return maker(result[1]);
        return null;
    };
}
function subject(content) {
    return types_1.UrlNode.Parse(content);
}
function predicate(content) {
    return types_1.UrlNode.Parse(content);
}
function object(content) {
    const o = unWrap(types_1.Rdfs.Parse)(content) ||
        unWrap(types_1.UrlNode.Parse)(content) ||
        types_1.SchemaString.Parse(content);
    assert_1.assert(o, `Unexpected: ${content}.`);
    return o;
}
const totalRegex = /\s*<([^<>]+)>\s*<([^<>]+)>\s*((?:<[^<>"]+>)|(?:"(?:[^"]|(?:\\"))+(?:[^\"]|\\")"(?:@[a-zA-Z]+)?))\s*\./;
function toTripleStrings(data) {
    const linearTriples = data
        .join('')
        .split(totalRegex)
        .map(s => s.trim())
        .filter(s => s.length > 0);
    return linearTriples.reduce((result, _, index, array) => {
        if (index % 3 === 0) {
            result.push(array.slice(index, index + 3));
        }
        return result;
    }, []);
}
exports.toTripleStrings = toTripleStrings;
/**
 * Loads schema all Triples from a given Schema file and version.
 */
function load(url) {
    return new rxjs_1.Observable(subscriber => {
        handleUrl(url, subscriber);
    });
}
exports.load = load;
/**
 * does the same as load(), but for a local file
 */
function loadFile(path) {
    return new rxjs_1.Observable(subscriber => {
        handleFile(path, subscriber);
    });
}
exports.loadFile = loadFile;
function handleFile(path, subscriber) {
    const rl = readline_1.default.createInterface({
        input: fs_1.default.createReadStream(path),
        crlfDelay: Infinity,
    });
    const data = [];
    rl.on('line', (line) => {
        data.push(line);
    });
    rl.on('close', () => {
        try {
            const triples = toTripleStrings(data);
            for (const triple of process(triples)) {
                subscriber.next(triple);
            }
        }
        catch (error) {
            logging_1.Log(`Caught Error on end: ${error}`);
            subscriber.error(error);
        }
        subscriber.complete();
    });
}
function handleUrl(url, subscriber) {
    https_1.default
        .get(url, response => {
        logging_1.Log(`Got Response ${response.statusCode}: ${response.statusMessage}.`);
        if (response.statusCode !== 200) {
            const location = response.headers['location'] || response.headers['content-location'];
            if (location) {
                logging_1.Log(`Handling redirect to ${location}...`);
                handleUrl(location, subscriber);
                return;
            }
            subscriber.error(`Got Errored Response ${response.statusCode}: ${response.statusMessage}.`);
            return;
        }
        const data = [];
        response.on('data', (chunkB) => {
            const chunk = chunkB.toString('utf-8');
            data.push(chunk);
        });
        response.on('end', () => {
            try {
                const triples = toTripleStrings(data);
                for (const triple of process(triples)) {
                    subscriber.next(triple);
                }
            }
            catch (error) {
                logging_1.Log(`Caught Error on end: ${error}`);
                subscriber.error(error);
            }
            subscriber.complete();
        });
        response.on('error', error => {
            logging_1.Log(`Saw error: ${error}`);
            subscriber.error(error);
        });
    })
        .on('error', e => subscriber.error(e));
}
function* process(triples) {
    for (const match of triples) {
        if (match.length !== 3) {
            throw Error(`Unexpected ${match}`);
        }
        if (match[0].includes('file:///')) {
            // Inexplicably, local files end up in the public schema for
            // certain layer overlays.
            continue;
        }
        // Schema.org 3.4 all-layers used to contain a test comment:
        // (Subject:    <http://meta.schema.org/>
        //  Predicate:  <http://www.w3.org/2000/01/rdf-schema#comment>
        //  Object:     "A test comment.")
        // We skip it manually.
        if (/http[s]?:\/\/meta.schema.org\//.test(match[0])) {
            continue;
        }
        if (match[1] === 'http://www.w3.org/2002/07/owl#equivalentClass' ||
            match[1] === 'http://www.w3.org/2002/07/owl#equivalentProperty' ||
            match[1] === 'http://purl.org/dc/terms/source' ||
            match[1] === 'http://www.w3.org/2000/01/rdf-schema#label' ||
            match[1] === 'http://www.w3.org/2004/02/skos/core#closeMatch' ||
            match[1] === 'http://www.w3.org/2004/02/skos/core#exactMatch') {
            // Skip Equivalent Classes & Properties
            continue;
        }
        if (/http[s]?:\/\/schema.org\/isPartOf/.test(match[1])) {
            // When isPartOf is used as a predicate, is a higher-order
            // property describing if a Property or Class is part of a
            // specific schema layer. We don't use that information yet,
            // so discard it.
            continue;
        }
        try {
            yield {
                Subject: subject(match[0]),
                Predicate: predicate(match[1]),
                Object: object(match[2]),
            };
        }
        catch (parseError) {
            const e = parseError;
            throw new Error(`ParseError: ${e.name}: ${e.message} while parsing line ${match}.\nOriginal Stack:\n${e.stack}\nRethrown from:`);
        }
    }
}
exports.process = process;
//# sourceMappingURL=reader.js.map
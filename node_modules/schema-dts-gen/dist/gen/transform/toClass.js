"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProcessClasses = void 0;
const logging_1 = require("../logging");
const types_1 = require("../triples/types");
const wellKnown_1 = require("../triples/wellKnown");
const class_1 = require("../ts/class");
const assert_1 = require("../util/assert");
function toClass(cls, topic, map) {
    const rest = [];
    for (const value of topic.values) {
        const added = cls.add(value, map);
        if (!added)
            rest.push(value);
    }
    if (rest.length > 0) {
        logging_1.Log(`Class ${cls.subject.name}: Did not add [${rest
            .map(r => `(${r.Predicate.name} ${r.Object.toString()})`)
            .join(',')}]`);
    }
    return cls;
}
const wellKnownTypes = [
    new class_1.AliasBuiltin('http://schema.org/Text', 'string'),
    new class_1.AliasBuiltin('http://schema.org/Number', 'number'),
    new class_1.AliasBuiltin('http://schema.org/Time', 'string'),
    new class_1.AliasBuiltin('http://schema.org/Date', 'string'),
    new class_1.AliasBuiltin('http://schema.org/DateTime', 'string'),
    new class_1.AliasBuiltin('http://schema.org/Boolean', 'boolean'),
];
// Should we allow 'string' to be a valid type for all values of this type?
const wellKnownStrings = [
    types_1.UrlNode.Parse('http://schema.org/Quantity'),
    types_1.UrlNode.Parse('http://schema.org/EntryPoint'),
    types_1.UrlNode.Parse('http://schema.org/Organization'),
    types_1.UrlNode.Parse('http://schema.org/Person'),
    types_1.UrlNode.Parse('http://schema.org/Place'),
    types_1.UrlNode.Parse('https://schema.org/Quantity'),
    types_1.UrlNode.Parse('https://schema.org/EntryPoint'),
    types_1.UrlNode.Parse('https://schema.org/Organization'),
    types_1.UrlNode.Parse('https://schema.org/Person'),
    types_1.UrlNode.Parse('https://schema.org/Place'),
];
function ForwardDeclareClasses(topics) {
    const classes = new Map();
    const dataType = new class_1.DataTypeUnion('http://schema.org/DataType', []);
    for (const topic of topics) {
        if (wellKnown_1.IsDataType(topic.Subject)) {
            classes.set(topic.Subject.toString(), dataType);
            continue;
        }
        else if (wellKnown_1.IsWellKnown(topic)) {
            const wk = wellKnownTypes.find(wk => wk.subject.equivTo(topic.Subject));
            if (!wk) {
                throw new Error(`Non-Object type ${topic.Subject.toString()} has no corresponding well-known type.`);
            }
            classes.set(topic.Subject.toString(), wk);
            dataType.wk.push(wk);
            continue;
        }
        else if (!wellKnown_1.IsNamedClass(topic))
            continue;
        const cls = new class_1.Class(topic.Subject);
        const allowString = wellKnownStrings.some(wks => wks.equivTo(topic.Subject));
        if (allowString)
            cls.addTypedef('string');
        classes.set(topic.Subject.toString(), cls);
    }
    return classes;
}
function BuildClasses(topics, classes) {
    for (const topic of topics) {
        if (!wellKnown_1.IsNamedClass(topic))
            continue;
        const cls = classes.get(topic.Subject.toString());
        assert_1.assert(cls);
        toClass(cls, topic, classes);
    }
}
/**
 * Produce a mapping of all Classes within the Ontology. The resulting classes
 * are empty and only describes their names, comments, and inheritance
 * relations.
 *
 * @param topics a sequence of processed triples describing an Ontology.
 * @returns ClassMap Mapping fully qualified ID of each type to a Class.
 */
function ProcessClasses(topics) {
    const classes = ForwardDeclareClasses(topics);
    BuildClasses(topics, classes);
    return classes;
}
exports.ProcessClasses = ProcessClasses;
//# sourceMappingURL=toClass.js.map
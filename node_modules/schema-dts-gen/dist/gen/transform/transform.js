"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WriteDeclarations = void 0;
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const rxjs_1 = require("rxjs");
const typescript_1 = require("typescript");
const operators_1 = require("../triples/operators");
const class_1 = require("../ts/class");
const toClass_1 = require("./toClass");
const toEnum_1 = require("./toEnum");
const toProperty_1 = require("./toProperty");
const helper_types_1 = require("../ts/helper_types");
/**
 * Writes TypeScript declarations for all Classes, Typedefs, and Enums
 * representing the ontology passed in the 'triples' parameter.
 *
 * @param triples Observable emitting all Triples found in an ontology.
 * @param includeDeprecated True if classes and properties marked with
 *     'supersededBy' should still be included (as 'deprecated') in the final
 *     TypeScript output.
 * @param write Callback function to write a portion of the file. Will be called
 *     sequentially on separate chunks within a file.
 *
 * @returns Promise indicating completion.
 */
function WriteDeclarations(triples, includeDeprecated, context, write) {
    return __awaiter(this, void 0, void 0, function* () {
        const topics = yield rxjs_1.firstValueFrom(triples.pipe(operators_1.asTopicArray()));
        const classes = toClass_1.ProcessClasses(topics);
        toProperty_1.ProcessProperties(topics, classes);
        toEnum_1.ProcessEnums(topics, classes);
        const sorted = Array.from(classes.values()).sort(class_1.Sort);
        const source = typescript_1.createSourceFile('result.ts', '', typescript_1.ScriptTarget.ES2015, 
        /*setParentNodes=*/ false, typescript_1.ScriptKind.TS);
        const printer = typescript_1.createPrinter({ newLine: typescript_1.NewLineKind.LineFeed });
        for (const helperType of helper_types_1.HelperTypes(context)) {
            write(printer.printNode(typescript_1.EmitHint.Unspecified, helperType, source));
            write('\n');
        }
        write('\n');
        for (const cls of sorted) {
            if (cls.deprecated && !includeDeprecated)
                continue;
            for (const node of cls.toNode(context, !includeDeprecated)) {
                const result = printer.printNode(typescript_1.EmitHint.Unspecified, node, source);
                yield write(result);
                yield write('\n');
            }
            yield write('\n');
        }
    });
}
exports.WriteDeclarations = WriteDeclarations;
//# sourceMappingURL=transform.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sort = exports.DataTypeUnion = exports.AliasBuiltin = exports.Builtin = exports.Class = void 0;
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const logging_1 = require("../logging");
const types_1 = require("../triples/types");
const wellKnown_1 = require("../triples/wellKnown");
const property_1 = require("./property");
const arrayof_1 = require("./util/arrayof");
const comments_1 = require("./util/comments");
const names_1 = require("./util/names");
const assert_1 = require("../util/assert");
const helper_types_1 = require("./helper_types");
const array_prototype_flatmap_1 = require("array.prototype.flatmap");
array_prototype_flatmap_1.shim();
/**
 * Represents a "Class" in Schema.org, except in cases where it is better
 * described by Builtin (i.e. is a DataType).
 *
 * In TypeScript, this corresponds to a collection of declarations:
 * 1. If the class has enum values, an Enum declaration.
 * 2. If the class has properties, the properties in an object literal.
 * 3. If the class has children,
 *        a type union over all children.
 *    otherwise, a "type" property.
 */
class Class {
    constructor(subject) {
        this.subject = subject;
        this.children = [];
        this._parents = [];
        this._props = new Set();
        this._enums = new Set();
        this._supersededBy = new Set();
    }
    allParents() {
        return this._parents;
    }
    namedParents() {
        return this._parents
            .map(p => p.baseName())
            .filter((name) => !!name);
    }
    isNodeType() {
        if (this instanceof Builtin)
            return false;
        if (this._props.size > 0)
            return true;
        return this.allParents().every(n => n.isNodeType());
    }
    get deprecated() {
        return this._supersededBy.size > 0;
    }
    get comment() {
        if (!this.deprecated)
            return this._comment;
        const deprecated = `@deprecated Use ${this.supersededBy()
            .map(c => c.className())
            .join(' or ')} instead.`;
        return comments_1.appendLine(this._comment, deprecated);
    }
    get typedefs() {
        const parents = this.allParents().flatMap(p => p.typedefs);
        return Array.from(new Set(this._typedef ? [this._typedef, ...parents] : parents)).sort();
    }
    properties() {
        return Array.from(this._props.values()).sort((a, b) => CompareKeys(a.key, b.key));
    }
    supersededBy() {
        return Array.from(this._supersededBy).sort((a, b) => CompareKeys(a.subject, b.subject));
    }
    enums() {
        return Array.from(this._enums).sort((a, b) => CompareKeys(a.value, b.value));
    }
    baseName() {
        // If Skip Base, we use the parent type instead.
        if (this.skipBase()) {
            if (this.namedParents().length === 0)
                return undefined;
            assert_1.assert(this.namedParents().length === 1);
            return this.namedParents()[0];
        }
        return names_1.toClassName(this.subject) + 'Base';
    }
    leafName() {
        // If the leaf has no node type and doesn't refer to any parent,
        // skip defining it.
        if (!this.isNodeType() && this.namedParents().length === 0) {
            return undefined;
        }
        return names_1.toClassName(this.subject) + 'Leaf';
    }
    className() {
        return names_1.toClassName(this.subject);
    }
    add(value, classMap) {
        const c = wellKnown_1.GetComment(value);
        if (c) {
            if (this._comment) {
                logging_1.Log(`Duplicate comments provided on class ${this.subject.toString()}. It will be overwritten.`);
            }
            this._comment = c.comment;
            return true;
        }
        const s = wellKnown_1.GetSubClassOf(value);
        if (s) {
            // DataType subclasses rdfs:Class (since it too is a 'meta' type).
            // We don't represent this well right now, but we want to skip it.
            if (wellKnown_1.IsClassType(s.subClassOf))
                return false;
            const parentClass = classMap.get(s.subClassOf.toString());
            if (parentClass) {
                this._parents.push(parentClass);
                parentClass.children.push(this);
            }
            else {
                throw new Error(`Couldn't find parent of ${this.subject.name}, ${s.subClassOf.toString()}`);
            }
            return true;
        }
        if (wellKnown_1.IsSupersededBy(value.Predicate)) {
            const supersededBy = classMap.get(value.Object.toString());
            if (!supersededBy) {
                throw new Error(`Couldn't find class ${value.Object.toString()}, which supersedes class ${this.subject.name}`);
            }
            this._supersededBy.add(supersededBy);
            return true;
        }
        return false;
    }
    addTypedef(typedef) {
        if (this._typedef) {
            throw new Error(`Class ${this.subject.href} already has typedef ${this._typedef} but we're also adding ${typedef}`);
        }
        this._typedef = typedef;
    }
    addProp(p) {
        this._props.add(p);
    }
    addEnum(e) {
        this._enums.add(e);
    }
    skipBase() {
        if (!this.isNodeType())
            return true;
        return this.namedParents().length === 1 && this._props.size === 0;
    }
    baseDecl(skipDeprecatedProperties, context) {
        if (this.skipBase()) {
            return undefined;
        }
        const baseName = this.baseName();
        assert_1.assert(baseName, 'If a baseNode is defined, baseName must be defined.');
        const parentTypes = this.namedParents().map(p => typescript_1.factory.createExpressionWithTypeArguments(typescript_1.factory.createIdentifier(p), []));
        const heritage = typescript_1.factory.createHeritageClause(typescript_1.SyntaxKind.ExtendsKeyword, parentTypes.length === 0
            ? [
                typescript_1.factory.createExpressionWithTypeArguments(typescript_1.factory.createIdentifier('Partial'), 
                /*typeArguments=*/ [
                    typescript_1.factory.createTypeReferenceNode(helper_types_1.IdReferenceName, 
                    /*typeArguments=*/ []),
                ]),
            ]
            : parentTypes);
        const members = this.properties()
            .filter(property => !property.deprecated || !skipDeprecatedProperties)
            .map(prop => prop.toNode(context));
        return typescript_1.factory.createInterfaceDeclaration(
        /*decorators=*/ [], 
        /*modifiers=*/ [], baseName, 
        /*typeParameters=*/ [], 
        /*heritageClause=*/ [heritage], 
        /*members=*/ members);
    }
    leafDecl(context) {
        const leafName = this.leafName();
        if (!leafName)
            return undefined;
        const baseName = this.baseName();
        // Leaf is missing if !isNodeType || namedParents.length == 0
        // Base is missing if !isNodeType && namedParents.length == 0 && numProps == 0
        //
        // so when "Leaf" is present, Base will always be present.
        assert_1.assert(baseName, 'Expect baseName to exist when leafName exists.');
        const baseTypeReference = typescript_1.factory.createTypeReferenceNode(baseName, 
        /*typeArguments=*/ []);
        return typescript_1.factory.createInterfaceDeclaration(
        /*decorators=*/ [], 
        /*modifiers=*/ [], leafName, 
        /*typeParameters=*/ [], 
        /*heritage=*/ [
            typescript_1.factory.createHeritageClause(typescript_1.SyntaxKind.ExtendsKeyword, [
                typescript_1.factory.createExpressionWithTypeArguments(typescript_1.factory.createIdentifier(baseName), 
                /*typeArguments=*/ []),
            ]),
        ], 
        /*members=*/ [new property_1.TypeProperty(this.subject).toNode(context)]);
    }
    nonEnumType(skipDeprecated) {
        this.children.sort((a, b) => CompareKeys(a.subject, b.subject));
        const children = this.children
            .filter(child => !(child.deprecated && skipDeprecated))
            .map(child => typescript_1.factory.createTypeReferenceNode(child.className(), 
        /*typeArguments=*/ []));
        // A type can have a valid typedef, add that if so.
        children.push(...this.typedefs.map(t => typescript_1.factory.createTypeReferenceNode(t, /*typeArgs=*/ [])));
        const upRef = this.leafName() || this.baseName();
        return upRef
            ? [typescript_1.factory.createTypeReferenceNode(upRef, /*typeArgs=*/ []), ...children]
            : children;
    }
    totalType(context, skipDeprecated) {
        const isEnum = this._enums.size > 0;
        if (isEnum) {
            return typescript_1.factory.createUnionTypeNode([
                ...this.enums().flatMap(e => e.toTypeLiteral(context)),
                ...this.nonEnumType(skipDeprecated),
            ]);
        }
        else {
            return typescript_1.factory.createUnionTypeNode(this.nonEnumType(skipDeprecated));
        }
    }
    toNode(context, skipDeprecated) {
        const typeValue = this.totalType(context, skipDeprecated);
        const declaration = comments_1.withComments(this.comment, typescript_1.factory.createTypeAliasDeclaration(
        /* decorators = */ [], typescript_1.factory.createModifiersFromModifierFlags(typescript_1.ModifierFlags.Export), this.className(), [], typeValue));
        // Guide to Code Generated:
        // // Base: Always There -----------------------//
        // type XyzBase = (Parents) & {
        //   ... props;
        // };
        // // Leaf:
        // export type XyzLeaf = XyzBase & {
        //   '@type': 'Xyz'
        // }
        // // Complete Type ----------------------------//
        // export type Xyz = "Enum1"|"Enum2"|...        // Enum Piece: Optional.
        //                  |XyzLeaf                    // 'Leaf' Piece.
        //                  |Child1|Child2|...          // Child Piece: Optional.
        // //-------------------------------------------//
        return arrayof_1.arrayOf(this.baseDecl(skipDeprecated, context), this.leafDecl(context), declaration);
    }
}
exports.Class = Class;
/**
 * Represents a DataType.
 */
class Builtin extends Class {
}
exports.Builtin = Builtin;
/**
 * A "Native" Schema.org object that is best represented
 * in JSON-LD and JavaScript as a typedef to a native type.
 */
class AliasBuiltin extends Builtin {
    constructor(url, equivTo) {
        super(types_1.UrlNode.Parse(url));
        this.addTypedef(equivTo);
    }
}
exports.AliasBuiltin = AliasBuiltin;
class DataTypeUnion extends Builtin {
    constructor(url, wk) {
        super(types_1.UrlNode.Parse(url));
        this.wk = wk;
    }
    toNode() {
        this.wk.sort(Sort);
        return [
            comments_1.withComments(this.comment, typescript_1.factory.createTypeAliasDeclaration(
            /*decorators=*/ [], typescript_1.factory.createModifiersFromModifierFlags(typescript_1.ModifierFlags.Export), this.subject.name, 
            /*typeParameters=*/ [], typescript_1.factory.createUnionTypeNode(this.wk.map(wk => typescript_1.factory.createTypeReferenceNode(wk.subject.name, 
            /*typeArguments=*/ []))))),
        ];
    }
}
exports.DataTypeUnion = DataTypeUnion;
/**
 * Defines a Sort order between Class declarations.
 *
 * DataTypes come first, next the 'DataType' union itself, followed by all
 * regular classes. Within each group, class names are ordered alphabetically in
 * UTF-16 code units order.
 */
function Sort(a, b) {
    if (a instanceof Builtin && !(a instanceof DataTypeUnion)) {
        if (b instanceof Builtin && !(b instanceof DataTypeUnion)) {
            return CompareKeys(a.subject, b.subject);
        }
        else {
            return -1;
        }
    }
    else if (b instanceof Builtin && !(b instanceof DataTypeUnion)) {
        return +1;
    }
    else if (a instanceof DataTypeUnion) {
        return b instanceof DataTypeUnion ? 0 : -1;
    }
    else if (b instanceof DataTypeUnion) {
        // If we are here, a is never a DataTypeUnion.
        return +1;
    }
    else {
        return CompareKeys(a.subject, b.subject);
    }
}
exports.Sort = Sort;
function CompareKeys(a, b) {
    const byName = a.name.localeCompare(b.name);
    if (byName !== 0)
        return byName;
    return a.href.localeCompare(b.href);
}
//# sourceMappingURL=class.js.map
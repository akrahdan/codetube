"use strict";
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeProperty = exports.Property = exports.PropertyType = void 0;
const typescript_1 = require("typescript");
const logging_1 = require("../logging");
const triple_1 = require("../triples/triple");
const wellKnown_1 = require("../triples/wellKnown");
const comments_1 = require("./util/comments");
const helper_types_1 = require("./helper_types");
/**
 * A "class" of properties, not associated with any particuar object.
 */
class PropertyType {
    constructor(subject) {
        this.subject = subject;
        this.types = [];
        this._supersededBy = [];
    }
    get comment() {
        if (!this.deprecated)
            return this._comment;
        const deprecated = `@deprecated Consider using ${this._supersededBy
            .map(o => o.toString())
            .join(' or ')} instead.`;
        return comments_1.appendLine(this._comment, deprecated);
    }
    get deprecated() {
        return this._supersededBy.length > 0;
    }
    add(value, classes) {
        const c = wellKnown_1.GetComment(value);
        if (c) {
            if (this._comment) {
                logging_1.Log(`Duplicate comments provided on property ${this.subject.toString()}. It will be overwritten.`);
            }
            this._comment = c.comment;
            return true;
        }
        if (wellKnown_1.IsRangeIncludes(value.Predicate)) {
            if (!wellKnown_1.IsTypeName(value.Object)) {
                throw new Error(`Type expected to be a UrlNode always. When adding ${triple_1.Format(value)} to ${this.subject.toString()}.`);
            }
            const cls = classes.get(value.Object.toString());
            if (!cls) {
                throw new Error(`Could not find class for ${value.Object.toString()}`);
            }
            this.types.push(cls);
            return true;
        }
        if (wellKnown_1.IsDomainIncludes(value.Predicate)) {
            const cls = classes.get(value.Object.toString());
            if (!cls) {
                throw new Error(`Could not find class for ${this.subject.name}, ${triple_1.Format(value)}.`);
            }
            cls.addProp(new Property(this.subject, this));
            return true;
        }
        if (wellKnown_1.IsSupersededBy(value.Predicate)) {
            this._supersededBy.push(value.Object);
            return true;
        }
        return false;
    }
    scalarTypeNode() {
        const typeNames = this.types.map(cls => cls.className()).sort();
        if (this.types.some(cls => cls.isNodeType())) {
            typeNames.push(helper_types_1.IdReferenceName);
        }
        const typeNodes = typeNames.map(type => typescript_1.factory.createTypeReferenceNode(type, /*typeArguments=*/ []));
        switch (typeNodes.length) {
            case 0:
                return typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.NeverKeyword);
            case 1:
                return typeNodes[0];
            default:
                return typescript_1.factory.createUnionTypeNode(typeNodes);
        }
    }
}
exports.PropertyType = PropertyType;
/**
 * A Property on a particular object.
 */
class Property {
    constructor(key, type) {
        this.key = key;
        this.type = type;
    }
    get deprecated() {
        return this.type.deprecated;
    }
    typeNode() {
        return typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier(helper_types_1.SchemaValueName), 
        /* typeArguments = */ [this.type.scalarTypeNode()]);
    }
    toNode(context) {
        return comments_1.withComments(this.type.comment, typescript_1.factory.createPropertySignature(
        /* modifiers= */ [], typescript_1.factory.createStringLiteral(context.getScopedName(this.key)), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), 
        /*typeNode=*/ this.typeNode()));
    }
}
exports.Property = Property;
class TypeProperty {
    constructor(className) {
        this.className = className;
        this.deprecated = false;
    }
    toNode(context) {
        return typescript_1.factory.createPropertySignature(
        /* modifiers= */ [], typescript_1.factory.createStringLiteral('@type'), 
        /* questionToken= */ undefined, 
        /* typeNode= */
        typescript_1.factory.createTypeReferenceNode(`"${context.getScopedName(this.className)}"`, 
        /*typeArguments=*/ undefined));
    }
}
exports.TypeProperty = TypeProperty;
//# sourceMappingURL=property.js.map
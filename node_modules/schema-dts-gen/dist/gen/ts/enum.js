"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnumValue = void 0;
/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const typescript_1 = require("typescript");
const logging_1 = require("../logging");
const wellKnown_1 = require("../triples/wellKnown");
/**
 * Corresponds to a value that belongs to an Enumeration.
 */
class EnumValue {
    constructor(value, types, map) {
        this.value = value;
        this.INSTANCE = 'EnumValue';
        for (const type of types) {
            // If a Subject has a "Type", then it either means:
            // 1- Type is Class - This topic represents an object that can be
            //    represented as a class (usually, a node/object).
            // 2- Type is DataType - This topic represents an object that can
            //    represented as a raw value.
            // 3- Type is Neither - This topic's IRI can be used in the place of that
            //    type to describe its value.
            //
            // For example,
            // - Thing is a Class only.
            // - Text is a Class and a DataType.
            // - DataType is a Class.
            // - Wednesday is a DayOfWeek only.
            //
            // In Schema.org 3.4, some enumerations were both a Class and an Enum.
            //
            // For example, SurgicalProcedure was both an enum value for
            // MedicalProcedureType and a class that can be described in its own
            // right. It had type Class and MedicalProcedureType.
            //
            // For those cases, we make sure:
            // (a) We add an EnumValue for all types that are not Class/DataType.
            // (b) An EnumValue being a Class/DataType should not disqualify it from
            //     being an enum value for some other type (if it has one).
            if (wellKnown_1.IsClassType(type) || wellKnown_1.IsDataType(type))
                continue;
            const enumObject = map.get(type.toString());
            if (!enumObject) {
                throw new Error(`Couldn't find ${type.toString()} in classes.`);
            }
            enumObject.addEnum(this);
        }
    }
    add(value) {
        const comment = wellKnown_1.GetComment(value);
        if (comment) {
            if (this.comment) {
                logging_1.Log(`Duplicate comments provided on ${this.value.toString()} enum but one already exists. It will be overwritten.`);
            }
            this.comment = comment.comment;
            return true;
        }
        return false;
    }
    toTypeLiteral(context) {
        const types = [
            typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createStringLiteral(this.value.toString())),
        ];
        if (this.value.context.protocol === 'http:') {
            types.push(typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createStringLiteral(this.value.toString().replace(/^http:/, 'https:'))));
        }
        const scoped = context.getScopedName(this.value);
        if (scoped !== this.value.href) {
            types.push(typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createStringLiteral(scoped)));
        }
        return types;
    }
}
exports.EnumValue = EnumValue;
//# sourceMappingURL=enum.js.map
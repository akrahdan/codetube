var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import differenceInCalendarMonths from 'date-fns/differenceInCalendarMonths';
import format from 'date-fns/format';
import parse from 'date-fns/parse';
import isMatch from 'date-fns/isMatch';
import glamorDefault, * as glamorExports from 'glamor';
import React from 'react';
import stylesheet from '../css/index';
import { slides } from '../vars/index';
var glamor = glamorDefault || glamorExports;
var style = {
    start: function () { return glamor.css(stylesheet['.psds-calendar__date--selected-start']); },
    end: function () { return glamor.css(stylesheet['.psds-calendar__date--selected-end']); },
    inRange: function (arg) {
        return glamor.css(arg && stylesheet['.psds-calendar__date--in-range']);
    }
};
export var useIsInRange = function (selected) {
    if (selected === void 0) { selected = []; }
    var _a = React.useState(), hoveredDate = _a[0], setHoveredDate = _a[1];
    // Calendar level
    var onMouseLeave = function () {
        setHoveredDate(undefined);
    };
    // Date level
    var onMouseEnter = function (date) {
        if (!selected.length) {
            return;
        }
        setHoveredDate(date);
    };
    var isInRange = function (date) {
        if (selected.length) {
            var firstSelected = selected[0].getTime();
            if (selected.length === 2) {
                var secondSelected = selected[1].getTime();
                return __assign(__assign(__assign({}, style.inRange(firstSelected < date.getTime() && secondSelected > date.getTime())), (firstSelected === date.getTime() && style.start())), (secondSelected === date.getTime() && style.end()));
            }
            else {
                return __assign(__assign({}, style.inRange(hoveredDate &&
                    ((firstSelected < date.getTime() &&
                        hoveredDate.getTime() >= date.getTime()) ||
                        (date.getTime() < firstSelected &&
                            date.getTime() >= hoveredDate.getTime())))), (firstSelected === date.getTime() && style.start()));
            }
        }
        return {};
    };
    return { onMouseLeave: onMouseLeave, onMouseEnter: onMouseEnter, isInRange: isInRange };
};
export var onRangeDateSelected = function (_a) {
    var _b = _a.selected, selected = _b === void 0 ? [] : _b, setSelected = _a.setSelected, onSelect = _a.onSelect;
    return function (dateObj, evt) {
        var selectable = dateObj.selectable, date = dateObj.date;
        if (!selectable) {
            return;
        }
        var dateTime = date.getTime();
        var newDates = __spreadArrays(selected);
        if (selected.length) {
            if (selected.length === 1) {
                var firstTime = selected[0].getTime();
                if (firstTime < dateTime) {
                    newDates.push(date);
                }
                else {
                    newDates.unshift(date);
                }
                setSelected(newDates);
            }
            else if (newDates.length === 2) {
                setSelected([date]);
            }
        }
        else {
            newDates.push(date);
            setSelected(newDates);
        }
        onSelect && onSelect(evt, dateObj);
    };
};
var getDateIndex = function (selected, condition) {
    var index;
    selected.some(function (date, i) {
        index = i;
        if (condition(date.getTime())) {
            return true;
        }
        // If we loop through all the selected dates and still didn't find
        // one, make sure to add it to the end of the array.
        index++;
        return false;
    });
    return index;
};
export var onMultiDateSelected = function (_a) {
    var _b = _a.selected, selected = _b === void 0 ? [] : _b, setSelected = _a.setSelected, onSelect = _a.onSelect;
    return function (dateObj, evt) {
        var isSelected = dateObj.selected, selectable = dateObj.selectable, date = dateObj.date;
        if (!selectable) {
            return;
        }
        var newSelectedDates = selected.slice();
        var selectedTime = date.getTime();
        if (isSelected) {
            var index = getDateIndex(selected, function (time) { return selectedTime === time; });
            newSelectedDates.splice(index, 1);
        }
        else {
            // Add
            var index = getDateIndex(selected, function (time) { return selectedTime < time; });
            newSelectedDates.splice(index, 0, date);
        }
        setSelected(newSelectedDates);
        onSelect && onSelect(evt, dateObj);
    };
};
export var useDateSelectChange = function (_a) {
    var selected = _a.selected, setSlide = _a.setSlide, setSelected = _a.setSelected, _b = _a.dateFormat, dateFormat = _b === void 0 ? 'MM/dd/yyyy' : _b;
    var _c = React.useState(selected ? format(selected, dateFormat) : ''), value = _c[0], setValue = _c[1];
    React.useEffect(function () {
        selected ? setValue(format(selected, dateFormat)) : '';
    }, [selected]);
    var onChange = function (evt) {
        var nextValue = evt.target.value;
        setValue(nextValue);
        var fulldate = false;
        try {
            fulldate = isMatch(nextValue, dateFormat);
        }
        catch (err) {
            if (!(err instanceof RangeError)) {
                throw err;
            }
        }
        var nextSelected = fulldate
            ? parse(nextValue, dateFormat, new Date())
            : selected;
        if (nextSelected instanceof Date &&
            !isNaN(nextSelected)) {
            var nextSlide = void 0;
            if (selected) {
                nextSlide =
                    differenceInCalendarMonths(nextSelected, selected) > 0
                        ? 'forward'
                        : differenceInCalendarMonths(nextSelected, selected) < 0
                            ? 'backward'
                            : undefined;
            }
            setSelected(nextSelected);
            setSlide(nextSlide);
        }
    };
    return [value, onChange];
};
export var useRangeSelectChange = function (_a) {
    var start = _a.start, _b = _a.selected, selected = _b === void 0 ? [] : _b, setSlide = _a.setSlide, setSelected = _a.setSelected, _c = _a.dateFormat, dateFormat = _c === void 0 ? 'MM/dd/yyyy' : _c;
    var _selected = start ? selected[0] : selected[1];
    var _d = React.useState(_selected ? format(_selected, dateFormat) : ''), value = _d[0], setValue = _d[1];
    React.useEffect(function () {
        _selected ? setValue(format(_selected, dateFormat)) : '';
    }, [_selected]);
    var onChange = function (evt) {
        var nextValue = evt.target.value;
        setValue(nextValue);
        var fulldate = false;
        try {
            fulldate = isMatch(nextValue, dateFormat);
        }
        catch (err) {
            if (!(err instanceof RangeError)) {
                throw err;
            }
        }
        var nextSelected = fulldate
            ? parse(nextValue, dateFormat, new Date())
            : selected;
        if (nextSelected instanceof Date &&
            !isNaN(nextSelected)) {
            var nextSlide = void 0;
            if (selected) {
                !selected[0] && setSelected([]);
                start && setSelected([nextSelected, selected[1]].filter(Boolean));
                selected[0] && !start && setSelected([selected[0], nextSelected]);
                nextSlide =
                    differenceInCalendarMonths(nextSelected, _selected) > 0
                        ? slides.forward
                        : differenceInCalendarMonths(nextSelected, _selected) < 0
                            ? slides.backward
                            : slides.undefined;
            }
            setSlide(nextSlide);
        }
    };
    return [value, onChange];
};
//# sourceMappingURL=utils.js.map
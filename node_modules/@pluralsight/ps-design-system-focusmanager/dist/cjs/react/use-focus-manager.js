"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
var ps_design_system_util_1 = require("@pluralsight/ps-design-system-util");
var react_1 = __importDefault(require("react"));
var FOCUSABLE_SELECTORS = [
    '[contenteditable]:not([contenteditable="false"])',
    '[tabindex]',
    'a[href]',
    'audio[controls]',
    'button',
    'iframe',
    'input',
    'select',
    'textarea',
    'video[controls]'
];
function useFocusManager(ref, _a) {
    var autofocus = _a.autofocus, returnFocus = _a.returnFocus, trapped = _a.trapped;
    var prevActiveElRef = react_1.default.useRef(null);
    react_1.default.useEffect(function () {
        // @ts-ignore: read-only prop
        prevActiveElRef.current = document.activeElement;
    }, []);
    var _b = react_1.default.useState(null), node = _b[0], setNode = _b[1];
    react_1.default.useEffect(function () {
        setNode(ref.current);
    }, [ref]);
    var _c = react_1.default.useState([]), focusableNodes = _c[0], setFocusableEls = _c[1];
    var firstNode = react_1.default.useMemo(function () { return focusableNodes[0]; }, [focusableNodes]);
    var lastNode = react_1.default.useMemo(function () { return focusableNodes[focusableNodes.length - 1]; }, [focusableNodes]);
    react_1.default.useEffect(function () {
        if (focusableNodes.length === 0)
            ref.current.setAttribute('tabindex', '0');
        else
            ref.current.removeAttribute('tabindex');
    }, [focusableNodes, ref]);
    react_1.default.useEffect(function () {
        var observer;
        if (ps_design_system_util_1.canUseDOM() && node instanceof Node) {
            observer = new MutationObserver(function (mutationList) {
                mutationList.forEach(function (mutation) {
                    if (mutation.type === 'childList') {
                        var nextEls_1 = getFocusableChildNodes(node);
                        setFocusableEls(nextEls_1);
                    }
                });
            });
            observer.observe(node, { childList: true, subtree: true });
        }
        var nextEls = getFocusableChildNodes(node);
        setFocusableEls(nextEls);
        return function () {
            observer === null || observer === void 0 ? void 0 : observer.disconnect();
        };
    }, [node]);
    react_1.default.useEffect(function () {
        if (!autofocus)
            return;
        var toFocus = firstNode || ref.current;
        toFocus.focus();
    }, [firstNode, autofocus, ref]);
    var handleKeyDown = react_1.default.useCallback(function (evt) {
        if (!isTab(evt))
            return;
        var curActive = document.activeElement;
        var reverse = withShift(evt);
        if (curActive === firstNode && reverse) {
            lastNode.focus();
            evt.preventDefault();
            evt.stopPropagation();
        }
        else if (curActive === lastNode && !reverse) {
            firstNode.focus();
            evt.preventDefault();
            evt.stopPropagation();
        }
    }, [firstNode, lastNode]);
    react_1.default.useEffect(function bind() {
        if (!trapped)
            return;
        window.addEventListener('keydown', handleKeyDown);
        return function unbind() {
            window.removeEventListener('keydown', handleKeyDown);
        };
    }, [handleKeyDown, autofocus, returnFocus, trapped]);
    react_1.default.useEffect(function () {
        if (!returnFocus)
            return;
        return function returnFocusWhenUnmounted() {
            if (prevActiveElRef.current)
                prevActiveElRef.current.focus();
        };
    }, [returnFocus]);
}
exports.default = useFocusManager;
function hasNegativeTabIndex(el) {
    return el.getAttribute('tabindex') && Number(el.getAttribute('tabindex')) < 0;
}
function withShift(evt) {
    return evt.shiftKey;
}
function isTab(evt) {
    return evt.key === 'Tab';
}
function getFocusableChildNodes(el) {
    if (!el)
        return [];
    var selectAll = FOCUSABLE_SELECTORS.join(',');
    var nodelist = el.querySelectorAll(selectAll);
    return Array.from(nodelist || []).filter(function (node) { return !hasNegativeTabIndex(node); });
}
//# sourceMappingURL=use-focus-manager.js.map
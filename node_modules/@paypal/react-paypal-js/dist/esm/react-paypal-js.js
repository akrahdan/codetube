function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * react-paypal-js v7.2.1 (2021-07-28T21:34:39.268Z)
 * Copyright 2020-present, PayPal, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React, { createContext, useContext, useReducer, useEffect, useRef, useState } from 'react';

var _assign = function __assign() {
  _assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }

    return t;
  };

  return _assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};

  for (var p in s) {
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
  }

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || from);
}

function findScript(url, attributes) {
  var currentScript = document.querySelector("script[src=\"" + url + "\"]");
  if (currentScript === null) return null;
  var nextScript = createScriptElement(url, attributes);
  var currentScriptDataset = Object.assign({}, currentScript.dataset);
  delete currentScriptDataset.uidAuto;

  if (Object.keys(currentScriptDataset).length !== Object.keys(nextScript.dataset).length) {
    return null;
  }

  var isExactMatch = true;
  Object.keys(currentScriptDataset).forEach(function (key) {
    if (currentScriptDataset[key] !== nextScript.dataset[key]) {
      isExactMatch = false;
    }
  });
  return isExactMatch ? currentScript : null;
}

function insertScriptElement(_a) {
  var url = _a.url,
      attributes = _a.attributes,
      onSuccess = _a.onSuccess,
      onError = _a.onError;
  var newScript = createScriptElement(url, attributes);
  newScript.onerror = onError;
  newScript.onload = onSuccess;
  document.head.insertBefore(newScript, document.head.firstElementChild);
}

function processOptions(options) {
  var sdkBaseURL = "https://www.paypal.com/sdk/js";

  if (options.sdkBaseURL) {
    sdkBaseURL = options.sdkBaseURL;
    delete options.sdkBaseURL;
  }

  var processedMerchantIDAttributes = processMerchantID(options["merchant-id"], options["data-merchant-id"]);
  var newOptions = Object.assign({}, options, processedMerchantIDAttributes);

  var _a = Object.keys(newOptions).filter(function (key) {
    return typeof newOptions[key] !== "undefined" && newOptions[key] !== null && newOptions[key] !== "";
  }).reduce(function (accumulator, key) {
    var value = newOptions[key].toString();

    if (key.substring(0, 5) === "data-") {
      accumulator.dataAttributes[key] = value;
    } else {
      accumulator.queryParams[key] = value;
    }

    return accumulator;
  }, {
    queryParams: {},
    dataAttributes: {}
  }),
      queryParams = _a.queryParams,
      dataAttributes = _a.dataAttributes;

  return {
    url: sdkBaseURL + "?" + objectToQueryString(queryParams),
    dataAttributes: dataAttributes
  };
}

function objectToQueryString(params) {
  var queryString = "";
  Object.keys(params).forEach(function (key) {
    if (queryString.length !== 0) queryString += "&";
    queryString += key + "=" + params[key];
  });
  return queryString;
}

function createScriptElement(url, attributes) {
  if (attributes === void 0) {
    attributes = {};
  }

  var newScript = document.createElement("script");
  newScript.src = url;
  Object.keys(attributes).forEach(function (key) {
    newScript.setAttribute(key, attributes[key]);

    if (key === "data-csp-nonce") {
      newScript.setAttribute("nonce", attributes["data-csp-nonce"]);
    }
  });
  return newScript;
}

function processMerchantID(merchantID, dataMerchantID) {
  var newMerchantID = "";
  var newDataMerchantID = "";

  if (Array.isArray(merchantID)) {
    if (merchantID.length > 1) {
      newMerchantID = "*";
      newDataMerchantID = merchantID.toString();
    } else {
      newMerchantID = merchantID.toString();
    }
  } else if (typeof merchantID === "string" && merchantID.length > 0) {
    newMerchantID = merchantID;
  } else if (typeof dataMerchantID === "string" && dataMerchantID.length > 0) {
    newMerchantID = "*";
    newDataMerchantID = dataMerchantID;
  }

  return {
    "merchant-id": newMerchantID,
    "data-merchant-id": newDataMerchantID
  };
}

function loadScript(options, PromisePonyfill) {
  if (PromisePonyfill === void 0) {
    PromisePonyfill = getDefaultPromiseImplementation();
  }

  validateArguments(options, PromisePonyfill);
  if (typeof window === "undefined") return PromisePonyfill.resolve(null);

  var _a = processOptions(options),
      url = _a.url,
      dataAttributes = _a.dataAttributes;

  var namespace = dataAttributes["data-namespace"] || "paypal";
  var existingWindowNamespace = getPayPalWindowNamespace$1(namespace);

  if (findScript(url, dataAttributes) && existingWindowNamespace) {
    return PromisePonyfill.resolve(existingWindowNamespace);
  }

  return loadCustomScript({
    url: url,
    attributes: dataAttributes
  }, PromisePonyfill).then(function () {
    var newWindowNamespace = getPayPalWindowNamespace$1(namespace);

    if (newWindowNamespace) {
      return newWindowNamespace;
    }

    throw new Error("The window." + namespace + " global variable is not available.");
  });
}

function loadCustomScript(options, PromisePonyfill) {
  if (PromisePonyfill === void 0) {
    PromisePonyfill = getDefaultPromiseImplementation();
  }

  validateArguments(options, PromisePonyfill);
  var url = options.url,
      attributes = options.attributes;

  if (typeof url !== "string" || url.length === 0) {
    throw new Error("Invalid url.");
  }

  if (typeof attributes !== "undefined" && _typeof(attributes) !== "object") {
    throw new Error("Expected attributes to be an object.");
  }

  return new PromisePonyfill(function (resolve, reject) {
    if (typeof window === "undefined") return resolve();
    insertScriptElement({
      url: url,
      attributes: attributes,
      onSuccess: function onSuccess() {
        return resolve();
      },
      onError: function onError() {
        return reject(new Error("The script \"" + url + "\" failed to load."));
      }
    });
  });
}

function getDefaultPromiseImplementation() {
  if (typeof Promise === "undefined") {
    throw new Error("Promise is undefined. To resolve the issue, use a Promise polyfill.");
  }

  return Promise;
}

function getPayPalWindowNamespace$1(namespace) {
  return window[namespace];
}

function validateArguments(options, PromisePonyfill) {
  if (_typeof(options) !== "object" || options === null) {
    throw new Error("Expected an options object.");
  }

  if (typeof PromisePonyfill !== "undefined" && typeof PromisePonyfill !== "function") {
    throw new Error("Expected PromisePonyfill to be a function.");
  }
}

var DEFAULT_PAYPAL_NAMESPACE = "paypal";

function getPayPalWindowNamespace(namespace) {
  if (namespace === void 0) {
    namespace = DEFAULT_PAYPAL_NAMESPACE;
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  return window[namespace];
}
/**
 * Creates a numeric hash based on the string input.
 */


function hashStr(str) {
  var hash = 0;

  for (var i = 0; i < str.length; i++) {
    hash += str[i].charCodeAt(0) * Math.pow(i % 10 + 1, 5);
  }

  return Math.floor(Math.pow(Math.sqrt(hash), 5));
}

var SCRIPT_LOADING_STATE = {
  INITIAL: "initial",
  PENDING: "pending",
  REJECTED: "rejected",
  RESOLVED: "resolved"
};
var ScriptContext = createContext(null);
var ScriptDispatchContext = createContext(null);

function scriptReducer(state, action) {
  switch (action.type) {
    case "setLoadingStatus":
      return {
        options: _assign({}, state.options),
        loadingStatus: action.value
      };

    case "resetOptions":
      // destroy existing script to make sure only one script loads at a time
      destroySDKScript(state.options["data-react-paypal-script-id"]); // exclude the old data-react-paypal-script-id value from the hash generated by getScriptID()

      delete action.value["data-react-paypal-script-id"];
      return {
        loadingStatus: SCRIPT_LOADING_STATE.PENDING,
        options: _assign(_assign({}, action.value), {
          "data-react-paypal-script-id": "" + getScriptID(action.value)
        })
      };

    default:
      {
        return state;
      }
  }
}

function getScriptID(options) {
  return "react-paypal-js-" + hashStr(JSON.stringify(options));
}

function destroySDKScript(reactPayPalScriptID) {
  var scriptNode = document.querySelector("script[data-react-paypal-script-id=\"" + reactPayPalScriptID + "\"]");
  if (scriptNode === null) return;

  if (scriptNode.parentNode) {
    scriptNode.parentNode.removeChild(scriptNode);
  }
}

function usePayPalScriptReducer() {
  var scriptContext = useContext(ScriptContext);
  var dispatchContext = useContext(ScriptDispatchContext);

  if (scriptContext === null || dispatchContext === null) {
    throw new Error("usePayPalScriptReducer must be used within a PayPalScriptProvider");
  }

  var loadingStatus = scriptContext.loadingStatus,
      restScriptContext = __rest(scriptContext, ["loadingStatus"]);

  var derivedStatusContext = _assign(_assign({}, restScriptContext), {
    isInitial: loadingStatus === SCRIPT_LOADING_STATE.INITIAL,
    isPending: loadingStatus === SCRIPT_LOADING_STATE.PENDING,
    isResolved: loadingStatus === SCRIPT_LOADING_STATE.RESOLVED,
    isRejected: loadingStatus === SCRIPT_LOADING_STATE.REJECTED
  });

  return [derivedStatusContext, dispatchContext];
}

var PayPalScriptProvider = function PayPalScriptProvider(_a) {
  var options = _a.options,
      children = _a.children,
      _b = _a.deferLoading,
      deferLoading = _b === void 0 ? false : _b;

  function initializeState(_a) {
    var options = _a.options,
        deferLoading = _a.deferLoading;
    return {
      options: _assign(_assign({}, options), {
        "data-react-paypal-script-id": "" + getScriptID(options)
      }),
      loadingStatus: deferLoading ? SCRIPT_LOADING_STATE.INITIAL : SCRIPT_LOADING_STATE.PENDING
    };
  }

  var _c = useReducer(scriptReducer, {
    options: options,
    deferLoading: deferLoading
  }, initializeState),
      state = _c[0],
      dispatch = _c[1];

  useEffect(function () {
    if (deferLoading === false && state.loadingStatus === SCRIPT_LOADING_STATE.INITIAL) {
      return dispatch({
        type: "setLoadingStatus",
        value: SCRIPT_LOADING_STATE.PENDING
      });
    }

    if (state.loadingStatus !== SCRIPT_LOADING_STATE.PENDING) return;
    var isSubscribed = true;
    loadScript(state.options).then(function () {
      if (isSubscribed) {
        dispatch({
          type: "setLoadingStatus",
          value: SCRIPT_LOADING_STATE.RESOLVED
        });
      }
    })["catch"](function () {
      if (isSubscribed) {
        dispatch({
          type: "setLoadingStatus",
          value: SCRIPT_LOADING_STATE.REJECTED
        });
      }
    });
    return function () {
      isSubscribed = false;
    };
  }, [options, deferLoading, state.loadingStatus]);
  return React.createElement(ScriptContext.Provider, {
    value: state
  }, React.createElement(ScriptDispatchContext.Provider, {
    value: dispatch
  }, children));
};
/**
This `<PayPalButtons />` component renders the [Smart Payment Buttons](https://developer.paypal.com/docs/business/javascript-sdk/javascript-sdk-reference/#buttons).
It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.

Use props for customizing your buttons. For example, here's how you would use the `style` and `createOrder` options:

```jsx
    import { PayPalScriptProvider, PayPalButtons } from "@paypal/react-paypal-js";

    <PayPalScriptProvider options={{ "client-id": "test" }}>
        <PayPalButtons
            style={{ layout: "horizontal" }}
            createOrder={(data, actions) => {
                return actions.order.create({
                    purchase_units: [
                        {
                            amount: {
                                value: "2.00",
                            },
                        },
                    ],
                });
            }}
        />;
    </PayPalScriptProvider>
```
*/


var PayPalButtons = function PayPalButtons(_a) {
  var _b = _a.className,
      className = _b === void 0 ? "" : _b,
      _c = _a.disabled,
      disabled = _c === void 0 ? false : _c,
      _d = _a.children,
      children = _d === void 0 ? null : _d,
      _e = _a.forceReRender,
      forceReRender = _e === void 0 ? [] : _e,
      buttonProps = __rest(_a, ["className", "disabled", "children", "forceReRender"]);

  var buttonsContainerRef = useRef(null);
  var buttons = useRef(null);
  var _f = usePayPalScriptReducer()[0],
      isResolved = _f.isResolved,
      options = _f.options;

  var _g = useState(null),
      initActions = _g[0],
      setInitActions = _g[1];

  var _h = useState(true),
      isEligible = _h[0],
      setIsEligible = _h[1];

  var _j = useState(null),
      setErrorState = _j[1];

  function closeButtonsComponent() {
    if (buttons.current !== null) {
      buttons.current.close()["catch"](function () {// ignore errors when closing the component
      });
    }
  } // useEffect hook for rendering the buttons


  useEffect(function () {
    // verify the sdk script has successfully loaded
    if (isResolved === false) {
      return closeButtonsComponent;
    }

    var paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]); // verify dependency on window object

    if (paypalWindowNamespace === undefined || paypalWindowNamespace.Buttons === undefined) {
      setErrorState(function () {
        throw new Error(getErrorMessage$2(options));
      });
      return closeButtonsComponent;
    }

    var decoratedOnInit = function decoratedOnInit(data, actions) {
      setInitActions(actions);

      if (typeof buttonProps.onInit === "function") {
        buttonProps.onInit(data, actions);
      }
    };

    buttons.current = paypalWindowNamespace.Buttons(_assign(_assign({}, buttonProps), {
      onInit: decoratedOnInit
    })); // only render the button when eligible

    if (buttons.current.isEligible() === false) {
      setIsEligible(false);
      return closeButtonsComponent;
    }

    if (buttonsContainerRef.current === null) {
      return closeButtonsComponent;
    }

    buttons.current.render(buttonsContainerRef.current)["catch"](function (err) {
      // component failed to render, possibly because it was closed or destroyed.
      if (buttonsContainerRef.current === null || buttonsContainerRef.current.children.length === 0) {
        // paypal buttons container is no longer in the DOM, we can safely ignore the error
        return;
      } // paypal buttons container is still in the DOM


      setErrorState(function () {
        throw new Error("Failed to render <PayPalButtons /> component. " + err);
      });
    });
    return closeButtonsComponent;
  }, __spreadArray(__spreadArray([isResolved], forceReRender), [buttonProps.fundingSource])); // useEffect hook for managing disabled state

  useEffect(function () {
    if (initActions === null) {
      return;
    }

    if (disabled === true) {
      initActions.disable()["catch"](function () {// ignore errors when disabling the component
      });
    } else {
      initActions.enable()["catch"](function () {// ignore errors when enabling the component
      });
    }
  }, [disabled, initActions]);
  var isDisabledStyle = disabled ? {
    opacity: 0.38
  } : {};
  var classNames = (className + " " + (disabled ? "paypal-buttons-disabled" : "")).trim();

  if (isEligible === false) {
    return children;
  }

  return React.createElement("div", {
    ref: buttonsContainerRef,
    style: isDisabledStyle,
    className: classNames
  });
};

function getErrorMessage$2(_a) {
  var _b = _a.components,
      components = _b === void 0 ? "" : _b,
      _c = _a["data-namespace"],
      dataNamespace = _c === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _c;
  var errorMessage = "Unable to render <PayPalButtons /> because window." + dataNamespace + ".Buttons is undefined."; // the JS SDK includes the Buttons component by default when no 'components' are specified.
  // The 'buttons' component must be included in the 'components' list when using it with other components.

  if (components.length && !components.includes("buttons")) {
    var expectedComponents = components + ",buttons";
    errorMessage += "\nTo fix the issue, add 'buttons' to the list of components passed to the parent PayPalScriptProvider:" + ("\n`<PayPalScriptProvider options={{ components: '" + expectedComponents + "'}}>`.");
  }

  return errorMessage;
}
/**
The `<PayPalMarks />` component is used for conditionally rendering different payment options using radio buttons.
The [Display PayPal Buttons with other Payment Methods guide](https://developer.paypal.com/docs/business/checkout/add-capabilities/buyer-experience/#display-paypal-buttons-with-other-payment-methods) describes this style of integration in detail.
It relies on the `<PayPalScriptProvider />` parent component for managing state related to loading the JS SDK script.

```jsx
    <PayPalMarks />
```

This component can also be configured to use a single funding source similar to the [standalone buttons](https://developer.paypal.com/docs/business/checkout/configure-payments/standalone-buttons/) approach.
A `FUNDING` object is exported by this library which has a key for every available funding source option.

```jsx
    import { PayPalScriptProvider, PayPalMarks, FUNDING } from "@paypal/react-paypal-js";

    <PayPalScriptProvider options={{ "client-id": "test", components: "buttons,marks" }}>
        <PayPalMarks fundingSource={FUNDING.PAYPAL}/>
    </PayPalScriptProvider>
```
*/


var PayPalMarks = function PayPalMarks(_a) {
  var _b = _a.className,
      className = _b === void 0 ? "" : _b,
      markProps = __rest(_a, ["className"]);

  var _c = usePayPalScriptReducer()[0],
      isResolved = _c.isResolved,
      options = _c.options;
  var markContainerRef = useRef(null);
  var mark = useRef(null);

  var _d = useState(null),
      setErrorState = _d[1];

  useEffect(function () {
    // verify the sdk script has successfully loaded
    if (isResolved === false) {
      return;
    } // don't rerender when already rendered


    if (mark.current !== null) {
      return;
    }

    var paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]); // verify dependency on window object

    if (paypalWindowNamespace === undefined || paypalWindowNamespace.Marks === undefined) {
      setErrorState(function () {
        throw new Error(getErrorMessage$1(options));
      });
      return;
    }

    mark.current = paypalWindowNamespace.Marks(_assign({}, markProps)); // only render the mark when eligible

    if (mark.current.isEligible() === false) {
      return;
    }

    if (markContainerRef.current === null) {
      return;
    }

    mark.current.render(markContainerRef.current)["catch"](function (err) {
      // component failed to render, possibly because it was closed or destroyed.
      if (markContainerRef.current === null || markContainerRef.current.children.length === 0) {
        // paypal marks container is no longer in the DOM, we can safely ignore the error
        return;
      } // paypal marks container is still in the DOM


      setErrorState(function () {
        throw new Error("Failed to render <PayPalMarks /> component. " + err);
      });
    });
  }, [isResolved, markProps.fundingSource]);
  return React.createElement("div", {
    ref: markContainerRef,
    className: className
  });
};

function getErrorMessage$1(_a) {
  var _b = _a.components,
      components = _b === void 0 ? "" : _b,
      _c = _a["data-namespace"],
      dataNamespace = _c === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _c;
  var errorMessage = "Unable to render <PayPalMarks /> because window." + dataNamespace + ".Marks is undefined."; // the JS SDK does not load the Marks component by default. It must be passed into the "components" query parameter.

  if (!components.includes("marks")) {
    var expectedComponents = components ? components + ",marks" : "marks";
    errorMessage += "\nTo fix the issue, add 'marks' to the list of components passed to the parent PayPalScriptProvider:" + ("\n`<PayPalScriptProvider options={{ components: '" + expectedComponents + "'}}>`.");
  }

  return errorMessage;
}

var PayPalMessages = function PayPalMessages(_a) {
  var _b = _a.className,
      className = _b === void 0 ? "" : _b,
      _c = _a.forceReRender,
      forceReRender = _c === void 0 ? [] : _c,
      messageProps = __rest(_a, ["className", "forceReRender"]);

  var _d = usePayPalScriptReducer()[0],
      isResolved = _d.isResolved,
      options = _d.options;
  var messagesContainerRef = useRef(null);
  var messages = useRef(null);

  var _e = useState(null),
      setErrorState = _e[1];

  useEffect(function () {
    // verify the sdk script has successfully loaded
    if (isResolved === false) {
      return;
    }

    var paypalWindowNamespace = getPayPalWindowNamespace(options["data-namespace"]); // verify dependency on window object

    if (paypalWindowNamespace === undefined || paypalWindowNamespace.Messages === undefined) {
      setErrorState(function () {
        throw new Error(getErrorMessage(options));
      });
      return;
    }

    messages.current = paypalWindowNamespace.Messages(_assign({}, messageProps));

    if (messagesContainerRef.current === null) {
      return;
    }

    messages.current.render(messagesContainerRef.current)["catch"](function (err) {
      // component failed to render, possibly because it was closed or destroyed.
      if (messagesContainerRef.current === null || messagesContainerRef.current.children.length === 0) {
        // paypal messages container is no longer in the DOM, we can safely ignore the error
        return;
      } // paypal messages container is still in the DOM


      setErrorState(function () {
        throw new Error("Failed to render <PayPalMessages /> component. " + err);
      });
    });
  }, __spreadArray([isResolved], forceReRender));
  return React.createElement("div", {
    ref: messagesContainerRef,
    className: className
  });
};

function getErrorMessage(_a) {
  var _b = _a.components,
      components = _b === void 0 ? "" : _b,
      _c = _a["data-namespace"],
      dataNamespace = _c === void 0 ? DEFAULT_PAYPAL_NAMESPACE : _c;
  var errorMessage = "Unable to render <PayPalMessages /> because window." + dataNamespace + ".Messages is undefined."; // the JS SDK does not load the Messages component by default. It must be passed into the "components" query parameter.

  if (!components.includes("messages")) {
    var expectedComponents = components ? components + ",messages" : "messages";
    errorMessage += "\nTo fix the issue, add 'messages' to the list of components passed to the parent PayPalScriptProvider:" + ("\n`<PayPalScriptProvider options={{ components: '" + expectedComponents + "'}}>`.");
  }

  return errorMessage;
}

var FUNDING$1 = {
  PAYPAL: 'paypal',
  VENMO: 'venmo',
  APPLEPAY: 'applepay',
  ITAU: 'itau',
  CREDIT: 'credit',
  PAYLATER: 'paylater',
  CARD: 'card',
  IDEAL: 'ideal',
  SEPA: 'sepa',
  BANCONTACT: 'bancontact',
  GIROPAY: 'giropay',
  SOFORT: 'sofort',
  EPS: 'eps',
  MYBANK: 'mybank',
  P24: 'p24',
  VERKKOPANKKI: 'verkkopankki',
  PAYU: 'payu',
  BLIK: 'blik',
  TRUSTLY: 'trustly',
  ZIMPLER: 'zimpler',
  MAXIMA: 'maxima',
  OXXO: 'oxxo',
  BOLETO: 'boleto',
  WECHATPAY: 'wechatpay',
  MERCADOPAGO: 'mercadopago'
}; // We do not re-export `FUNDING` from the `sdk-constants` module
// directly because it has no type definitions.
//
// See https://github.com/paypal/react-paypal-js/issues/125

var FUNDING = FUNDING$1;
export { FUNDING, PayPalButtons, PayPalMarks, PayPalMessages, PayPalScriptProvider, usePayPalScriptReducer };

{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///react-truncate-markup.min.js","webpack:///webpack/bootstrap 00ee2ec857344021a41b","webpack:///./src/index.js","webpack:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}","webpack:///./node_modules/memoize-one/dist/memoize-one.esm.js","webpack:///./node_modules/line-height/lib/line-height.js","webpack:///./node_modules/computed-style/dist/computedStyle.commonjs.js","webpack:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/tokenize-rules.js","webpack:///./src/atom.js"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_2__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","value","writable","setPrototypeOf","__proto__","TruncateMarkup","_class","_temp","__WEBPACK_IMPORTED_MODULE_0_react__","__WEBPACK_IMPORTED_MODULE_0_react___default","__WEBPACK_IMPORTED_MODULE_1_memoize_one__","__WEBPACK_IMPORTED_MODULE_2_line_height__","__WEBPACK_IMPORTED_MODULE_2_line_height___default","__WEBPACK_IMPORTED_MODULE_3_resize_observer_polyfill__","__WEBPACK_IMPORTED_MODULE_4__tokenize_rules__","__WEBPACK_IMPORTED_MODULE_5__atom__","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","length","descriptor","key","protoProps","staticProps","_extends","assign","arguments","source","SPLIT","LEFT","RIGHT","toString","node","string","undefined","children","Array","isArray","a","Children","map","child","join","cloneWithChildren","isRootEl","level","style","display","validateTree","type","toArray","reduce","isValid","_React$Component","_this","lineHeight","splitDirectionSeq","shouldTruncate","wasLastCharTested","endFound","latestThatFits","onTruncateCalled","toStringMemo","childrenWithRefMemo","childrenElementWithRef","validateTreeMemo","onTruncate","wasTruncated","handleResize","el","prevResizeObserver","disconnect","initialRender","resizeCallback","setState","text","origText","truncate","resizeObserver","observe","setRef","isNewEl","state","componentDidMount","UNSAFE_componentWillReceiveProps","nextProps","_this2","componentDidUpdate","fits","splice","push","tryToFit","componentWillUnmount","truncateOriginalText","only","cloneElement","ref","wordWrap","rootEl","splitDirections","newRootEl","split","ellipsis","newChildren","newChildrenWithEllipsis","concat","shouldRenderEllipsis","isRoot","splitString","splitArray","policy","isAtomic","tokenizeString","splitDirection","restSplitDirections","slice","pivotIndex","Math","ceil","beforeString","substring","afterString","array","beforeArray","afterArray","maxLines","lines","_el$getBoundingClient","getBoundingClientRect","height","round","parseFloat","render","tokenize","characters","Component","Atom","defaultProps","areInputsEqual","newInputs","lastInputs","memoizeOne","resultFn","isEqual","memoized","newArgs","_i","calledOnce","lastThis","lastArgs","lastResult","apply","lnHeightStr","computedStyle","lnHeight","_lnHeightStyle","indexOf","nodeName","_node","document","createElement","innerHTML","toUpperCase","setAttribute","fontSizeStr","fontSize","padding","border","body","appendChild","offsetHeight","removeChild","prop","getComputedStyle","window","currentStyle","replace","word","letter","global","throttle","callback","delay","resolvePending","leadingCall","trailingCall","proxy","timeoutCallback","requestAnimationFrame$1","timeStamp","Date","now","lastCallTime","trailingTimeout","setTimeout","toFloat","getBordersSize","styles","positions","size","position","getPaddings","paddings","positions_1","getSVGContentRect","bbox","getBBox","createRectInit","width","getHTMLElementContentRect","clientWidth","clientHeight","emptyRect","getWindowOf","horizPad","left","right","vertPad","top","bottom","boxSizing","isDocumentElement","vertScrollbar","horizScrollbar","abs","documentElement","getContentRect","isBrowser","isSVGGraphicsElement","createReadOnlyRect","_a","x","y","Constr","DOMRectReadOnly","rect","defineConfigurable","MapShim","getIndex","arr","result","some","entry","index","Map","class_1","__entries__","set","delete","entries","has","clear","forEach","ctx","global$1","Function","requestAnimationFrame","bind","REFRESH_DELAY","transitionKeys","mutationObserverSupported","MutationObserver","ResizeObserverController","connected_","mutationEventsAdded_","mutationsObserver_","observers_","onTransitionEnd_","refresh","addObserver","observer","connect_","removeObserver","observers","disconnect_","updateObservers_","activeObservers","filter","gatherActive","hasActive","broadcastActive","addEventListener","attributes","childList","characterData","subtree","removeEventListener","_b","propertyName","getInstance","instance_","keys","ownerDocument","defaultView","SVGGraphicsElement","SVGElement","ResizeObservation","broadcastWidth","broadcastHeight","contentRect_","isActive","broadcastRect","ResizeObserverEntry","rectInit","contentRect","ResizeObserverSPI","controller","callbackCtx","activeObservations_","observations_","callback_","controller_","callbackCtx_","Element","observations","unobserve","clearActive","observation","WeakMap","ResizeObserver","method","g","eval","e","TOKENIZE_POLICY","str","words","match","test","isAtomComponent","ATOM_STRING_ID","__rtm_atom","reactEl"],"mappings":"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","file":"react-truncate-markup.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ReactTruncateMarkup\"] = factory(require(\"react\"));\n\telse\n\t\troot[\"ReactTruncateMarkup\"] = factory(root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_2__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TruncateMarkup; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_memoize_one__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_line_height__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_line_height___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_line_height__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_resize_observer_polyfill__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__tokenize_rules__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__atom__ = __webpack_require__(9);\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\n\n\n\n\n\n\nvar SPLIT = {\n  LEFT: true,\n  RIGHT: false\n};\n\nvar toString = function toString(node) {\n  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (Object(__WEBPACK_IMPORTED_MODULE_5__atom__[\"c\" /* isAtomComponent */])(node)) {\n    return string + __WEBPACK_IMPORTED_MODULE_5__atom__[\"a\" /* ATOM_STRING_ID */];\n  }\n  var children = Array.isArray(node) ? node : node.props.children || '';\n\n  return string + __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.map(children, function (child) {\n    return toString(child);\n  }).join('');\n};\n\nvar cloneWithChildren = function cloneWithChildren(node, children, isRootEl, level) {\n  var getDisplayStyle = function getDisplayStyle() {\n    if (isRootEl) {\n      return {\n        // root element cannot be an inline element because of the line calculation\n        display: (node.props.style || {}).display || 'block'\n      };\n    } else if (level === 2) {\n      return {\n        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n        display: (node.props.style || {}).display || 'inline-block'\n      };\n    } else return {};\n  };\n\n  return _extends({}, node, {\n    props: _extends({}, node.props, {\n      style: _extends({}, node.props.style, getDisplayStyle()),\n      children: children\n    })\n  });\n};\n\nvar validateTree = function validateTree(node) {\n  if (typeof node === 'string' || Object(__WEBPACK_IMPORTED_MODULE_5__atom__[\"c\" /* isAtomComponent */])(node)) {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (false) {\n      /* eslint-disable no-console */\n      console.error('ReactTruncateMarkup tried to render <' + node.type.name + ' />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported. Alternatively, you can take advantage of the <TruncateMarkup.Atom /> component (see more in the docs https://github.com/parsable/react-truncate-markup/blob/master/README.md#truncatemarkupatom-).');\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.toArray(node.props.children).reduce(function (isValid, child) {\n      return isValid && validateTree(child);\n    }, true);\n  }\n\n  return true;\n};\n\nvar TruncateMarkup = (_temp = _class = function (_React$Component) {\n  _inherits(TruncateMarkup, _React$Component);\n\n  function TruncateMarkup(props) {\n    _classCallCheck(this, TruncateMarkup);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this.lineHeight = null;\n    _this.splitDirectionSeq = [];\n    _this.shouldTruncate = true;\n    _this.wasLastCharTested = false;\n    _this.endFound = false;\n    _this.latestThatFits = null;\n    _this.onTruncateCalled = false;\n    _this.toStringMemo = Object(__WEBPACK_IMPORTED_MODULE_1_memoize_one__[\"a\" /* default */])(toString);\n    _this.childrenWithRefMemo = Object(__WEBPACK_IMPORTED_MODULE_1_memoize_one__[\"a\" /* default */])(_this.childrenElementWithRef);\n    _this.validateTreeMemo = Object(__WEBPACK_IMPORTED_MODULE_1_memoize_one__[\"a\" /* default */])(validateTree);\n\n    _this.onTruncate = function (wasTruncated) {\n      if (!_this.onTruncateCalled) {\n        _this.onTruncateCalled = true;\n        _this.props.onTruncate(wasTruncated);\n      }\n    };\n\n    _this.handleResize = function (el, prevResizeObserver) {\n      // clean up previous observer\n      if (prevResizeObserver) {\n        prevResizeObserver.disconnect();\n      }\n\n      // unmounting or just unsetting the element to be replaced with a new one later\n      if (!el) return null;\n\n      /* Wrapper element resize handing */\n      var initialRender = true;\n      var resizeCallback = function resizeCallback() {\n        if (initialRender) {\n          // ResizeObserer cb is called on initial render too so we are skipping here\n          initialRender = false;\n        } else {\n          // wrapper element has been resized, recalculating with the original text\n          _this.shouldTruncate = false;\n          _this.latestThatFits = null;\n\n          _this.setState({\n            text: _this.origText\n          }, function () {\n            _this.shouldTruncate = true;\n            _this.onTruncateCalled = false;\n            _this.truncate();\n          });\n        }\n      };\n\n      var resizeObserver = prevResizeObserver || new __WEBPACK_IMPORTED_MODULE_3_resize_observer_polyfill__[\"a\" /* default */](resizeCallback);\n\n      resizeObserver.observe(el);\n\n      return resizeObserver;\n    };\n\n    _this.setRef = function (el) {\n      var isNewEl = _this.el !== el;\n      _this.el = el;\n\n      // whenever we obtain a new element, attach resize handler\n      if (isNewEl) {\n        _this.resizeObserver = _this.handleResize(el, _this.resizeObserver);\n      }\n    };\n\n    _this.state = {\n      text: _this.childrenWithRefMemo(_this.props.children)\n    };\n    return _this;\n  }\n\n  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this.lineHeight = this.props.lineHeight || __WEBPACK_IMPORTED_MODULE_2_line_height___default()(this.el);\n    this.truncate();\n  };\n\n  TruncateMarkup.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n\n    this.setState({\n      text: this.childrenWithRefMemo(nextProps.children)\n    }, function () {\n      if (!_this2.isValid) {\n        return;\n      }\n\n      _this2.lineHeight = nextProps.lineHeight || __WEBPACK_IMPORTED_MODULE_2_line_height___default()(_this2.el);\n      _this2.shouldTruncate = true;\n      _this2.truncate();\n    });\n  };\n\n  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.latestThatFits !== null && this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits\n        });\n\n        return;\n        /* eslint-enable */\n      }\n\n      this.onTruncate( /* wasTruncated */true);\n\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this.splitDirectionSeq.splice(this.splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  };\n\n  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.lineHeight = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  };\n\n  TruncateMarkup.prototype.truncate = function truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onTruncate( /* wasTruncated */false);\n\n      return;\n    }\n\n    this.truncateOriginalText();\n  };\n\n  TruncateMarkup.prototype.childrenElementWithRef = function childrenElementWithRef(children) {\n    var child = __WEBPACK_IMPORTED_MODULE_0_react___default.a.Children.only(children);\n\n    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(child, {\n      ref: this.setRef,\n      style: _extends({\n        wordWrap: 'break-word'\n      }, child.props.style)\n    });\n  };\n\n  TruncateMarkup.prototype.truncateOriginalText = function truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  };\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n\n\n  TruncateMarkup.prototype.tryToFit = function tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    var newRootEl = this.split(rootEl, splitDirections, /* isRootEl */true);\n\n    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : this.props.ellipsis;\n\n    ellipsis = (typeof ellipsis === 'undefined' ? 'undefined' : _typeof(ellipsis)) === 'object' ? __WEBPACK_IMPORTED_MODULE_0_react___default.a.cloneElement(ellipsis, { key: 'ellipsis' }) : ellipsis;\n\n    var newChildren = newRootEl.props.children;\n    var newChildrenWithEllipsis = [].concat(newChildren, ellipsis);\n\n    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n    var shouldRenderEllipsis = toString(newChildren) !== this.toStringMemo(this.props.children);\n\n    this.setState({\n      text: _extends({}, newRootEl, {\n        props: _extends({}, newRootEl.props, {\n          children: shouldRenderEllipsis ? newChildrenWithEllipsis : newChildren\n        })\n      })\n    });\n  };\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n\n\n  TruncateMarkup.prototype.split = function split(node, splitDirections) {\n    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    if (!node || Object(__WEBPACK_IMPORTED_MODULE_5__atom__[\"c\" /* isAtomComponent */])(node)) {\n      this.endFound = true;\n\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections, level);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    var newChildren = this.split(node.props.children, splitDirections,\n    /* isRoot */false, level + 1);\n\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  };\n\n  TruncateMarkup.prototype.splitString = function splitString(string) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && this.policy.isAtomic(string)) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    if (this.policy.tokenizeString) {\n      var wordsArray = this.splitArray(this.policy.tokenizeString(string), splitDirections, level);\n\n      // in order to preserve the input structure\n      return wordsArray.join('');\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(string.length / 2);\n    var beforeString = string.substring(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitString(beforeString, restSplitDirections, level);\n    }\n    var afterString = string.substring(pivotIndex);\n\n    return beforeString + this.splitString(afterString, restSplitDirections, level);\n  };\n\n  TruncateMarkup.prototype.splitArray = function splitArray(array) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      return [this.split(array[0], splitDirections, /* isRoot */false, level)];\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(array.length / 2);\n    var beforeArray = array.slice(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitArray(beforeArray, restSplitDirections, level);\n    }\n    var afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(this.splitArray(afterArray, restSplitDirections, level));\n  };\n\n  TruncateMarkup.prototype.fits = function fits() {\n    var maxLines = this.props.lines;\n\n    var _el$getBoundingClient = this.el.getBoundingClientRect(),\n        height = _el$getBoundingClient.height;\n\n    var computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    return maxLines >= computedLines;\n  };\n\n  TruncateMarkup.prototype.render = function render() {\n    return this.state.text;\n  };\n\n  _createClass(TruncateMarkup, [{\n    key: 'isValid',\n    get: function get() {\n      return this.validateTreeMemo(this.props.children);\n    }\n  }, {\n    key: 'origText',\n    get: function get() {\n      return this.childrenWithRefMemo(this.props.children);\n    }\n  }, {\n    key: 'policy',\n    get: function get() {\n      return __WEBPACK_IMPORTED_MODULE_4__tokenize_rules__[\"a\" /* default */][this.props.tokenize] || __WEBPACK_IMPORTED_MODULE_4__tokenize_rules__[\"a\" /* default */].characters;\n    }\n  }]);\n\n  return TruncateMarkup;\n}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component), _class.Atom = __WEBPACK_IMPORTED_MODULE_5__atom__[\"b\" /* Atom */], _class.defaultProps = {\n  lines: 1,\n  ellipsis: '...',\n  lineHeight: '',\n  onTruncate: function onTruncate() {},\n  tokenize: 'characters'\n}, _temp);\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (memoizeOne);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// Load in dependencies\nvar computedStyle = __webpack_require__(5);\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (index);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(7)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nvar TOKENIZE_POLICY = {\n  characters: {\n    tokenizeString: null,\n    isAtomic: function isAtomic(str) {\n      return str.length <= 1;\n    }\n  },\n  words: {\n    tokenizeString: function tokenizeString(str) {\n      return str.match(/(\\s*\\S[\\S\\xA0]*)/g);\n    },\n    isAtomic: function isAtomic(str) {\n      return (/^\\s*[\\S\\xA0]*\\s*$/.test(str)\n      );\n    }\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (TOKENIZE_POLICY);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return Atom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"c\", function() { return isAtomComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return ATOM_STRING_ID; });\nvar Atom = function Atom(props) {\n  return props.children || null;\n};\nAtom.__rtm_atom = true;\n\nvar isAtomComponent = function isAtomComponent(reactEl) {\n  return !!(reactEl && reactEl.type && reactEl.type.__rtm_atom === true);\n};\n\nvar ATOM_STRING_ID = '<Atom>';\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// react-truncate-markup.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 00ee2ec857344021a41b","import React from 'react';\nimport memoizeOne from 'memoize-one';\nimport PropTypes from 'prop-types';\nimport getLineHeight from 'line-height';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport TOKENIZE_POLICY from './tokenize-rules';\nimport { Atom, isAtomComponent, ATOM_STRING_ID } from './atom';\n\nconst SPLIT = {\n  LEFT: true,\n  RIGHT: false,\n};\n\nconst toString = (node, string = '') => {\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (isAtomComponent(node)) {\n    return string + ATOM_STRING_ID;\n  }\n  const children = Array.isArray(node) ? node : node.props.children || '';\n\n  return (\n    string + React.Children.map(children, (child) => toString(child)).join('')\n  );\n};\n\nconst cloneWithChildren = (node, children, isRootEl, level) => {\n  const getDisplayStyle = () => {\n    if (isRootEl) {\n      return {\n        // root element cannot be an inline element because of the line calculation\n        display: (node.props.style || {}).display || 'block',\n      };\n    } else if (level === 2) {\n      return {\n        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n        display: (node.props.style || {}).display || 'inline-block',\n      };\n    } else return {};\n  };\n\n  return {\n    ...node,\n    props: {\n      ...node.props,\n      style: {\n        ...node.props.style,\n        ...getDisplayStyle(),\n      },\n      children,\n    },\n  };\n};\n\nconst validateTree = (node) => {\n  if (typeof node === 'string' || isAtomComponent(node)) {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-console */\n      console.error(\n        `ReactTruncateMarkup tried to render <${node.type.name} />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported. Alternatively, you can take advantage of the <TruncateMarkup.Atom /> component (see more in the docs https://github.com/parsable/react-truncate-markup/blob/master/README.md#truncatemarkupatom-).`,\n      );\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    return React.Children.toArray(node.props.children).reduce(\n      (isValid, child) => isValid && validateTree(child),\n      true,\n    );\n  }\n\n  return true;\n};\n\nexport default class TruncateMarkup extends React.Component {\n  static Atom = Atom;\n\n  static propTypes = {\n    children: PropTypes.element.isRequired,\n    lines: PropTypes.number,\n    ellipsis: PropTypes.oneOfType([\n      PropTypes.element,\n      PropTypes.string,\n      PropTypes.func,\n    ]),\n    lineHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n    onTruncate: PropTypes.func,\n    // eslint-disable-next-line\n    onAfterTruncate: (props, propName, componentName) => {\n      if (props[propName]) {\n        return new Error(\n          `${componentName}: Setting \\`onAfterTruncate\\` prop is deprecated, use \\`onTruncate\\` instead.`,\n        );\n      }\n    },\n    tokenize: (props, propName, componentName) => {\n      const tokenizeValue = props[propName];\n\n      if (typeof tokenizeValue !== 'undefined') {\n        if (!TOKENIZE_POLICY[tokenizeValue]) {\n          /* eslint-disable no-console */\n          return new Error(\n            `${componentName}: Unknown option for prop 'tokenize': '${tokenizeValue}'. Option 'characters' will be used instead.`,\n          );\n          /* eslint-enable */\n        }\n      }\n    },\n  };\n\n  static defaultProps = {\n    lines: 1,\n    ellipsis: '...',\n    lineHeight: '',\n    onTruncate: () => {},\n    tokenize: 'characters',\n  };\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      text: this.childrenWithRefMemo(this.props.children),\n    };\n  }\n\n  lineHeight = null;\n  splitDirectionSeq = [];\n  shouldTruncate = true;\n  wasLastCharTested = false;\n  endFound = false;\n  latestThatFits = null;\n  onTruncateCalled = false;\n\n  toStringMemo = memoizeOne(toString);\n  childrenWithRefMemo = memoizeOne(this.childrenElementWithRef);\n  validateTreeMemo = memoizeOne(validateTree);\n\n  get isValid() {\n    return this.validateTreeMemo(this.props.children);\n  }\n  get origText() {\n    return this.childrenWithRefMemo(this.props.children);\n  }\n  get policy() {\n    return TOKENIZE_POLICY[this.props.tokenize] || TOKENIZE_POLICY.characters;\n  }\n\n  componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this.lineHeight = this.props.lineHeight || getLineHeight(this.el);\n    this.truncate();\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n\n    this.setState(\n      {\n        text: this.childrenWithRefMemo(nextProps.children),\n      },\n      () => {\n        if (!this.isValid) {\n          return;\n        }\n\n        this.lineHeight = nextProps.lineHeight || getLineHeight(this.el);\n        this.shouldTruncate = true;\n        this.truncate();\n      },\n    );\n  }\n\n  componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (\n        this.latestThatFits !== null &&\n        this.state.text !== this.latestThatFits\n      ) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits,\n        });\n\n        return;\n        /* eslint-enable */\n      }\n\n      this.onTruncate(/* wasTruncated */ true);\n\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this.splitDirectionSeq.splice(\n          this.splitDirectionSeq.length - 1,\n          1,\n          SPLIT.RIGHT,\n          SPLIT.LEFT,\n        );\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  }\n\n  componentWillUnmount() {\n    this.lineHeight = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  }\n\n  onTruncate = (wasTruncated) => {\n    if (!this.onTruncateCalled) {\n      this.onTruncateCalled = true;\n      this.props.onTruncate(wasTruncated);\n    }\n  };\n\n  handleResize = (el, prevResizeObserver) => {\n    // clean up previous observer\n    if (prevResizeObserver) {\n      prevResizeObserver.disconnect();\n    }\n\n    // unmounting or just unsetting the element to be replaced with a new one later\n    if (!el) return null;\n\n    /* Wrapper element resize handing */\n    let initialRender = true;\n    const resizeCallback = () => {\n      if (initialRender) {\n        // ResizeObserer cb is called on initial render too so we are skipping here\n        initialRender = false;\n      } else {\n        // wrapper element has been resized, recalculating with the original text\n        this.shouldTruncate = false;\n        this.latestThatFits = null;\n\n        this.setState(\n          {\n            text: this.origText,\n          },\n          () => {\n            this.shouldTruncate = true;\n            this.onTruncateCalled = false;\n            this.truncate();\n          },\n        );\n      }\n    };\n\n    const resizeObserver =\n      prevResizeObserver || new ResizeObserver(resizeCallback);\n\n    resizeObserver.observe(el);\n\n    return resizeObserver;\n  };\n\n  truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onTruncate(/* wasTruncated */ false);\n\n      return;\n    }\n\n    this.truncateOriginalText();\n  }\n\n  setRef = (el) => {\n    const isNewEl = this.el !== el;\n    this.el = el;\n\n    // whenever we obtain a new element, attach resize handler\n    if (isNewEl) {\n      this.resizeObserver = this.handleResize(el, this.resizeObserver);\n    }\n  };\n\n  childrenElementWithRef(children) {\n    const child = React.Children.only(children);\n\n    return React.cloneElement(child, {\n      ref: this.setRef,\n      style: {\n        wordWrap: 'break-word',\n        ...child.props.style,\n      },\n    });\n  }\n\n  truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  }\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n  tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    const newRootEl = this.split(rootEl, splitDirections, /* isRootEl */ true);\n\n    let ellipsis =\n      typeof this.props.ellipsis === 'function'\n        ? this.props.ellipsis(newRootEl)\n        : this.props.ellipsis;\n\n    ellipsis =\n      typeof ellipsis === 'object'\n        ? React.cloneElement(ellipsis, { key: 'ellipsis' })\n        : ellipsis;\n\n    const newChildren = newRootEl.props.children;\n    const newChildrenWithEllipsis = [].concat(newChildren, ellipsis);\n\n    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n    const shouldRenderEllipsis =\n      toString(newChildren) !== this.toStringMemo(this.props.children);\n\n    this.setState({\n      text: {\n        ...newRootEl,\n        props: {\n          ...newRootEl.props,\n          children: shouldRenderEllipsis\n            ? newChildrenWithEllipsis\n            : newChildren,\n        },\n      },\n    });\n  }\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n  split(node, splitDirections, isRoot = false, level = 1) {\n    if (!node || isAtomComponent(node)) {\n      this.endFound = true;\n\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections, level);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    const newChildren = this.split(\n      node.props.children,\n      splitDirections,\n      /* isRoot */ false,\n      level + 1,\n    );\n\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  }\n\n  splitString(string, splitDirections = [], level) {\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && this.policy.isAtomic(string)) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    if (this.policy.tokenizeString) {\n      const wordsArray = this.splitArray(\n        this.policy.tokenizeString(string),\n        splitDirections,\n        level,\n      );\n\n      // in order to preserve the input structure\n      return wordsArray.join('');\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(string.length / 2);\n    const beforeString = string.substring(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitString(beforeString, restSplitDirections, level);\n    }\n    const afterString = string.substring(pivotIndex);\n\n    return (\n      beforeString + this.splitString(afterString, restSplitDirections, level)\n    );\n  }\n\n  splitArray(array, splitDirections = [], level) {\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      return [this.split(array[0], splitDirections, /* isRoot */ false, level)];\n    }\n\n    const [splitDirection, ...restSplitDirections] = splitDirections;\n    const pivotIndex = Math.ceil(array.length / 2);\n    const beforeArray = array.slice(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitArray(beforeArray, restSplitDirections, level);\n    }\n    const afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(\n      this.splitArray(afterArray, restSplitDirections, level),\n    );\n  }\n\n  fits() {\n    const { lines: maxLines } = this.props;\n    const { height } = this.el.getBoundingClientRect();\n    const computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    return maxLines >= computedLines;\n  }\n\n  render() {\n    return this.state.text;\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = __WEBPACK_EXTERNAL_MODULE_2__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n// module id = 2\n// module chunks = 0","function areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/memoize-one/dist/memoize-one.esm.js\n// module id = 3\n// module chunks = 0","// Load in dependencies\nvar computedStyle = require('computed-style');\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/line-height/lib/line-height.js\n// module id = 4\n// module chunks = 0","// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/computed-style/dist/computedStyle.commonjs.js\n// module id = 5\n// module chunks = 0","/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\r\n/* eslint-disable require-jsdoc, valid-jsdoc */\r\nvar MapShim = (function () {\r\n    if (typeof Map !== 'undefined') {\r\n        return Map;\r\n    }\r\n    /**\r\n     * Returns index in provided array that matches the specified key.\r\n     *\r\n     * @param {Array<Array>} arr\r\n     * @param {*} key\r\n     * @returns {number}\r\n     */\r\n    function getIndex(arr, key) {\r\n        var result = -1;\r\n        arr.some(function (entry, index) {\r\n            if (entry[0] === key) {\r\n                result = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return result;\r\n    }\r\n    return /** @class */ (function () {\r\n        function class_1() {\r\n            this.__entries__ = [];\r\n        }\r\n        Object.defineProperty(class_1.prototype, \"size\", {\r\n            /**\r\n             * @returns {boolean}\r\n             */\r\n            get: function () {\r\n                return this.__entries__.length;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        /**\r\n         * @param {*} key\r\n         * @returns {*}\r\n         */\r\n        class_1.prototype.get = function (key) {\r\n            var index = getIndex(this.__entries__, key);\r\n            var entry = this.__entries__[index];\r\n            return entry && entry[1];\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @param {*} value\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.set = function (key, value) {\r\n            var index = getIndex(this.__entries__, key);\r\n            if (~index) {\r\n                this.__entries__[index][1] = value;\r\n            }\r\n            else {\r\n                this.__entries__.push([key, value]);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.delete = function (key) {\r\n            var entries = this.__entries__;\r\n            var index = getIndex(entries, key);\r\n            if (~index) {\r\n                entries.splice(index, 1);\r\n            }\r\n        };\r\n        /**\r\n         * @param {*} key\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.has = function (key) {\r\n            return !!~getIndex(this.__entries__, key);\r\n        };\r\n        /**\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.clear = function () {\r\n            this.__entries__.splice(0);\r\n        };\r\n        /**\r\n         * @param {Function} callback\r\n         * @param {*} [ctx=null]\r\n         * @returns {void}\r\n         */\r\n        class_1.prototype.forEach = function (callback, ctx) {\r\n            if (ctx === void 0) { ctx = null; }\r\n            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\r\n                var entry = _a[_i];\r\n                callback.call(ctx, entry[1], entry[0]);\r\n            }\r\n        };\r\n        return class_1;\r\n    }());\r\n})();\n\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\r\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;\n\n// Returns global object of a current environment.\r\nvar global$1 = (function () {\r\n    if (typeof global !== 'undefined' && global.Math === Math) {\r\n        return global;\r\n    }\r\n    if (typeof self !== 'undefined' && self.Math === Math) {\r\n        return self;\r\n    }\r\n    if (typeof window !== 'undefined' && window.Math === Math) {\r\n        return window;\r\n    }\r\n    // eslint-disable-next-line no-new-func\r\n    return Function('return this')();\r\n})();\n\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\r\nvar requestAnimationFrame$1 = (function () {\r\n    if (typeof requestAnimationFrame === 'function') {\r\n        // It's required to use a bounded function because IE sometimes throws\r\n        // an \"Invalid calling object\" error if rAF is invoked without the global\r\n        // object on the left hand side.\r\n        return requestAnimationFrame.bind(global$1);\r\n    }\r\n    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };\r\n})();\n\n// Defines minimum timeout before adding a trailing call.\r\nvar trailingTimeout = 2;\r\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\r\nfunction throttle (callback, delay) {\r\n    var leadingCall = false, trailingCall = false, lastCallTime = 0;\r\n    /**\r\n     * Invokes the original callback function and schedules new invocation if\r\n     * the \"proxy\" was called during current request.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function resolvePending() {\r\n        if (leadingCall) {\r\n            leadingCall = false;\r\n            callback();\r\n        }\r\n        if (trailingCall) {\r\n            proxy();\r\n        }\r\n    }\r\n    /**\r\n     * Callback invoked after the specified delay. It will further postpone\r\n     * invocation of the original function delegating it to the\r\n     * requestAnimationFrame.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function timeoutCallback() {\r\n        requestAnimationFrame$1(resolvePending);\r\n    }\r\n    /**\r\n     * Schedules invocation of the original function.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    function proxy() {\r\n        var timeStamp = Date.now();\r\n        if (leadingCall) {\r\n            // Reject immediately following calls.\r\n            if (timeStamp - lastCallTime < trailingTimeout) {\r\n                return;\r\n            }\r\n            // Schedule new call to be in invoked when the pending one is resolved.\r\n            // This is important for \"transitions\" which never actually start\r\n            // immediately so there is a chance that we might miss one if change\r\n            // happens amids the pending invocation.\r\n            trailingCall = true;\r\n        }\r\n        else {\r\n            leadingCall = true;\r\n            trailingCall = false;\r\n            setTimeout(timeoutCallback, delay);\r\n        }\r\n        lastCallTime = timeStamp;\r\n    }\r\n    return proxy;\r\n}\n\n// Minimum delay before invoking the update of observers.\r\nvar REFRESH_DELAY = 20;\r\n// A list of substrings of CSS properties used to find transition events that\r\n// might affect dimensions of observed elements.\r\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];\r\n// Check if MutationObserver is available.\r\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\r\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\r\nvar ResizeObserverController = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserverController.\r\n     *\r\n     * @private\r\n     */\r\n    function ResizeObserverController() {\r\n        /**\r\n         * Indicates whether DOM listeners have been added.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.connected_ = false;\r\n        /**\r\n         * Tells that controller has subscribed for Mutation Events.\r\n         *\r\n         * @private {boolean}\r\n         */\r\n        this.mutationEventsAdded_ = false;\r\n        /**\r\n         * Keeps reference to the instance of MutationObserver.\r\n         *\r\n         * @private {MutationObserver}\r\n         */\r\n        this.mutationsObserver_ = null;\r\n        /**\r\n         * A list of connected observers.\r\n         *\r\n         * @private {Array<ResizeObserverSPI>}\r\n         */\r\n        this.observers_ = [];\r\n        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\r\n        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\r\n    }\r\n    /**\r\n     * Adds observer to observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be added.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.addObserver = function (observer) {\r\n        if (!~this.observers_.indexOf(observer)) {\r\n            this.observers_.push(observer);\r\n        }\r\n        // Add listeners if they haven't been added yet.\r\n        if (!this.connected_) {\r\n            this.connect_();\r\n        }\r\n    };\r\n    /**\r\n     * Removes observer from observers list.\r\n     *\r\n     * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.removeObserver = function (observer) {\r\n        var observers = this.observers_;\r\n        var index = observers.indexOf(observer);\r\n        // Remove observer if it's present in registry.\r\n        if (~index) {\r\n            observers.splice(index, 1);\r\n        }\r\n        // Remove listeners if controller has no connected observers.\r\n        if (!observers.length && this.connected_) {\r\n            this.disconnect_();\r\n        }\r\n    };\r\n    /**\r\n     * Invokes the update of observers. It will continue running updates insofar\r\n     * it detects changes.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.refresh = function () {\r\n        var changesDetected = this.updateObservers_();\r\n        // Continue running updates if changes have been detected as there might\r\n        // be future ones caused by CSS transitions.\r\n        if (changesDetected) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Updates every observer from observers list and notifies them of queued\r\n     * entries.\r\n     *\r\n     * @private\r\n     * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n     *      dimensions of it's elements.\r\n     */\r\n    ResizeObserverController.prototype.updateObservers_ = function () {\r\n        // Collect observers that have active observations.\r\n        var activeObservers = this.observers_.filter(function (observer) {\r\n            return observer.gatherActive(), observer.hasActive();\r\n        });\r\n        // Deliver notifications in a separate cycle in order to avoid any\r\n        // collisions between observers, e.g. when multiple instances of\r\n        // ResizeObserver are tracking the same element and the callback of one\r\n        // of them changes content dimensions of the observed target. Sometimes\r\n        // this may result in notifications being blocked for the rest of observers.\r\n        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });\r\n        return activeObservers.length > 0;\r\n    };\r\n    /**\r\n     * Initializes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.connect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already added.\r\n        if (!isBrowser || this.connected_) {\r\n            return;\r\n        }\r\n        // Subscription to the \"Transitionend\" event is used as a workaround for\r\n        // delayed transitions. This way it's possible to capture at least the\r\n        // final state of an element.\r\n        document.addEventListener('transitionend', this.onTransitionEnd_);\r\n        window.addEventListener('resize', this.refresh);\r\n        if (mutationObserverSupported) {\r\n            this.mutationsObserver_ = new MutationObserver(this.refresh);\r\n            this.mutationsObserver_.observe(document, {\r\n                attributes: true,\r\n                childList: true,\r\n                characterData: true,\r\n                subtree: true\r\n            });\r\n        }\r\n        else {\r\n            document.addEventListener('DOMSubtreeModified', this.refresh);\r\n            this.mutationEventsAdded_ = true;\r\n        }\r\n        this.connected_ = true;\r\n    };\r\n    /**\r\n     * Removes DOM listeners.\r\n     *\r\n     * @private\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.disconnect_ = function () {\r\n        // Do nothing if running in a non-browser environment or if listeners\r\n        // have been already removed.\r\n        if (!isBrowser || !this.connected_) {\r\n            return;\r\n        }\r\n        document.removeEventListener('transitionend', this.onTransitionEnd_);\r\n        window.removeEventListener('resize', this.refresh);\r\n        if (this.mutationsObserver_) {\r\n            this.mutationsObserver_.disconnect();\r\n        }\r\n        if (this.mutationEventsAdded_) {\r\n            document.removeEventListener('DOMSubtreeModified', this.refresh);\r\n        }\r\n        this.mutationsObserver_ = null;\r\n        this.mutationEventsAdded_ = false;\r\n        this.connected_ = false;\r\n    };\r\n    /**\r\n     * \"Transitionend\" event handler.\r\n     *\r\n     * @private\r\n     * @param {TransitionEvent} event\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\r\n        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;\r\n        // Detect whether transition may affect dimensions of an element.\r\n        var isReflowProperty = transitionKeys.some(function (key) {\r\n            return !!~propertyName.indexOf(key);\r\n        });\r\n        if (isReflowProperty) {\r\n            this.refresh();\r\n        }\r\n    };\r\n    /**\r\n     * Returns instance of the ResizeObserverController.\r\n     *\r\n     * @returns {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.getInstance = function () {\r\n        if (!this.instance_) {\r\n            this.instance_ = new ResizeObserverController();\r\n        }\r\n        return this.instance_;\r\n    };\r\n    /**\r\n     * Holds reference to the controller's instance.\r\n     *\r\n     * @private {ResizeObserverController}\r\n     */\r\n    ResizeObserverController.instance_ = null;\r\n    return ResizeObserverController;\r\n}());\n\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\r\nvar defineConfigurable = (function (target, props) {\r\n    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        Object.defineProperty(target, key, {\r\n            value: props[key],\r\n            enumerable: false,\r\n            writable: false,\r\n            configurable: true\r\n        });\r\n    }\r\n    return target;\r\n});\n\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\r\nvar getWindowOf = (function (target) {\r\n    // Assume that the element is an instance of Node, which means that it\r\n    // has the \"ownerDocument\" property from which we can retrieve a\r\n    // corresponding global object.\r\n    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;\r\n    // Return the local global object if it's not possible extract one from\r\n    // provided element.\r\n    return ownerGlobal || global$1;\r\n});\n\n// Placeholder of an empty content rectangle.\r\nvar emptyRect = createRectInit(0, 0, 0, 0);\r\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\r\nfunction toFloat(value) {\r\n    return parseFloat(value) || 0;\r\n}\r\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\r\nfunction getBordersSize(styles) {\r\n    var positions = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        positions[_i - 1] = arguments[_i];\r\n    }\r\n    return positions.reduce(function (size, position) {\r\n        var value = styles['border-' + position + '-width'];\r\n        return size + toFloat(value);\r\n    }, 0);\r\n}\r\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\r\nfunction getPaddings(styles) {\r\n    var positions = ['top', 'right', 'bottom', 'left'];\r\n    var paddings = {};\r\n    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\r\n        var position = positions_1[_i];\r\n        var value = styles['padding-' + position];\r\n        paddings[position] = toFloat(value);\r\n    }\r\n    return paddings;\r\n}\r\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getSVGContentRect(target) {\r\n    var bbox = target.getBBox();\r\n    return createRectInit(0, 0, bbox.width, bbox.height);\r\n}\r\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getHTMLElementContentRect(target) {\r\n    // Client width & height properties can't be\r\n    // used exclusively as they provide rounded values.\r\n    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;\r\n    // By this condition we can catch all non-replaced inline, hidden and\r\n    // detached elements. Though elements with width & height properties less\r\n    // than 0.5 will be discarded as well.\r\n    //\r\n    // Without it we would need to implement separate methods for each of\r\n    // those cases and it's not possible to perform a precise and performance\r\n    // effective test for hidden elements. E.g. even jQuery's ':visible' filter\r\n    // gives wrong results for elements with width & height less than 0.5.\r\n    if (!clientWidth && !clientHeight) {\r\n        return emptyRect;\r\n    }\r\n    var styles = getWindowOf(target).getComputedStyle(target);\r\n    var paddings = getPaddings(styles);\r\n    var horizPad = paddings.left + paddings.right;\r\n    var vertPad = paddings.top + paddings.bottom;\r\n    // Computed styles of width & height are being used because they are the\r\n    // only dimensions available to JS that contain non-rounded values. It could\r\n    // be possible to utilize the getBoundingClientRect if only it's data wasn't\r\n    // affected by CSS transformations let alone paddings, borders and scroll bars.\r\n    var width = toFloat(styles.width), height = toFloat(styles.height);\r\n    // Width & height include paddings and borders when the 'border-box' box\r\n    // model is applied (except for IE).\r\n    if (styles.boxSizing === 'border-box') {\r\n        // Following conditions are required to handle Internet Explorer which\r\n        // doesn't include paddings and borders to computed CSS dimensions.\r\n        //\r\n        // We can say that if CSS dimensions + paddings are equal to the \"client\"\r\n        // properties then it's either IE, and thus we don't need to subtract\r\n        // anything, or an element merely doesn't have paddings/borders styles.\r\n        if (Math.round(width + horizPad) !== clientWidth) {\r\n            width -= getBordersSize(styles, 'left', 'right') + horizPad;\r\n        }\r\n        if (Math.round(height + vertPad) !== clientHeight) {\r\n            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\r\n        }\r\n    }\r\n    // Following steps can't be applied to the document's root element as its\r\n    // client[Width/Height] properties represent viewport area of the window.\r\n    // Besides, it's as well not necessary as the <html> itself neither has\r\n    // rendered scroll bars nor it can be clipped.\r\n    if (!isDocumentElement(target)) {\r\n        // In some browsers (only in Firefox, actually) CSS width & height\r\n        // include scroll bars size which can be removed at this step as scroll\r\n        // bars are the only difference between rounded dimensions + paddings\r\n        // and \"client\" properties, though that is not always true in Chrome.\r\n        var vertScrollbar = Math.round(width + horizPad) - clientWidth;\r\n        var horizScrollbar = Math.round(height + vertPad) - clientHeight;\r\n        // Chrome has a rather weird rounding of \"client\" properties.\r\n        // E.g. for an element with content width of 314.2px it sometimes gives\r\n        // the client width of 315px and for the width of 314.7px it may give\r\n        // 314px. And it doesn't happen all the time. So just ignore this delta\r\n        // as a non-relevant.\r\n        if (Math.abs(vertScrollbar) !== 1) {\r\n            width -= vertScrollbar;\r\n        }\r\n        if (Math.abs(horizScrollbar) !== 1) {\r\n            height -= horizScrollbar;\r\n        }\r\n    }\r\n    return createRectInit(paddings.left, paddings.top, width, height);\r\n}\r\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nvar isSVGGraphicsElement = (function () {\r\n    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\r\n    // interface.\r\n    if (typeof SVGGraphicsElement !== 'undefined') {\r\n        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };\r\n    }\r\n    // If it's so, then check that element is at least an instance of the\r\n    // SVGElement and that it has the \"getBBox\" method.\r\n    // eslint-disable-next-line no-extra-parens\r\n    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&\r\n        typeof target.getBBox === 'function'); };\r\n})();\r\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\r\nfunction isDocumentElement(target) {\r\n    return target === getWindowOf(target).document.documentElement;\r\n}\r\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction getContentRect(target) {\r\n    if (!isBrowser) {\r\n        return emptyRect;\r\n    }\r\n    if (isSVGGraphicsElement(target)) {\r\n        return getSVGContentRect(target);\r\n    }\r\n    return getHTMLElementContentRect(target);\r\n}\r\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\r\nfunction createReadOnlyRect(_a) {\r\n    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n    // If DOMRectReadOnly is available use it as a prototype for the rectangle.\r\n    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\r\n    var rect = Object.create(Constr.prototype);\r\n    // Rectangle's properties are not writable and non-enumerable.\r\n    defineConfigurable(rect, {\r\n        x: x, y: y, width: width, height: height,\r\n        top: y,\r\n        right: x + width,\r\n        bottom: height + y,\r\n        left: x\r\n    });\r\n    return rect;\r\n}\r\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\r\nfunction createRectInit(x, y, width, height) {\r\n    return { x: x, y: y, width: width, height: height };\r\n}\n\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\r\nvar ResizeObservation = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObservation.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     */\r\n    function ResizeObservation(target) {\r\n        /**\r\n         * Broadcasted width of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastWidth = 0;\r\n        /**\r\n         * Broadcasted height of content rectangle.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.broadcastHeight = 0;\r\n        /**\r\n         * Reference to the last observed content rectangle.\r\n         *\r\n         * @private {DOMRectInit}\r\n         */\r\n        this.contentRect_ = createRectInit(0, 0, 0, 0);\r\n        this.target = target;\r\n    }\r\n    /**\r\n     * Updates content rectangle and tells whether it's width or height properties\r\n     * have changed since the last broadcast.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObservation.prototype.isActive = function () {\r\n        var rect = getContentRect(this.target);\r\n        this.contentRect_ = rect;\r\n        return (rect.width !== this.broadcastWidth ||\r\n            rect.height !== this.broadcastHeight);\r\n    };\r\n    /**\r\n     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n     * from the corresponding properties of the last observed content rectangle.\r\n     *\r\n     * @returns {DOMRectInit} Last observed content rectangle.\r\n     */\r\n    ResizeObservation.prototype.broadcastRect = function () {\r\n        var rect = this.contentRect_;\r\n        this.broadcastWidth = rect.width;\r\n        this.broadcastHeight = rect.height;\r\n        return rect;\r\n    };\r\n    return ResizeObservation;\r\n}());\n\nvar ResizeObserverEntry = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of ResizeObserverEntry.\r\n     *\r\n     * @param {Element} target - Element that is being observed.\r\n     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n     */\r\n    function ResizeObserverEntry(target, rectInit) {\r\n        var contentRect = createReadOnlyRect(rectInit);\r\n        // According to the specification following properties are not writable\r\n        // and are also not enumerable in the native implementation.\r\n        //\r\n        // Property accessors are not being used as they'd require to define a\r\n        // private WeakMap storage which may cause memory leaks in browsers that\r\n        // don't support this type of collections.\r\n        defineConfigurable(this, { target: target, contentRect: contentRect });\r\n    }\r\n    return ResizeObserverEntry;\r\n}());\n\nvar ResizeObserverSPI = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n     *      when one of the observed elements changes it's content dimensions.\r\n     * @param {ResizeObserverController} controller - Controller instance which\r\n     *      is responsible for the updates of observer.\r\n     * @param {ResizeObserver} callbackCtx - Reference to the public\r\n     *      ResizeObserver instance which will be passed to callback function.\r\n     */\r\n    function ResizeObserverSPI(callback, controller, callbackCtx) {\r\n        /**\r\n         * Collection of resize observations that have detected changes in dimensions\r\n         * of elements.\r\n         *\r\n         * @private {Array<ResizeObservation>}\r\n         */\r\n        this.activeObservations_ = [];\r\n        /**\r\n         * Registry of the ResizeObservation instances.\r\n         *\r\n         * @private {Map<Element, ResizeObservation>}\r\n         */\r\n        this.observations_ = new MapShim();\r\n        if (typeof callback !== 'function') {\r\n            throw new TypeError('The callback provided as parameter 1 is not a function.');\r\n        }\r\n        this.callback_ = callback;\r\n        this.controller_ = controller;\r\n        this.callbackCtx_ = callbackCtx;\r\n    }\r\n    /**\r\n     * Starts observing provided element.\r\n     *\r\n     * @param {Element} target - Element to be observed.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.observe = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is already being observed.\r\n        if (observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.set(target, new ResizeObservation(target));\r\n        this.controller_.addObserver(this);\r\n        // Force the update of observations.\r\n        this.controller_.refresh();\r\n    };\r\n    /**\r\n     * Stops observing provided element.\r\n     *\r\n     * @param {Element} target - Element to stop observing.\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.unobserve = function (target) {\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        // Do nothing if current environment doesn't have the Element interface.\r\n        if (typeof Element === 'undefined' || !(Element instanceof Object)) {\r\n            return;\r\n        }\r\n        if (!(target instanceof getWindowOf(target).Element)) {\r\n            throw new TypeError('parameter 1 is not of type \"Element\".');\r\n        }\r\n        var observations = this.observations_;\r\n        // Do nothing if element is not being observed.\r\n        if (!observations.has(target)) {\r\n            return;\r\n        }\r\n        observations.delete(target);\r\n        if (!observations.size) {\r\n            this.controller_.removeObserver(this);\r\n        }\r\n    };\r\n    /**\r\n     * Stops observing all elements.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.disconnect = function () {\r\n        this.clearActive();\r\n        this.observations_.clear();\r\n        this.controller_.removeObserver(this);\r\n    };\r\n    /**\r\n     * Collects observation instances the associated element of which has changed\r\n     * it's content rectangle.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.gatherActive = function () {\r\n        var _this = this;\r\n        this.clearActive();\r\n        this.observations_.forEach(function (observation) {\r\n            if (observation.isActive()) {\r\n                _this.activeObservations_.push(observation);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Invokes initial callback function with a list of ResizeObserverEntry\r\n     * instances collected from active resize observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.broadcastActive = function () {\r\n        // Do nothing if observer doesn't have active observations.\r\n        if (!this.hasActive()) {\r\n            return;\r\n        }\r\n        var ctx = this.callbackCtx_;\r\n        // Create ResizeObserverEntry instance for every active observation.\r\n        var entries = this.activeObservations_.map(function (observation) {\r\n            return new ResizeObserverEntry(observation.target, observation.broadcastRect());\r\n        });\r\n        this.callback_.call(ctx, entries, ctx);\r\n        this.clearActive();\r\n    };\r\n    /**\r\n     * Clears the collection of active observations.\r\n     *\r\n     * @returns {void}\r\n     */\r\n    ResizeObserverSPI.prototype.clearActive = function () {\r\n        this.activeObservations_.splice(0);\r\n    };\r\n    /**\r\n     * Tells whether observer has active observations.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    ResizeObserverSPI.prototype.hasActive = function () {\r\n        return this.activeObservations_.length > 0;\r\n    };\r\n    return ResizeObserverSPI;\r\n}());\n\n// Registry of internal observers. If WeakMap is not available use current shim\r\n// for the Map collection as it has all required methods and because WeakMap\r\n// can't be fully polyfilled anyway.\r\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\r\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\r\nvar ResizeObserver = /** @class */ (function () {\r\n    /**\r\n     * Creates a new instance of ResizeObserver.\r\n     *\r\n     * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n     *      dimensions of the observed elements change.\r\n     */\r\n    function ResizeObserver(callback) {\r\n        if (!(this instanceof ResizeObserver)) {\r\n            throw new TypeError('Cannot call a class as a function.');\r\n        }\r\n        if (!arguments.length) {\r\n            throw new TypeError('1 argument required, but only 0 present.');\r\n        }\r\n        var controller = ResizeObserverController.getInstance();\r\n        var observer = new ResizeObserverSPI(callback, controller, this);\r\n        observers.set(this, observer);\r\n    }\r\n    return ResizeObserver;\r\n}());\r\n// Expose public methods of ResizeObserver.\r\n[\r\n    'observe',\r\n    'unobserve',\r\n    'disconnect'\r\n].forEach(function (method) {\r\n    ResizeObserver.prototype[method] = function () {\r\n        var _a;\r\n        return (_a = observers.get(this))[method].apply(_a, arguments);\r\n    };\r\n});\n\nvar index = (function () {\r\n    // Export existing implementation if available.\r\n    if (typeof global$1.ResizeObserver !== 'undefined') {\r\n        return global$1.ResizeObserver;\r\n    }\r\n    return ResizeObserver;\r\n})();\n\nexport default index;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n// module id = 6\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 7\n// module chunks = 0","const TOKENIZE_POLICY = {\n  characters: {\n    tokenizeString: null,\n    isAtomic: (str) => str.length <= 1,\n  },\n  words: {\n    tokenizeString: (str) => str.match(/(\\s*\\S[\\S\\xA0]*)/g),\n    isAtomic: (str) => /^\\s*[\\S\\xA0]*\\s*$/.test(str),\n  },\n};\n\nexport default TOKENIZE_POLICY;\n\n\n\n// WEBPACK FOOTER //\n// ./src/tokenize-rules.js","export const Atom = (props) => {\n  return props.children || null;\n};\nAtom.__rtm_atom = true;\n\nexport const isAtomComponent = (reactEl) => {\n  return !!(reactEl && reactEl.type && reactEl.type.__rtm_atom === true);\n};\n\nexport const ATOM_STRING_ID = '<Atom>';\n\n\n\n// WEBPACK FOOTER //\n// ./src/atom.js"],"sourceRoot":""}
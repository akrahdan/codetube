{"ast":null,"code":"// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromActiveItemId(state) {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  var accumulatedCollectionsCount = state.collections.map(function (collections) {\n    return collections.items.length;\n  }).reduce(function (acc, collectionsCount, index) {\n    var previousValue = acc[index - 1] || 0;\n    var nextValue = previousValue + collectionsCount;\n    acc.push(nextValue);\n    return acc;\n  }, []); // Based on the accumulated counts, we can infer the index of the suggestion.\n\n  var collectionIndex = accumulatedCollectionsCount.reduce(function (acc, current) {\n    if (current <= state.activeItemId) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n  return state.collections[collectionIndex];\n}\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      ↑\n *         (absolute: 3, relative: 1)\n */\n\n\nfunction getRelativeActiveItemId(_ref) {\n  var state = _ref.state,\n      collection = _ref.collection;\n  var isOffsetFound = false;\n  var counter = 0;\n  var previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    var currentCollection = state.collections[counter];\n\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentCollection.items.length;\n    counter++;\n  }\n\n  return state.activeItemId - previousItemsOffset;\n}\n\nexport function getActiveItem(state) {\n  var collection = getCollectionFromActiveItemId(state);\n\n  if (!collection) {\n    return null;\n  }\n\n  var item = collection.items[getRelativeActiveItemId({\n    state: state,\n    collection: collection\n  })];\n  var source = collection.source;\n  var itemInputValue = source.getItemInputValue({\n    item: item,\n    state: state\n  });\n  var itemUrl = source.getItemUrl({\n    item: item,\n    state: state\n  });\n  return {\n    item: item,\n    itemInputValue: itemInputValue,\n    itemUrl: itemUrl,\n    source: source\n  };\n}","map":{"version":3,"sources":["/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/@algolia/autocomplete-core/dist/esm/utils/getActiveItem.js"],"names":["getCollectionFromActiveItemId","state","accumulatedCollectionsCount","collections","map","items","length","reduce","acc","collectionsCount","index","previousValue","nextValue","push","collectionIndex","current","activeItemId","getRelativeActiveItemId","_ref","collection","isOffsetFound","counter","previousItemsOffset","currentCollection","getActiveItem","item","source","itemInputValue","getItemInputValue","itemUrl","getItemUrl"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,6BAAT,CAAuCC,KAAvC,EAA8C;AAC5C;AACA;AACA;AACA,MAAIC,2BAA2B,GAAGD,KAAK,CAACE,WAAN,CAAkBC,GAAlB,CAAsB,UAAUD,WAAV,EAAuB;AAC7E,WAAOA,WAAW,CAACE,KAAZ,CAAkBC,MAAzB;AACD,GAFiC,EAE/BC,MAF+B,CAExB,UAAUC,GAAV,EAAeC,gBAAf,EAAiCC,KAAjC,EAAwC;AAChD,QAAIC,aAAa,GAAGH,GAAG,CAACE,KAAK,GAAG,CAAT,CAAH,IAAkB,CAAtC;AACA,QAAIE,SAAS,GAAGD,aAAa,GAAGF,gBAAhC;AACAD,IAAAA,GAAG,CAACK,IAAJ,CAASD,SAAT;AACA,WAAOJ,GAAP;AACD,GAPiC,EAO/B,EAP+B,CAAlC,CAJ4C,CAWpC;;AAER,MAAIM,eAAe,GAAGZ,2BAA2B,CAACK,MAA5B,CAAmC,UAAUC,GAAV,EAAeO,OAAf,EAAwB;AAC/E,QAAIA,OAAO,IAAId,KAAK,CAACe,YAArB,EAAmC;AACjC,aAAOR,GAAG,GAAG,CAAb;AACD;;AAED,WAAOA,GAAP;AACD,GANqB,EAMnB,CANmB,CAAtB;AAOA,SAAOP,KAAK,CAACE,WAAN,CAAkBW,eAAlB,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASG,uBAAT,CAAiCC,IAAjC,EAAuC;AACrC,MAAIjB,KAAK,GAAGiB,IAAI,CAACjB,KAAjB;AAAA,MACIkB,UAAU,GAAGD,IAAI,CAACC,UADtB;AAEA,MAAIC,aAAa,GAAG,KAApB;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,mBAAmB,GAAG,CAA1B;;AAEA,SAAOF,aAAa,KAAK,KAAzB,EAAgC;AAC9B,QAAIG,iBAAiB,GAAGtB,KAAK,CAACE,WAAN,CAAkBkB,OAAlB,CAAxB;;AAEA,QAAIE,iBAAiB,KAAKJ,UAA1B,EAAsC;AACpCC,MAAAA,aAAa,GAAG,IAAhB;AACA;AACD;;AAEDE,IAAAA,mBAAmB,IAAIC,iBAAiB,CAAClB,KAAlB,CAAwBC,MAA/C;AACAe,IAAAA,OAAO;AACR;;AAED,SAAOpB,KAAK,CAACe,YAAN,GAAqBM,mBAA5B;AACD;;AAED,OAAO,SAASE,aAAT,CAAuBvB,KAAvB,EAA8B;AACnC,MAAIkB,UAAU,GAAGnB,6BAA6B,CAACC,KAAD,CAA9C;;AAEA,MAAI,CAACkB,UAAL,EAAiB;AACf,WAAO,IAAP;AACD;;AAED,MAAIM,IAAI,GAAGN,UAAU,CAACd,KAAX,CAAiBY,uBAAuB,CAAC;AAClDhB,IAAAA,KAAK,EAAEA,KAD2C;AAElDkB,IAAAA,UAAU,EAAEA;AAFsC,GAAD,CAAxC,CAAX;AAIA,MAAIO,MAAM,GAAGP,UAAU,CAACO,MAAxB;AACA,MAAIC,cAAc,GAAGD,MAAM,CAACE,iBAAP,CAAyB;AAC5CH,IAAAA,IAAI,EAAEA,IADsC;AAE5CxB,IAAAA,KAAK,EAAEA;AAFqC,GAAzB,CAArB;AAIA,MAAI4B,OAAO,GAAGH,MAAM,CAACI,UAAP,CAAkB;AAC9BL,IAAAA,IAAI,EAAEA,IADwB;AAE9BxB,IAAAA,KAAK,EAAEA;AAFuB,GAAlB,CAAd;AAIA,SAAO;AACLwB,IAAAA,IAAI,EAAEA,IADD;AAELE,IAAAA,cAAc,EAAEA,cAFX;AAGLE,IAAAA,OAAO,EAAEA,OAHJ;AAILH,IAAAA,MAAM,EAAEA;AAJH,GAAP;AAMD","sourcesContent":["// We don't have access to the autocomplete source when we call `onKeyDown`\n// or `onClick` because those are native browser events.\n// However, we can get the source from the suggestion index.\nfunction getCollectionFromActiveItemId(state) {\n  // Given 3 sources with respectively 1, 2 and 3 suggestions: [1, 2, 3]\n  // We want to get the accumulated counts:\n  // [1, 1 + 2, 1 + 2 + 3] = [1, 3, 3 + 3] = [1, 3, 6]\n  var accumulatedCollectionsCount = state.collections.map(function (collections) {\n    return collections.items.length;\n  }).reduce(function (acc, collectionsCount, index) {\n    var previousValue = acc[index - 1] || 0;\n    var nextValue = previousValue + collectionsCount;\n    acc.push(nextValue);\n    return acc;\n  }, []); // Based on the accumulated counts, we can infer the index of the suggestion.\n\n  var collectionIndex = accumulatedCollectionsCount.reduce(function (acc, current) {\n    if (current <= state.activeItemId) {\n      return acc + 1;\n    }\n\n    return acc;\n  }, 0);\n  return state.collections[collectionIndex];\n}\n/**\n * Gets the highlighted index relative to a suggestion object (not the absolute\n * highlighted index).\n *\n * Example:\n *  [['a', 'b'], ['c', 'd', 'e'], ['f']]\n *                      ↑\n *         (absolute: 3, relative: 1)\n */\n\n\nfunction getRelativeActiveItemId(_ref) {\n  var state = _ref.state,\n      collection = _ref.collection;\n  var isOffsetFound = false;\n  var counter = 0;\n  var previousItemsOffset = 0;\n\n  while (isOffsetFound === false) {\n    var currentCollection = state.collections[counter];\n\n    if (currentCollection === collection) {\n      isOffsetFound = true;\n      break;\n    }\n\n    previousItemsOffset += currentCollection.items.length;\n    counter++;\n  }\n\n  return state.activeItemId - previousItemsOffset;\n}\n\nexport function getActiveItem(state) {\n  var collection = getCollectionFromActiveItemId(state);\n\n  if (!collection) {\n    return null;\n  }\n\n  var item = collection.items[getRelativeActiveItemId({\n    state: state,\n    collection: collection\n  })];\n  var source = collection.source;\n  var itemInputValue = source.getItemInputValue({\n    item: item,\n    state: state\n  });\n  var itemUrl = source.getItemUrl({\n    item: item,\n    state: state\n  });\n  return {\n    item: item,\n    itemInputValue: itemInputValue,\n    itemUrl: itemUrl,\n    source: source\n  };\n}"]},"metadata":{},"sourceType":"module"}
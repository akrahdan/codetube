{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class, _temp;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React from 'react';\nimport memoizeOne from 'memoize-one';\nimport PropTypes from 'prop-types';\nimport getLineHeight from 'line-height';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport TOKENIZE_POLICY from './tokenize-rules';\nimport { Atom, isAtomComponent, ATOM_STRING_ID } from './atom';\nvar SPLIT = {\n  LEFT: true,\n  RIGHT: false\n};\n\nvar toString = function toString(node) {\n  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (isAtomComponent(node)) {\n    return string + ATOM_STRING_ID;\n  }\n\n  var children = Array.isArray(node) ? node : node.props.children || '';\n  return string + React.Children.map(children, function (child) {\n    return toString(child);\n  }).join('');\n};\n\nvar cloneWithChildren = function cloneWithChildren(node, children, isRootEl, level) {\n  var getDisplayStyle = function getDisplayStyle() {\n    if (isRootEl) {\n      return {\n        // root element cannot be an inline element because of the line calculation\n        display: (node.props.style || {}).display || 'block'\n      };\n    } else if (level === 2) {\n      return {\n        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n        display: (node.props.style || {}).display || 'inline-block'\n      };\n    } else return {};\n  };\n\n  return _extends({}, node, {\n    props: _extends({}, node.props, {\n      style: _extends({}, node.props.style, getDisplayStyle()),\n      children: children\n    })\n  });\n};\n\nvar validateTree = function validateTree(node) {\n  if (typeof node === 'string' || isAtomComponent(node)) {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-console */\n      console.error('ReactTruncateMarkup tried to render <' + node.type.name + ' />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported. Alternatively, you can take advantage of the <TruncateMarkup.Atom /> component (see more in the docs https://github.com/parsable/react-truncate-markup/blob/master/README.md#truncatemarkupatom-).');\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    return React.Children.toArray(node.props.children).reduce(function (isValid, child) {\n      return isValid && validateTree(child);\n    }, true);\n  }\n\n  return true;\n};\n\nvar TruncateMarkup = (_temp = _class = function (_React$Component) {\n  _inherits(TruncateMarkup, _React$Component);\n\n  function TruncateMarkup(props) {\n    _classCallCheck(this, TruncateMarkup);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this.lineHeight = null;\n    _this.splitDirectionSeq = [];\n    _this.shouldTruncate = true;\n    _this.wasLastCharTested = false;\n    _this.endFound = false;\n    _this.latestThatFits = null;\n    _this.onTruncateCalled = false;\n    _this.toStringMemo = memoizeOne(toString);\n    _this.childrenWithRefMemo = memoizeOne(_this.childrenElementWithRef);\n    _this.validateTreeMemo = memoizeOne(validateTree);\n\n    _this.onTruncate = function (wasTruncated) {\n      if (!_this.onTruncateCalled) {\n        _this.onTruncateCalled = true;\n\n        _this.props.onTruncate(wasTruncated);\n      }\n    };\n\n    _this.handleResize = function (el, prevResizeObserver) {\n      // clean up previous observer\n      if (prevResizeObserver) {\n        prevResizeObserver.disconnect();\n      } // unmounting or just unsetting the element to be replaced with a new one later\n\n\n      if (!el) return null;\n      /* Wrapper element resize handing */\n\n      var initialRender = true;\n\n      var resizeCallback = function resizeCallback() {\n        if (initialRender) {\n          // ResizeObserer cb is called on initial render too so we are skipping here\n          initialRender = false;\n        } else {\n          // wrapper element has been resized, recalculating with the original text\n          _this.shouldTruncate = false;\n          _this.latestThatFits = null;\n\n          _this.setState({\n            text: _this.origText\n          }, function () {\n            _this.shouldTruncate = true;\n            _this.onTruncateCalled = false;\n\n            _this.truncate();\n          });\n        }\n      };\n\n      var resizeObserver = prevResizeObserver || new ResizeObserver(resizeCallback);\n      resizeObserver.observe(el);\n      return resizeObserver;\n    };\n\n    _this.setRef = function (el) {\n      var isNewEl = _this.el !== el;\n      _this.el = el; // whenever we obtain a new element, attach resize handler\n\n      if (isNewEl) {\n        _this.resizeObserver = _this.handleResize(el, _this.resizeObserver);\n      }\n    };\n\n    _this.state = {\n      text: _this.childrenWithRefMemo(_this.props.children)\n    };\n    return _this;\n  }\n\n  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isValid) {\n      return;\n    } // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n\n\n    this.lineHeight = this.props.lineHeight || getLineHeight(this.el);\n    this.truncate();\n  };\n\n  TruncateMarkup.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n    this.setState({\n      text: this.childrenWithRefMemo(nextProps.children)\n    }, function () {\n      if (!_this2.isValid) {\n        return;\n      }\n\n      _this2.lineHeight = nextProps.lineHeight || getLineHeight(_this2.el);\n      _this2.shouldTruncate = true;\n\n      _this2.truncate();\n    });\n  };\n\n  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.latestThatFits !== null && this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits\n        });\n        return;\n        /* eslint-enable */\n      }\n\n      this.onTruncate(\n      /* wasTruncated */\n      true);\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text; // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n\n        this.splitDirectionSeq.splice(this.splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  };\n\n  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.lineHeight = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  };\n\n  TruncateMarkup.prototype.truncate = function truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onTruncate(\n      /* wasTruncated */\n      false);\n      return;\n    }\n\n    this.truncateOriginalText();\n  };\n\n  TruncateMarkup.prototype.childrenElementWithRef = function childrenElementWithRef(children) {\n    var child = React.Children.only(children);\n    return React.cloneElement(child, {\n      ref: this.setRef,\n      style: _extends({\n        wordWrap: 'break-word'\n      }, child.props.style)\n    });\n  };\n\n  TruncateMarkup.prototype.truncateOriginalText = function truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  };\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n\n\n  TruncateMarkup.prototype.tryToFit = function tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    var newRootEl = this.split(rootEl, splitDirections,\n    /* isRootEl */\n    true);\n    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : this.props.ellipsis;\n    ellipsis = (typeof ellipsis === 'undefined' ? 'undefined' : _typeof(ellipsis)) === 'object' ? React.cloneElement(ellipsis, {\n      key: 'ellipsis'\n    }) : ellipsis;\n    var newChildren = newRootEl.props.children;\n    var newChildrenWithEllipsis = [].concat(newChildren, ellipsis); // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n\n    var shouldRenderEllipsis = toString(newChildren) !== this.toStringMemo(this.props.children);\n    this.setState({\n      text: _extends({}, newRootEl, {\n        props: _extends({}, newRootEl.props, {\n          children: shouldRenderEllipsis ? newChildrenWithEllipsis : newChildren\n        })\n      })\n    });\n  };\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n\n\n  TruncateMarkup.prototype.split = function split(node, splitDirections) {\n    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    if (!node || isAtomComponent(node)) {\n      this.endFound = true;\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections, level);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    var newChildren = this.split(node.props.children, splitDirections,\n    /* isRoot */\n    false, level + 1);\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  };\n\n  TruncateMarkup.prototype.splitString = function splitString(string) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && this.policy.isAtomic(string)) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    if (this.policy.tokenizeString) {\n      var wordsArray = this.splitArray(this.policy.tokenizeString(string), splitDirections, level); // in order to preserve the input structure\n\n      return wordsArray.join('');\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n    var pivotIndex = Math.ceil(string.length / 2);\n    var beforeString = string.substring(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitString(beforeString, restSplitDirections, level);\n    }\n\n    var afterString = string.substring(pivotIndex);\n    return beforeString + this.splitString(afterString, restSplitDirections, level);\n  };\n\n  TruncateMarkup.prototype.splitArray = function splitArray(array) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      return [this.split(array[0], splitDirections,\n      /* isRoot */\n      false, level)];\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n    var pivotIndex = Math.ceil(array.length / 2);\n    var beforeArray = array.slice(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitArray(beforeArray, restSplitDirections, level);\n    }\n\n    var afterArray = array.slice(pivotIndex);\n    return beforeArray.concat(this.splitArray(afterArray, restSplitDirections, level));\n  };\n\n  TruncateMarkup.prototype.fits = function fits() {\n    var maxLines = this.props.lines;\n\n    var _el$getBoundingClient = this.el.getBoundingClientRect(),\n        height = _el$getBoundingClient.height;\n\n    var computedLines = Math.round(height / parseFloat(this.lineHeight));\n    return maxLines >= computedLines;\n  };\n\n  TruncateMarkup.prototype.render = function render() {\n    return this.state.text;\n  };\n\n  _createClass(TruncateMarkup, [{\n    key: 'isValid',\n    get: function get() {\n      return this.validateTreeMemo(this.props.children);\n    }\n  }, {\n    key: 'origText',\n    get: function get() {\n      return this.childrenWithRefMemo(this.props.children);\n    }\n  }, {\n    key: 'policy',\n    get: function get() {\n      return TOKENIZE_POLICY[this.props.tokenize] || TOKENIZE_POLICY.characters;\n    }\n  }]);\n\n  return TruncateMarkup;\n}(React.Component), _class.Atom = Atom, _class.defaultProps = {\n  lines: 1,\n  ellipsis: '...',\n  lineHeight: '',\n  onTruncate: function onTruncate() {},\n  tokenize: 'characters'\n}, _temp);\nexport { TruncateMarkup as default };\nTruncateMarkup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  children: PropTypes.element.isRequired,\n  lines: PropTypes.number,\n  ellipsis: PropTypes.oneOfType([PropTypes.element, PropTypes.string, PropTypes.func]),\n  lineHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  onTruncate: PropTypes.func,\n  // eslint-disable-next-line\n  onAfterTruncate: function onAfterTruncate(props, propName, componentName) {\n    if (props[propName]) {\n      return new Error(componentName + ': Setting `onAfterTruncate` prop is deprecated, use `onTruncate` instead.');\n    }\n  },\n  tokenize: function tokenize(props, propName, componentName) {\n    var tokenizeValue = props[propName];\n\n    if (typeof tokenizeValue !== 'undefined') {\n      if (!TOKENIZE_POLICY[tokenizeValue]) {\n        /* eslint-disable no-console */\n        return new Error(componentName + ': Unknown option for prop \\'tokenize\\': \\'' + tokenizeValue + '\\'. Option \\'characters\\' will be used instead.');\n        /* eslint-enable */\n      }\n    }\n  }\n} : {};","map":{"version":3,"sources":["/Users/akrah/Documents/dev/codefluent/node_modules/react-truncate-markup/es/index.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","_class","_temp","_extends","assign","arguments","source","hasOwnProperty","call","_classCallCheck","instance","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","value","setPrototypeOf","__proto__","React","memoizeOne","PropTypes","getLineHeight","ResizeObserver","TOKENIZE_POLICY","Atom","isAtomComponent","ATOM_STRING_ID","SPLIT","LEFT","RIGHT","toString","node","string","undefined","children","Array","isArray","Children","map","child","join","cloneWithChildren","isRootEl","level","getDisplayStyle","display","style","validateTree","type","process","env","NODE_ENV","console","error","name","toArray","reduce","isValid","TruncateMarkup","_React$Component","_this","lineHeight","splitDirectionSeq","shouldTruncate","wasLastCharTested","endFound","latestThatFits","onTruncateCalled","toStringMemo","childrenWithRefMemo","childrenElementWithRef","validateTreeMemo","onTruncate","wasTruncated","handleResize","el","prevResizeObserver","disconnect","initialRender","resizeCallback","setState","text","origText","truncate","resizeObserver","observe","setRef","isNewEl","state","componentDidMount","UNSAFE_componentWillReceiveProps","nextProps","_this2","componentDidUpdate","fits","splice","push","tryToFit","componentWillUnmount","truncateOriginalText","only","cloneElement","ref","wordWrap","rootEl","splitDirections","newRootEl","split","ellipsis","newChildren","newChildrenWithEllipsis","concat","shouldRenderEllipsis","isRoot","splitString","splitArray","policy","isAtomic","tokenizeString","wordsArray","splitDirection","restSplitDirections","slice","pivotIndex","Math","ceil","beforeString","substring","afterString","array","beforeArray","afterArray","maxLines","lines","_el$getBoundingClient","getBoundingClientRect","height","computedLines","round","parseFloat","render","get","tokenize","characters","Component","defaultProps","default","propTypes","element","isRequired","number","oneOfType","func","onAfterTruncate","propName","componentName","Error","tokenizeValue"],"mappings":"AAAA,IAAIA,OAAO,GAAG,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA3D,GAAsE,UAAUC,GAAV,EAAe;AAAE,SAAO,OAAOA,GAAd;AAAoB,CAA3G,GAA8G,UAAUA,GAAV,EAAe;AAAE,SAAOA,GAAG,IAAI,OAAOF,MAAP,KAAkB,UAAzB,IAAuCE,GAAG,CAACC,WAAJ,KAAoBH,MAA3D,IAAqEE,GAAG,KAAKF,MAAM,CAACI,SAApF,GAAgG,QAAhG,GAA2G,OAAOF,GAAzH;AAA+H,CAA5Q;;AAEA,IAAIG,YAAY,GAAG,YAAY;AAAE,WAASC,gBAAT,CAA0BC,MAA1B,EAAkCC,KAAlC,EAAyC;AAAE,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACE,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AAAE,UAAIE,UAAU,GAAGH,KAAK,CAACC,CAAD,CAAtB;AAA2BE,MAAAA,UAAU,CAACC,UAAX,GAAwBD,UAAU,CAACC,UAAX,IAAyB,KAAjD;AAAwDD,MAAAA,UAAU,CAACE,YAAX,GAA0B,IAA1B;AAAgC,UAAI,WAAWF,UAAf,EAA2BA,UAAU,CAACG,QAAX,GAAsB,IAAtB;AAA4BC,MAAAA,MAAM,CAACC,cAAP,CAAsBT,MAAtB,EAA8BI,UAAU,CAACM,GAAzC,EAA8CN,UAA9C;AAA4D;AAAE;;AAAC,SAAO,UAAUO,WAAV,EAAuBC,UAAvB,EAAmCC,WAAnC,EAAgD;AAAE,QAAID,UAAJ,EAAgBb,gBAAgB,CAACY,WAAW,CAACd,SAAb,EAAwBe,UAAxB,CAAhB;AAAqD,QAAIC,WAAJ,EAAiBd,gBAAgB,CAACY,WAAD,EAAcE,WAAd,CAAhB;AAA4C,WAAOF,WAAP;AAAqB,GAAhN;AAAmN,CAA9hB,EAAnB;;AAEA,IAAIG,MAAJ,EAAYC,KAAZ;;AAEA,IAAIC,QAAQ,GAAGR,MAAM,CAACS,MAAP,IAAiB,UAAUjB,MAAV,EAAkB;AAAE,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgB,SAAS,CAACf,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AAAE,QAAIiB,MAAM,GAAGD,SAAS,CAAChB,CAAD,CAAtB;;AAA2B,SAAK,IAAIQ,GAAT,IAAgBS,MAAhB,EAAwB;AAAE,UAAIX,MAAM,CAACX,SAAP,CAAiBuB,cAAjB,CAAgCC,IAAhC,CAAqCF,MAArC,EAA6CT,GAA7C,CAAJ,EAAuD;AAAEV,QAAAA,MAAM,CAACU,GAAD,CAAN,GAAcS,MAAM,CAACT,GAAD,CAApB;AAA4B;AAAE;AAAE;;AAAC,SAAOV,MAAP;AAAgB,CAAhQ;;AAEA,SAASsB,eAAT,CAAyBC,QAAzB,EAAmCZ,WAAnC,EAAgD;AAAE,MAAI,EAAEY,QAAQ,YAAYZ,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIa,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;;AAEzJ,SAASC,0BAAT,CAAoCC,IAApC,EAA0CL,IAA1C,EAAgD;AAAE,MAAI,CAACK,IAAL,EAAW;AAAE,UAAM,IAAIC,cAAJ,CAAmB,2DAAnB,CAAN;AAAwF;;AAAC,SAAON,IAAI,KAAK,OAAOA,IAAP,KAAgB,QAAhB,IAA4B,OAAOA,IAAP,KAAgB,UAAjD,CAAJ,GAAmEA,IAAnE,GAA0EK,IAAjF;AAAwF;;AAEhP,SAASE,SAAT,CAAmBC,QAAnB,EAA6BC,UAA7B,EAAyC;AAAE,MAAI,OAAOA,UAAP,KAAsB,UAAtB,IAAoCA,UAAU,KAAK,IAAvD,EAA6D;AAAE,UAAM,IAAIN,SAAJ,CAAc,6DAA6D,OAAOM,UAAlF,CAAN;AAAsG;;AAACD,EAAAA,QAAQ,CAAChC,SAAT,GAAqBW,MAAM,CAACuB,MAAP,CAAcD,UAAU,IAAIA,UAAU,CAACjC,SAAvC,EAAkD;AAAED,IAAAA,WAAW,EAAE;AAAEoC,MAAAA,KAAK,EAAEH,QAAT;AAAmBxB,MAAAA,UAAU,EAAE,KAA/B;AAAsCE,MAAAA,QAAQ,EAAE,IAAhD;AAAsDD,MAAAA,YAAY,EAAE;AAApE;AAAf,GAAlD,CAArB;AAAqK,MAAIwB,UAAJ,EAAgBtB,MAAM,CAACyB,cAAP,GAAwBzB,MAAM,CAACyB,cAAP,CAAsBJ,QAAtB,EAAgCC,UAAhC,CAAxB,GAAsED,QAAQ,CAACK,SAAT,GAAqBJ,UAA3F;AAAwG;;AAE9e,OAAOK,KAAP,MAAkB,OAAlB;AACA,OAAOC,UAAP,MAAuB,aAAvB;AACA,OAAOC,SAAP,MAAsB,YAAtB;AACA,OAAOC,aAAP,MAA0B,aAA1B;AACA,OAAOC,cAAP,MAA2B,0BAA3B;AACA,OAAOC,eAAP,MAA4B,kBAA5B;AACA,SAASC,IAAT,EAAeC,eAAf,EAAgCC,cAAhC,QAAsD,QAAtD;AAEA,IAAIC,KAAK,GAAG;AACVC,EAAAA,IAAI,EAAE,IADI;AAEVC,EAAAA,KAAK,EAAE;AAFG,CAAZ;;AAKA,IAAIC,QAAQ,GAAG,SAASA,QAAT,CAAkBC,IAAlB,EAAwB;AACrC,MAAIC,MAAM,GAAG/B,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBgC,SAAzC,GAAqDhC,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAAjF;;AAEA,MAAI,CAAC8B,IAAL,EAAW;AACT,WAAOC,MAAP;AACD,GAFD,MAEO,IAAI,OAAOD,IAAP,KAAgB,QAApB,EAA8B;AACnC,WAAOC,MAAM,GAAGD,IAAhB;AACD,GAFM,MAEA,IAAIN,eAAe,CAACM,IAAD,CAAnB,EAA2B;AAChC,WAAOC,MAAM,GAAGN,cAAhB;AACD;;AACD,MAAIQ,QAAQ,GAAGC,KAAK,CAACC,OAAN,CAAcL,IAAd,IAAsBA,IAAtB,GAA6BA,IAAI,CAAC/C,KAAL,CAAWkD,QAAX,IAAuB,EAAnE;AAEA,SAAOF,MAAM,GAAGd,KAAK,CAACmB,QAAN,CAAeC,GAAf,CAAmBJ,QAAnB,EAA6B,UAAUK,KAAV,EAAiB;AAC5D,WAAOT,QAAQ,CAACS,KAAD,CAAf;AACD,GAFe,EAEbC,IAFa,CAER,EAFQ,CAAhB;AAGD,CAfD;;AAiBA,IAAIC,iBAAiB,GAAG,SAASA,iBAAT,CAA2BV,IAA3B,EAAiCG,QAAjC,EAA2CQ,QAA3C,EAAqDC,KAArD,EAA4D;AAClF,MAAIC,eAAe,GAAG,SAASA,eAAT,GAA2B;AAC/C,QAAIF,QAAJ,EAAc;AACZ,aAAO;AACL;AACAG,QAAAA,OAAO,EAAE,CAACd,IAAI,CAAC/C,KAAL,CAAW8D,KAAX,IAAoB,EAArB,EAAyBD,OAAzB,IAAoC;AAFxC,OAAP;AAID,KALD,MAKO,IAAIF,KAAK,KAAK,CAAd,EAAiB;AACtB,aAAO;AACL;AACA;AACAE,QAAAA,OAAO,EAAE,CAACd,IAAI,CAAC/C,KAAL,CAAW8D,KAAX,IAAoB,EAArB,EAAyBD,OAAzB,IAAoC;AAHxC,OAAP;AAKD,KANM,MAMA,OAAO,EAAP;AACR,GAbD;;AAeA,SAAO9C,QAAQ,CAAC,EAAD,EAAKgC,IAAL,EAAW;AACxB/C,IAAAA,KAAK,EAAEe,QAAQ,CAAC,EAAD,EAAKgC,IAAI,CAAC/C,KAAV,EAAiB;AAC9B8D,MAAAA,KAAK,EAAE/C,QAAQ,CAAC,EAAD,EAAKgC,IAAI,CAAC/C,KAAL,CAAW8D,KAAhB,EAAuBF,eAAe,EAAtC,CADe;AAE9BV,MAAAA,QAAQ,EAAEA;AAFoB,KAAjB;AADS,GAAX,CAAf;AAMD,CAtBD;;AAwBA,IAAIa,YAAY,GAAG,SAASA,YAAT,CAAsBhB,IAAtB,EAA4B;AAC7C,MAAI,OAAOA,IAAP,KAAgB,QAAhB,IAA4BN,eAAe,CAACM,IAAD,CAA/C,EAAuD;AACrD,WAAO,IAAP;AACD,GAFD,MAEO,IAAI,OAAOA,IAAI,CAACiB,IAAZ,KAAqB,UAAzB,EAAqC;AAC1C,QAAIC,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzC;AACAC,MAAAA,OAAO,CAACC,KAAR,CAAc,0CAA0CtB,IAAI,CAACiB,IAAL,CAAUM,IAApD,GAA2D,kUAAzE;AACA;AACD;;AAED,WAAO,KAAP;AACD;;AAED,MAAIvB,IAAI,CAAC/C,KAAL,CAAWkD,QAAf,EAAyB;AACvB,WAAOhB,KAAK,CAACmB,QAAN,CAAekB,OAAf,CAAuBxB,IAAI,CAAC/C,KAAL,CAAWkD,QAAlC,EAA4CsB,MAA5C,CAAmD,UAAUC,OAAV,EAAmBlB,KAAnB,EAA0B;AAClF,aAAOkB,OAAO,IAAIV,YAAY,CAACR,KAAD,CAA9B;AACD,KAFM,EAEJ,IAFI,CAAP;AAGD;;AAED,SAAO,IAAP;AACD,CApBD;;AAsBA,IAAImB,cAAc,IAAI5D,KAAK,GAAGD,MAAM,GAAG,UAAU8D,gBAAV,EAA4B;AACjEhD,EAAAA,SAAS,CAAC+C,cAAD,EAAiBC,gBAAjB,CAAT;;AAEA,WAASD,cAAT,CAAwB1E,KAAxB,EAA+B;AAC7BqB,IAAAA,eAAe,CAAC,IAAD,EAAOqD,cAAP,CAAf;;AAEA,QAAIE,KAAK,GAAGpD,0BAA0B,CAAC,IAAD,EAAOmD,gBAAgB,CAACvD,IAAjB,CAAsB,IAAtB,EAA4BpB,KAA5B,CAAP,CAAtC;;AAEA4E,IAAAA,KAAK,CAACC,UAAN,GAAmB,IAAnB;AACAD,IAAAA,KAAK,CAACE,iBAAN,GAA0B,EAA1B;AACAF,IAAAA,KAAK,CAACG,cAAN,GAAuB,IAAvB;AACAH,IAAAA,KAAK,CAACI,iBAAN,GAA0B,KAA1B;AACAJ,IAAAA,KAAK,CAACK,QAAN,GAAiB,KAAjB;AACAL,IAAAA,KAAK,CAACM,cAAN,GAAuB,IAAvB;AACAN,IAAAA,KAAK,CAACO,gBAAN,GAAyB,KAAzB;AACAP,IAAAA,KAAK,CAACQ,YAAN,GAAqBjD,UAAU,CAACW,QAAD,CAA/B;AACA8B,IAAAA,KAAK,CAACS,mBAAN,GAA4BlD,UAAU,CAACyC,KAAK,CAACU,sBAAP,CAAtC;AACAV,IAAAA,KAAK,CAACW,gBAAN,GAAyBpD,UAAU,CAAC4B,YAAD,CAAnC;;AAEAa,IAAAA,KAAK,CAACY,UAAN,GAAmB,UAAUC,YAAV,EAAwB;AACzC,UAAI,CAACb,KAAK,CAACO,gBAAX,EAA6B;AAC3BP,QAAAA,KAAK,CAACO,gBAAN,GAAyB,IAAzB;;AACAP,QAAAA,KAAK,CAAC5E,KAAN,CAAYwF,UAAZ,CAAuBC,YAAvB;AACD;AACF,KALD;;AAOAb,IAAAA,KAAK,CAACc,YAAN,GAAqB,UAAUC,EAAV,EAAcC,kBAAd,EAAkC;AACrD;AACA,UAAIA,kBAAJ,EAAwB;AACtBA,QAAAA,kBAAkB,CAACC,UAAnB;AACD,OAJoD,CAMrD;;;AACA,UAAI,CAACF,EAAL,EAAS,OAAO,IAAP;AAET;;AACA,UAAIG,aAAa,GAAG,IAApB;;AACA,UAAIC,cAAc,GAAG,SAASA,cAAT,GAA0B;AAC7C,YAAID,aAAJ,EAAmB;AACjB;AACAA,UAAAA,aAAa,GAAG,KAAhB;AACD,SAHD,MAGO;AACL;AACAlB,UAAAA,KAAK,CAACG,cAAN,GAAuB,KAAvB;AACAH,UAAAA,KAAK,CAACM,cAAN,GAAuB,IAAvB;;AAEAN,UAAAA,KAAK,CAACoB,QAAN,CAAe;AACbC,YAAAA,IAAI,EAAErB,KAAK,CAACsB;AADC,WAAf,EAEG,YAAY;AACbtB,YAAAA,KAAK,CAACG,cAAN,GAAuB,IAAvB;AACAH,YAAAA,KAAK,CAACO,gBAAN,GAAyB,KAAzB;;AACAP,YAAAA,KAAK,CAACuB,QAAN;AACD,WAND;AAOD;AACF,OAjBD;;AAmBA,UAAIC,cAAc,GAAGR,kBAAkB,IAAI,IAAItD,cAAJ,CAAmByD,cAAnB,CAA3C;AAEAK,MAAAA,cAAc,CAACC,OAAf,CAAuBV,EAAvB;AAEA,aAAOS,cAAP;AACD,KAnCD;;AAqCAxB,IAAAA,KAAK,CAAC0B,MAAN,GAAe,UAAUX,EAAV,EAAc;AAC3B,UAAIY,OAAO,GAAG3B,KAAK,CAACe,EAAN,KAAaA,EAA3B;AACAf,MAAAA,KAAK,CAACe,EAAN,GAAWA,EAAX,CAF2B,CAI3B;;AACA,UAAIY,OAAJ,EAAa;AACX3B,QAAAA,KAAK,CAACwB,cAAN,GAAuBxB,KAAK,CAACc,YAAN,CAAmBC,EAAnB,EAAuBf,KAAK,CAACwB,cAA7B,CAAvB;AACD;AACF,KARD;;AAUAxB,IAAAA,KAAK,CAAC4B,KAAN,GAAc;AACZP,MAAAA,IAAI,EAAErB,KAAK,CAACS,mBAAN,CAA0BT,KAAK,CAAC5E,KAAN,CAAYkD,QAAtC;AADM,KAAd;AAGA,WAAO0B,KAAP;AACD;;AAEDF,EAAAA,cAAc,CAAC9E,SAAf,CAAyB6G,iBAAzB,GAA6C,SAASA,iBAAT,GAA6B;AACxE,QAAI,CAAC,KAAKhC,OAAV,EAAmB;AACjB;AACD,KAHuE,CAKxE;AACA;;;AACA,SAAKI,UAAL,GAAkB,KAAK7E,KAAL,CAAW6E,UAAX,IAAyBxC,aAAa,CAAC,KAAKsD,EAAN,CAAxD;AACA,SAAKQ,QAAL;AACD,GATD;;AAWAzB,EAAAA,cAAc,CAAC9E,SAAf,CAAyB8G,gCAAzB,GAA4D,SAASA,gCAAT,CAA0CC,SAA1C,EAAqD;AAC/G,QAAIC,MAAM,GAAG,IAAb;;AAEA,SAAK7B,cAAL,GAAsB,KAAtB;AACA,SAAKG,cAAL,GAAsB,IAAtB;AAEA,SAAKc,QAAL,CAAc;AACZC,MAAAA,IAAI,EAAE,KAAKZ,mBAAL,CAAyBsB,SAAS,CAACzD,QAAnC;AADM,KAAd,EAEG,YAAY;AACb,UAAI,CAAC0D,MAAM,CAACnC,OAAZ,EAAqB;AACnB;AACD;;AAEDmC,MAAAA,MAAM,CAAC/B,UAAP,GAAoB8B,SAAS,CAAC9B,UAAV,IAAwBxC,aAAa,CAACuE,MAAM,CAACjB,EAAR,CAAzD;AACAiB,MAAAA,MAAM,CAAC7B,cAAP,GAAwB,IAAxB;;AACA6B,MAAAA,MAAM,CAACT,QAAP;AACD,KAVD;AAWD,GAjBD;;AAmBAzB,EAAAA,cAAc,CAAC9E,SAAf,CAAyBiH,kBAAzB,GAA8C,SAASA,kBAAT,GAA8B;AAC1E,QAAI,KAAK9B,cAAL,KAAwB,KAAxB,IAAiC,KAAKN,OAAL,KAAiB,KAAtD,EAA6D;AAC3D;AACD;;AAED,QAAI,KAAKQ,QAAT,EAAmB;AACjB;AACA;AACA;AACA,UAAI,KAAKC,cAAL,KAAwB,IAAxB,IAAgC,KAAKsB,KAAL,CAAWP,IAAX,KAAoB,KAAKf,cAA7D,EAA6E;AAC3E;AACA,aAAKc,QAAL,CAAc;AACZC,UAAAA,IAAI,EAAE,KAAKf;AADC,SAAd;AAIA;AACA;AACD;;AAED,WAAKM,UAAL;AAAiB;AAAkB,UAAnC;AAEA;AACD;;AAED,QAAI,KAAKV,iBAAL,CAAuB5E,MAA3B,EAAmC;AACjC,UAAI,KAAK4G,IAAL,EAAJ,EAAiB;AACf,aAAK5B,cAAL,GAAsB,KAAKsB,KAAL,CAAWP,IAAjC,CADe,CAEf;AACA;AACA;AACA;;AACA,aAAKnB,iBAAL,CAAuBiC,MAAvB,CAA8B,KAAKjC,iBAAL,CAAuB5E,MAAvB,GAAgC,CAA9D,EAAiE,CAAjE,EAAoEyC,KAAK,CAACE,KAA1E,EAAiFF,KAAK,CAACC,IAAvF;AACD,OAPD,MAOO;AACL,aAAKkC,iBAAL,CAAuBkC,IAAvB,CAA4BrE,KAAK,CAACC,IAAlC;AACD;;AAED,WAAKqE,QAAL,CAAc,KAAKf,QAAnB,EAA6B,KAAKpB,iBAAlC;AACD;AACF,GAtCD;;AAwCAJ,EAAAA,cAAc,CAAC9E,SAAf,CAAyBsH,oBAAzB,GAAgD,SAASA,oBAAT,GAAgC;AAC9E,SAAKrC,UAAL,GAAkB,IAAlB;AACA,SAAKK,cAAL,GAAsB,IAAtB;AACA,SAAKJ,iBAAL,GAAyB,EAAzB;AACD,GAJD;;AAMAJ,EAAAA,cAAc,CAAC9E,SAAf,CAAyBuG,QAAzB,GAAoC,SAASA,QAAT,GAAoB;AACtD,QAAI,KAAKW,IAAL,EAAJ,EAAiB;AACf;AACA,WAAK/B,cAAL,GAAsB,KAAtB;AACA,WAAKS,UAAL;AAAiB;AAAkB,WAAnC;AAEA;AACD;;AAED,SAAK2B,oBAAL;AACD,GAVD;;AAYAzC,EAAAA,cAAc,CAAC9E,SAAf,CAAyB0F,sBAAzB,GAAkD,SAASA,sBAAT,CAAgCpC,QAAhC,EAA0C;AAC1F,QAAIK,KAAK,GAAGrB,KAAK,CAACmB,QAAN,CAAe+D,IAAf,CAAoBlE,QAApB,CAAZ;AAEA,WAAOhB,KAAK,CAACmF,YAAN,CAAmB9D,KAAnB,EAA0B;AAC/B+D,MAAAA,GAAG,EAAE,KAAKhB,MADqB;AAE/BxC,MAAAA,KAAK,EAAE/C,QAAQ,CAAC;AACdwG,QAAAA,QAAQ,EAAE;AADI,OAAD,EAEZhE,KAAK,CAACvD,KAAN,CAAY8D,KAFA;AAFgB,KAA1B,CAAP;AAMD,GATD;;AAWAY,EAAAA,cAAc,CAAC9E,SAAf,CAAyBuH,oBAAzB,GAAgD,SAASA,oBAAT,GAAgC;AAC9E,SAAKlC,QAAL,GAAgB,KAAhB;AACA,SAAKH,iBAAL,GAAyB,CAACnC,KAAK,CAACC,IAAP,CAAzB;AACA,SAAKoC,iBAAL,GAAyB,KAAzB;AAEA,SAAKiC,QAAL,CAAc,KAAKf,QAAnB,EAA6B,KAAKpB,iBAAlC;AACD,GAND;AAQA;AACF;AACA;AACA;AACA;AACA;;;AAGEJ,EAAAA,cAAc,CAAC9E,SAAf,CAAyBqH,QAAzB,GAAoC,SAASA,QAAT,CAAkBO,MAAlB,EAA0BC,eAA1B,EAA2C;AAC7E,QAAI,CAACD,MAAM,CAACxH,KAAP,CAAakD,QAAlB,EAA4B;AAC1B;AACA;AACD;;AAED,QAAIwE,SAAS,GAAG,KAAKC,KAAL,CAAWH,MAAX,EAAmBC,eAAnB;AAAoC;AAAc,QAAlD,CAAhB;AAEA,QAAIG,QAAQ,GAAG,OAAO,KAAK5H,KAAL,CAAW4H,QAAlB,KAA+B,UAA/B,GAA4C,KAAK5H,KAAL,CAAW4H,QAAX,CAAoBF,SAApB,CAA5C,GAA6E,KAAK1H,KAAL,CAAW4H,QAAvG;AAEAA,IAAAA,QAAQ,GAAG,CAAC,OAAOA,QAAP,KAAoB,WAApB,GAAkC,WAAlC,GAAgDrI,OAAO,CAACqI,QAAD,CAAxD,MAAwE,QAAxE,GAAmF1F,KAAK,CAACmF,YAAN,CAAmBO,QAAnB,EAA6B;AAAEnH,MAAAA,GAAG,EAAE;AAAP,KAA7B,CAAnF,GAAuImH,QAAlJ;AAEA,QAAIC,WAAW,GAAGH,SAAS,CAAC1H,KAAV,CAAgBkD,QAAlC;AACA,QAAI4E,uBAAuB,GAAG,GAAGC,MAAH,CAAUF,WAAV,EAAuBD,QAAvB,CAA9B,CAb6E,CAe7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,QAAII,oBAAoB,GAAGlF,QAAQ,CAAC+E,WAAD,CAAR,KAA0B,KAAKzC,YAAL,CAAkB,KAAKpF,KAAL,CAAWkD,QAA7B,CAArD;AAEA,SAAK8C,QAAL,CAAc;AACZC,MAAAA,IAAI,EAAElF,QAAQ,CAAC,EAAD,EAAK2G,SAAL,EAAgB;AAC5B1H,QAAAA,KAAK,EAAEe,QAAQ,CAAC,EAAD,EAAK2G,SAAS,CAAC1H,KAAf,EAAsB;AACnCkD,UAAAA,QAAQ,EAAE8E,oBAAoB,GAAGF,uBAAH,GAA6BD;AADxB,SAAtB;AADa,OAAhB;AADF,KAAd;AAOD,GArCD;AAuCA;AACF;AACA;AACA;AACA;AACA;;;AAGEnD,EAAAA,cAAc,CAAC9E,SAAf,CAAyB+H,KAAzB,GAAiC,SAASA,KAAT,CAAe5E,IAAf,EAAqB0E,eAArB,EAAsC;AACrE,QAAIQ,MAAM,GAAGhH,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBgC,SAAzC,GAAqDhC,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAjF;AACA,QAAI0C,KAAK,GAAG1C,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBgC,SAAzC,GAAqDhC,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAAhF;;AAEA,QAAI,CAAC8B,IAAD,IAASN,eAAe,CAACM,IAAD,CAA5B,EAAoC;AAClC,WAAKkC,QAAL,GAAgB,IAAhB;AAEA,aAAOlC,IAAP;AACD,KAJD,MAIO,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;AACnC,aAAO,KAAKmF,WAAL,CAAiBnF,IAAjB,EAAuB0E,eAAvB,EAAwC9D,KAAxC,CAAP;AACD,KAFM,MAEA,IAAIR,KAAK,CAACC,OAAN,CAAcL,IAAd,CAAJ,EAAyB;AAC9B,aAAO,KAAKoF,UAAL,CAAgBpF,IAAhB,EAAsB0E,eAAtB,EAAuC9D,KAAvC,CAAP;AACD;;AAED,QAAIkE,WAAW,GAAG,KAAKF,KAAL,CAAW5E,IAAI,CAAC/C,KAAL,CAAWkD,QAAtB,EAAgCuE,eAAhC;AAClB;AAAY,SADM,EACC9D,KAAK,GAAG,CADT,CAAlB;AAGA,WAAOF,iBAAiB,CAACV,IAAD,EAAO8E,WAAP,EAAoBI,MAApB,EAA4BtE,KAA5B,CAAxB;AACD,GAlBD;;AAoBAe,EAAAA,cAAc,CAAC9E,SAAf,CAAyBsI,WAAzB,GAAuC,SAASA,WAAT,CAAqBlF,MAArB,EAA6B;AAClE,QAAIyE,eAAe,GAAGxG,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBgC,SAAzC,GAAqDhC,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA1F;AACA,QAAI0C,KAAK,GAAG1C,SAAS,CAAC,CAAD,CAArB;;AAEA,QAAI,CAACwG,eAAe,CAACvH,MAArB,EAA6B;AAC3B,aAAO8C,MAAP;AACD;;AAED,QAAIyE,eAAe,CAACvH,MAAhB,IAA0B,KAAKkI,MAAL,CAAYC,QAAZ,CAAqBrF,MAArB,CAA9B,EAA4D;AAC1D;AACA;AACA;AACA,UAAI,CAAC,KAAKgC,iBAAV,EAA6B;AAC3B,aAAKA,iBAAL,GAAyB,IAAzB;AACD,OAFD,MAEO;AACL;AACA;AACA,aAAKC,QAAL,GAAgB,IAAhB;AACD;;AAED,aAAOjC,MAAP;AACD;;AAED,QAAI,KAAKoF,MAAL,CAAYE,cAAhB,EAAgC;AAC9B,UAAIC,UAAU,GAAG,KAAKJ,UAAL,CAAgB,KAAKC,MAAL,CAAYE,cAAZ,CAA2BtF,MAA3B,CAAhB,EAAoDyE,eAApD,EAAqE9D,KAArE,CAAjB,CAD8B,CAG9B;;AACA,aAAO4E,UAAU,CAAC/E,IAAX,CAAgB,EAAhB,CAAP;AACD;;AAED,QAAIgF,cAAc,GAAGf,eAAe,CAAC,CAAD,CAApC;AAAA,QACIgB,mBAAmB,GAAGhB,eAAe,CAACiB,KAAhB,CAAsB,CAAtB,CAD1B;AAGA,QAAIC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAU7F,MAAM,CAAC9C,MAAP,GAAgB,CAA1B,CAAjB;AACA,QAAI4I,YAAY,GAAG9F,MAAM,CAAC+F,SAAP,CAAiB,CAAjB,EAAoBJ,UAApB,CAAnB;;AAEA,QAAIH,cAAc,KAAK7F,KAAK,CAACC,IAA7B,EAAmC;AACjC,aAAO,KAAKsF,WAAL,CAAiBY,YAAjB,EAA+BL,mBAA/B,EAAoD9E,KAApD,CAAP;AACD;;AACD,QAAIqF,WAAW,GAAGhG,MAAM,CAAC+F,SAAP,CAAiBJ,UAAjB,CAAlB;AAEA,WAAOG,YAAY,GAAG,KAAKZ,WAAL,CAAiBc,WAAjB,EAA8BP,mBAA9B,EAAmD9E,KAAnD,CAAtB;AACD,GA1CD;;AA4CAe,EAAAA,cAAc,CAAC9E,SAAf,CAAyBuI,UAAzB,GAAsC,SAASA,UAAT,CAAoBc,KAApB,EAA2B;AAC/D,QAAIxB,eAAe,GAAGxG,SAAS,CAACf,MAAV,GAAmB,CAAnB,IAAwBe,SAAS,CAAC,CAAD,CAAT,KAAiBgC,SAAzC,GAAqDhC,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA1F;AACA,QAAI0C,KAAK,GAAG1C,SAAS,CAAC,CAAD,CAArB;;AAEA,QAAI,CAACwG,eAAe,CAACvH,MAArB,EAA6B;AAC3B,aAAO+I,KAAP;AACD;;AAED,QAAIA,KAAK,CAAC/I,MAAN,KAAiB,CAArB,EAAwB;AACtB,aAAO,CAAC,KAAKyH,KAAL,CAAWsB,KAAK,CAAC,CAAD,CAAhB,EAAqBxB,eAArB;AAAsC;AAAY,WAAlD,EAAyD9D,KAAzD,CAAD,CAAP;AACD;;AAED,QAAI6E,cAAc,GAAGf,eAAe,CAAC,CAAD,CAApC;AAAA,QACIgB,mBAAmB,GAAGhB,eAAe,CAACiB,KAAhB,CAAsB,CAAtB,CAD1B;AAGA,QAAIC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUI,KAAK,CAAC/I,MAAN,GAAe,CAAzB,CAAjB;AACA,QAAIgJ,WAAW,GAAGD,KAAK,CAACP,KAAN,CAAY,CAAZ,EAAeC,UAAf,CAAlB;;AAEA,QAAIH,cAAc,KAAK7F,KAAK,CAACC,IAA7B,EAAmC;AACjC,aAAO,KAAKuF,UAAL,CAAgBe,WAAhB,EAA6BT,mBAA7B,EAAkD9E,KAAlD,CAAP;AACD;;AACD,QAAIwF,UAAU,GAAGF,KAAK,CAACP,KAAN,CAAYC,UAAZ,CAAjB;AAEA,WAAOO,WAAW,CAACnB,MAAZ,CAAmB,KAAKI,UAAL,CAAgBgB,UAAhB,EAA4BV,mBAA5B,EAAiD9E,KAAjD,CAAnB,CAAP;AACD,GAxBD;;AA0BAe,EAAAA,cAAc,CAAC9E,SAAf,CAAyBkH,IAAzB,GAAgC,SAASA,IAAT,GAAgB;AAC9C,QAAIsC,QAAQ,GAAG,KAAKpJ,KAAL,CAAWqJ,KAA1B;;AAEA,QAAIC,qBAAqB,GAAG,KAAK3D,EAAL,CAAQ4D,qBAAR,EAA5B;AAAA,QACIC,MAAM,GAAGF,qBAAqB,CAACE,MADnC;;AAGA,QAAIC,aAAa,GAAGb,IAAI,CAACc,KAAL,CAAWF,MAAM,GAAGG,UAAU,CAAC,KAAK9E,UAAN,CAA9B,CAApB;AAEA,WAAOuE,QAAQ,IAAIK,aAAnB;AACD,GATD;;AAWA/E,EAAAA,cAAc,CAAC9E,SAAf,CAAyBgK,MAAzB,GAAkC,SAASA,MAAT,GAAkB;AAClD,WAAO,KAAKpD,KAAL,CAAWP,IAAlB;AACD,GAFD;;AAIApG,EAAAA,YAAY,CAAC6E,cAAD,EAAiB,CAAC;AAC5BjE,IAAAA,GAAG,EAAE,SADuB;AAE5BoJ,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKtE,gBAAL,CAAsB,KAAKvF,KAAL,CAAWkD,QAAjC,CAAP;AACD;AAJ2B,GAAD,EAK1B;AACDzC,IAAAA,GAAG,EAAE,UADJ;AAEDoJ,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAO,KAAKxE,mBAAL,CAAyB,KAAKrF,KAAL,CAAWkD,QAApC,CAAP;AACD;AAJA,GAL0B,EAU1B;AACDzC,IAAAA,GAAG,EAAE,QADJ;AAEDoJ,IAAAA,GAAG,EAAE,SAASA,GAAT,GAAe;AAClB,aAAOtH,eAAe,CAAC,KAAKvC,KAAL,CAAW8J,QAAZ,CAAf,IAAwCvH,eAAe,CAACwH,UAA/D;AACD;AAJA,GAV0B,CAAjB,CAAZ;;AAiBA,SAAOrF,cAAP;AACD,CA5WsC,CA4WrCxC,KAAK,CAAC8H,SA5W+B,CAAjB,EA4WFnJ,MAAM,CAAC2B,IAAP,GAAcA,IA5WZ,EA4WkB3B,MAAM,CAACoJ,YAAP,GAAsB;AAC5DZ,EAAAA,KAAK,EAAE,CADqD;AAE5DzB,EAAAA,QAAQ,EAAE,KAFkD;AAG5D/C,EAAAA,UAAU,EAAE,EAHgD;AAI5DW,EAAAA,UAAU,EAAE,SAASA,UAAT,GAAsB,CAAE,CAJwB;AAK5DsE,EAAAA,QAAQ,EAAE;AALkD,CA5WxC,EAkXnBhJ,KAlXe,CAAlB;AAmXA,SAAS4D,cAAc,IAAIwF,OAA3B;AACAxF,cAAc,CAACyF,SAAf,GAA2BlG,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAAzB,GAAwC;AACjEjB,EAAAA,QAAQ,EAAEd,SAAS,CAACgI,OAAV,CAAkBC,UADqC;AAEjEhB,EAAAA,KAAK,EAAEjH,SAAS,CAACkI,MAFgD;AAGjE1C,EAAAA,QAAQ,EAAExF,SAAS,CAACmI,SAAV,CAAoB,CAACnI,SAAS,CAACgI,OAAX,EAAoBhI,SAAS,CAACY,MAA9B,EAAsCZ,SAAS,CAACoI,IAAhD,CAApB,CAHuD;AAIjE3F,EAAAA,UAAU,EAAEzC,SAAS,CAACmI,SAAV,CAAoB,CAACnI,SAAS,CAACY,MAAX,EAAmBZ,SAAS,CAACkI,MAA7B,CAApB,CAJqD;AAKjE9E,EAAAA,UAAU,EAAEpD,SAAS,CAACoI,IAL2C;AAMjE;AACAC,EAAAA,eAAe,EAAE,SAASA,eAAT,CAAyBzK,KAAzB,EAAgC0K,QAAhC,EAA0CC,aAA1C,EAAyD;AACxE,QAAI3K,KAAK,CAAC0K,QAAD,CAAT,EAAqB;AACnB,aAAO,IAAIE,KAAJ,CAAUD,aAAa,GAAG,2EAA1B,CAAP;AACD;AACF,GAXgE;AAYjEb,EAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkB9J,KAAlB,EAAyB0K,QAAzB,EAAmCC,aAAnC,EAAkD;AAC1D,QAAIE,aAAa,GAAG7K,KAAK,CAAC0K,QAAD,CAAzB;;AAEA,QAAI,OAAOG,aAAP,KAAyB,WAA7B,EAA0C;AACxC,UAAI,CAACtI,eAAe,CAACsI,aAAD,CAApB,EAAqC;AACnC;AACA,eAAO,IAAID,KAAJ,CAAUD,aAAa,GAAG,4CAAhB,GAA+DE,aAA/D,GAA+E,iDAAzF,CAAP;AACA;AACD;AACF;AACF;AAtBgE,CAAxC,GAuBvB,EAvBJ","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _class, _temp;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nimport React from 'react';\nimport memoizeOne from 'memoize-one';\nimport PropTypes from 'prop-types';\nimport getLineHeight from 'line-height';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport TOKENIZE_POLICY from './tokenize-rules';\nimport { Atom, isAtomComponent, ATOM_STRING_ID } from './atom';\n\nvar SPLIT = {\n  LEFT: true,\n  RIGHT: false\n};\n\nvar toString = function toString(node) {\n  var string = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!node) {\n    return string;\n  } else if (typeof node === 'string') {\n    return string + node;\n  } else if (isAtomComponent(node)) {\n    return string + ATOM_STRING_ID;\n  }\n  var children = Array.isArray(node) ? node : node.props.children || '';\n\n  return string + React.Children.map(children, function (child) {\n    return toString(child);\n  }).join('');\n};\n\nvar cloneWithChildren = function cloneWithChildren(node, children, isRootEl, level) {\n  var getDisplayStyle = function getDisplayStyle() {\n    if (isRootEl) {\n      return {\n        // root element cannot be an inline element because of the line calculation\n        display: (node.props.style || {}).display || 'block'\n      };\n    } else if (level === 2) {\n      return {\n        // level 2 elements (direct children of the root element) need to be inline because of the ellipsis.\n        // if level 2 element was a block element, ellipsis would get rendered on a new line, breaking the max number of lines\n        display: (node.props.style || {}).display || 'inline-block'\n      };\n    } else return {};\n  };\n\n  return _extends({}, node, {\n    props: _extends({}, node.props, {\n      style: _extends({}, node.props.style, getDisplayStyle()),\n      children: children\n    })\n  });\n};\n\nvar validateTree = function validateTree(node) {\n  if (typeof node === 'string' || isAtomComponent(node)) {\n    return true;\n  } else if (typeof node.type === 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      /* eslint-disable no-console */\n      console.error('ReactTruncateMarkup tried to render <' + node.type.name + ' />, but truncating React components is not supported, the full content is rendered instead. Only DOM elements are supported. Alternatively, you can take advantage of the <TruncateMarkup.Atom /> component (see more in the docs https://github.com/parsable/react-truncate-markup/blob/master/README.md#truncatemarkupatom-).');\n      /* eslint-enable */\n    }\n\n    return false;\n  }\n\n  if (node.props.children) {\n    return React.Children.toArray(node.props.children).reduce(function (isValid, child) {\n      return isValid && validateTree(child);\n    }, true);\n  }\n\n  return true;\n};\n\nvar TruncateMarkup = (_temp = _class = function (_React$Component) {\n  _inherits(TruncateMarkup, _React$Component);\n\n  function TruncateMarkup(props) {\n    _classCallCheck(this, TruncateMarkup);\n\n    var _this = _possibleConstructorReturn(this, _React$Component.call(this, props));\n\n    _this.lineHeight = null;\n    _this.splitDirectionSeq = [];\n    _this.shouldTruncate = true;\n    _this.wasLastCharTested = false;\n    _this.endFound = false;\n    _this.latestThatFits = null;\n    _this.onTruncateCalled = false;\n    _this.toStringMemo = memoizeOne(toString);\n    _this.childrenWithRefMemo = memoizeOne(_this.childrenElementWithRef);\n    _this.validateTreeMemo = memoizeOne(validateTree);\n\n    _this.onTruncate = function (wasTruncated) {\n      if (!_this.onTruncateCalled) {\n        _this.onTruncateCalled = true;\n        _this.props.onTruncate(wasTruncated);\n      }\n    };\n\n    _this.handleResize = function (el, prevResizeObserver) {\n      // clean up previous observer\n      if (prevResizeObserver) {\n        prevResizeObserver.disconnect();\n      }\n\n      // unmounting or just unsetting the element to be replaced with a new one later\n      if (!el) return null;\n\n      /* Wrapper element resize handing */\n      var initialRender = true;\n      var resizeCallback = function resizeCallback() {\n        if (initialRender) {\n          // ResizeObserer cb is called on initial render too so we are skipping here\n          initialRender = false;\n        } else {\n          // wrapper element has been resized, recalculating with the original text\n          _this.shouldTruncate = false;\n          _this.latestThatFits = null;\n\n          _this.setState({\n            text: _this.origText\n          }, function () {\n            _this.shouldTruncate = true;\n            _this.onTruncateCalled = false;\n            _this.truncate();\n          });\n        }\n      };\n\n      var resizeObserver = prevResizeObserver || new ResizeObserver(resizeCallback);\n\n      resizeObserver.observe(el);\n\n      return resizeObserver;\n    };\n\n    _this.setRef = function (el) {\n      var isNewEl = _this.el !== el;\n      _this.el = el;\n\n      // whenever we obtain a new element, attach resize handler\n      if (isNewEl) {\n        _this.resizeObserver = _this.handleResize(el, _this.resizeObserver);\n      }\n    };\n\n    _this.state = {\n      text: _this.childrenWithRefMemo(_this.props.children)\n    };\n    return _this;\n  }\n\n  TruncateMarkup.prototype.componentDidMount = function componentDidMount() {\n    if (!this.isValid) {\n      return;\n    }\n\n    // get the computed line-height of the parent element\n    // it'll be used for determining whether the text fits the container or not\n    this.lineHeight = this.props.lineHeight || getLineHeight(this.el);\n    this.truncate();\n  };\n\n  TruncateMarkup.prototype.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(nextProps) {\n    var _this2 = this;\n\n    this.shouldTruncate = false;\n    this.latestThatFits = null;\n\n    this.setState({\n      text: this.childrenWithRefMemo(nextProps.children)\n    }, function () {\n      if (!_this2.isValid) {\n        return;\n      }\n\n      _this2.lineHeight = nextProps.lineHeight || getLineHeight(_this2.el);\n      _this2.shouldTruncate = true;\n      _this2.truncate();\n    });\n  };\n\n  TruncateMarkup.prototype.componentDidUpdate = function componentDidUpdate() {\n    if (this.shouldTruncate === false || this.isValid === false) {\n      return;\n    }\n\n    if (this.endFound) {\n      // we've found the end where we cannot split the text further\n      // that means we've already found the max subtree that fits the container\n      // so we are rendering that\n      if (this.latestThatFits !== null && this.state.text !== this.latestThatFits) {\n        /* eslint-disable react/no-did-update-set-state */\n        this.setState({\n          text: this.latestThatFits\n        });\n\n        return;\n        /* eslint-enable */\n      }\n\n      this.onTruncate( /* wasTruncated */true);\n\n      return;\n    }\n\n    if (this.splitDirectionSeq.length) {\n      if (this.fits()) {\n        this.latestThatFits = this.state.text;\n        // we've found a subtree that fits the container\n        // but we need to check if we didn't cut too much of it off\n        // so we are changing the last splitting decision from splitting and going left\n        // to splitting and going right\n        this.splitDirectionSeq.splice(this.splitDirectionSeq.length - 1, 1, SPLIT.RIGHT, SPLIT.LEFT);\n      } else {\n        this.splitDirectionSeq.push(SPLIT.LEFT);\n      }\n\n      this.tryToFit(this.origText, this.splitDirectionSeq);\n    }\n  };\n\n  TruncateMarkup.prototype.componentWillUnmount = function componentWillUnmount() {\n    this.lineHeight = null;\n    this.latestThatFits = null;\n    this.splitDirectionSeq = [];\n  };\n\n  TruncateMarkup.prototype.truncate = function truncate() {\n    if (this.fits()) {\n      // the whole text fits on the first try, no need to do anything else\n      this.shouldTruncate = false;\n      this.onTruncate( /* wasTruncated */false);\n\n      return;\n    }\n\n    this.truncateOriginalText();\n  };\n\n  TruncateMarkup.prototype.childrenElementWithRef = function childrenElementWithRef(children) {\n    var child = React.Children.only(children);\n\n    return React.cloneElement(child, {\n      ref: this.setRef,\n      style: _extends({\n        wordWrap: 'break-word'\n      }, child.props.style)\n    });\n  };\n\n  TruncateMarkup.prototype.truncateOriginalText = function truncateOriginalText() {\n    this.endFound = false;\n    this.splitDirectionSeq = [SPLIT.LEFT];\n    this.wasLastCharTested = false;\n\n    this.tryToFit(this.origText, this.splitDirectionSeq);\n  };\n\n  /**\n   * Splits rootEl based on instructions and updates React's state with the returned element\n   * After React rerenders the new text, we'll check if the new text fits in componentDidUpdate\n   * @param  {ReactElement} rootEl - the original children element\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   */\n\n\n  TruncateMarkup.prototype.tryToFit = function tryToFit(rootEl, splitDirections) {\n    if (!rootEl.props.children) {\n      // no markup in container\n      return;\n    }\n\n    var newRootEl = this.split(rootEl, splitDirections, /* isRootEl */true);\n\n    var ellipsis = typeof this.props.ellipsis === 'function' ? this.props.ellipsis(newRootEl) : this.props.ellipsis;\n\n    ellipsis = (typeof ellipsis === 'undefined' ? 'undefined' : _typeof(ellipsis)) === 'object' ? React.cloneElement(ellipsis, { key: 'ellipsis' }) : ellipsis;\n\n    var newChildren = newRootEl.props.children;\n    var newChildrenWithEllipsis = [].concat(newChildren, ellipsis);\n\n    // edge case tradeoff EC#1 - on initial render it doesn't fit in the requested number of lines (1) so it starts truncating\n    // - because of truncating and the ellipsis position, div#lvl2 will have display set to 'inline-block',\n    //   causing the whole body to fit in 1 line again\n    // - if that happens, ellipsis is not needed anymore as the whole body is rendered\n    // - NOTE this could be fixed by checking for this exact case and handling it separately so it renders <div>foo {ellipsis}</div>\n    //\n    // Example:\n    // <TruncateMarkup lines={1}>\n    //   <div>\n    //     foo\n    //     <div id=\"lvl2\">bar</div>\n    //   </div>\n    // </TruncateMarkup>\n    var shouldRenderEllipsis = toString(newChildren) !== this.toStringMemo(this.props.children);\n\n    this.setState({\n      text: _extends({}, newRootEl, {\n        props: _extends({}, newRootEl.props, {\n          children: shouldRenderEllipsis ? newChildrenWithEllipsis : newChildren\n        })\n      })\n    });\n  };\n\n  /**\n   * Splits JSX node based on its type\n   * @param  {null|string|Array|Object} node - JSX node\n   * @param  {Array} splitDirections - list of SPLIT.RIGHT/LEFT instructions\n   * @return {null|string|Array|Object} - split JSX node\n   */\n\n\n  TruncateMarkup.prototype.split = function split(node, splitDirections) {\n    var isRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var level = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n    if (!node || isAtomComponent(node)) {\n      this.endFound = true;\n\n      return node;\n    } else if (typeof node === 'string') {\n      return this.splitString(node, splitDirections, level);\n    } else if (Array.isArray(node)) {\n      return this.splitArray(node, splitDirections, level);\n    }\n\n    var newChildren = this.split(node.props.children, splitDirections,\n    /* isRoot */false, level + 1);\n\n    return cloneWithChildren(node, newChildren, isRoot, level);\n  };\n\n  TruncateMarkup.prototype.splitString = function splitString(string) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return string;\n    }\n\n    if (splitDirections.length && this.policy.isAtomic(string)) {\n      // allow for an extra render test with the current character included\n      // in most cases this variation was already tested, but some edge cases require this check\n      // NOTE could be removed once EC#1 is taken care of\n      if (!this.wasLastCharTested) {\n        this.wasLastCharTested = true;\n      } else {\n        // we are trying to split further but we have nowhere to go now\n        // that means we've already found the max subtree that fits the container\n        this.endFound = true;\n      }\n\n      return string;\n    }\n\n    if (this.policy.tokenizeString) {\n      var wordsArray = this.splitArray(this.policy.tokenizeString(string), splitDirections, level);\n\n      // in order to preserve the input structure\n      return wordsArray.join('');\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(string.length / 2);\n    var beforeString = string.substring(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitString(beforeString, restSplitDirections, level);\n    }\n    var afterString = string.substring(pivotIndex);\n\n    return beforeString + this.splitString(afterString, restSplitDirections, level);\n  };\n\n  TruncateMarkup.prototype.splitArray = function splitArray(array) {\n    var splitDirections = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var level = arguments[2];\n\n    if (!splitDirections.length) {\n      return array;\n    }\n\n    if (array.length === 1) {\n      return [this.split(array[0], splitDirections, /* isRoot */false, level)];\n    }\n\n    var splitDirection = splitDirections[0],\n        restSplitDirections = splitDirections.slice(1);\n\n    var pivotIndex = Math.ceil(array.length / 2);\n    var beforeArray = array.slice(0, pivotIndex);\n\n    if (splitDirection === SPLIT.LEFT) {\n      return this.splitArray(beforeArray, restSplitDirections, level);\n    }\n    var afterArray = array.slice(pivotIndex);\n\n    return beforeArray.concat(this.splitArray(afterArray, restSplitDirections, level));\n  };\n\n  TruncateMarkup.prototype.fits = function fits() {\n    var maxLines = this.props.lines;\n\n    var _el$getBoundingClient = this.el.getBoundingClientRect(),\n        height = _el$getBoundingClient.height;\n\n    var computedLines = Math.round(height / parseFloat(this.lineHeight));\n\n    return maxLines >= computedLines;\n  };\n\n  TruncateMarkup.prototype.render = function render() {\n    return this.state.text;\n  };\n\n  _createClass(TruncateMarkup, [{\n    key: 'isValid',\n    get: function get() {\n      return this.validateTreeMemo(this.props.children);\n    }\n  }, {\n    key: 'origText',\n    get: function get() {\n      return this.childrenWithRefMemo(this.props.children);\n    }\n  }, {\n    key: 'policy',\n    get: function get() {\n      return TOKENIZE_POLICY[this.props.tokenize] || TOKENIZE_POLICY.characters;\n    }\n  }]);\n\n  return TruncateMarkup;\n}(React.Component), _class.Atom = Atom, _class.defaultProps = {\n  lines: 1,\n  ellipsis: '...',\n  lineHeight: '',\n  onTruncate: function onTruncate() {},\n  tokenize: 'characters'\n}, _temp);\nexport { TruncateMarkup as default };\nTruncateMarkup.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  children: PropTypes.element.isRequired,\n  lines: PropTypes.number,\n  ellipsis: PropTypes.oneOfType([PropTypes.element, PropTypes.string, PropTypes.func]),\n  lineHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  onTruncate: PropTypes.func,\n  // eslint-disable-next-line\n  onAfterTruncate: function onAfterTruncate(props, propName, componentName) {\n    if (props[propName]) {\n      return new Error(componentName + ': Setting `onAfterTruncate` prop is deprecated, use `onTruncate` instead.');\n    }\n  },\n  tokenize: function tokenize(props, propName, componentName) {\n    var tokenizeValue = props[propName];\n\n    if (typeof tokenizeValue !== 'undefined') {\n      if (!TOKENIZE_POLICY[tokenizeValue]) {\n        /* eslint-disable no-console */\n        return new Error(componentName + ': Unknown option for prop \\'tokenize\\': \\'' + tokenizeValue + '\\'. Option \\'characters\\' will be used instead.');\n        /* eslint-enable */\n      }\n    }\n  }\n} : {};"]},"metadata":{},"sourceType":"module"}
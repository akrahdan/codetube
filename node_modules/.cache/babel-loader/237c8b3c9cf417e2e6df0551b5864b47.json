{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { get, identity, isFunction, isObject, isString, merge } from 'lodash';\nimport { getStaticCss } from './utils/getStaticProperties';\nimport { orderPropNames } from './utils/propNames';\nimport { arrayParser, isMediaArray, isMediaMap, objectParser, orderBreakpoints, parseBreakpoints } from './utils/responsive';\nexport var variance = {\n  // Parser to handle any set of configured props\n  createParser: function createParser(config) {\n    var propNames = orderPropNames(config);\n    var breakpoints;\n\n    var parser = function parser(props) {\n      var styles = {};\n      var theme = props.theme; // Attempt to cache the breakpoints if we have not yet or if theme has become available.\n\n      if (breakpoints === undefined || breakpoints === null && theme !== null && theme !== void 0 && theme.breakpoints) {\n        // Save the breakpoints if we can\n        breakpoints = parseBreakpoints(theme === null || theme === void 0 ? void 0 : theme.breakpoints);\n      } // Loops over all prop names on the configured config to check for configured styles\n\n\n      propNames.forEach(function (prop) {\n        var property = config[prop];\n        var value = get(props, prop);\n\n        switch (_typeof(value)) {\n          case 'string':\n          case 'number':\n            return Object.assign(styles, property.styleFn(value, prop, props));\n          // handle any props configured with the responsive notation\n\n          case 'object':\n            if (!breakpoints) {\n              return;\n            } // If it is an array the order of values is smallest to largest: [_, xs, ...]\n\n\n            if (isMediaArray(value)) {\n              return merge(styles, arrayParser(value, props, property, breakpoints.array));\n            } // Check to see if value is an object matching the responsive syntax and generate the styles.\n\n\n            if (isMediaMap(value)) {\n              return merge(styles, objectParser(value, props, property, breakpoints.map));\n            }\n\n        }\n      });\n      return breakpoints ? orderBreakpoints(styles, breakpoints.array) : styles;\n    }; // return the parser function with the resulting meta information for further composition\n\n\n    return Object.assign(parser, {\n      propNames: propNames,\n      config: config\n    });\n  },\n  // Given a single property configuration enrich the config with a transform function\n  // that traverses the properties the function is responsible for.\n  createTransform: function createTransform(prop, config) {\n    var _config$transform = config.transform,\n        transform = _config$transform === void 0 ? identity : _config$transform,\n        property = config.property,\n        _config$properties = config.properties,\n        properties = _config$properties === void 0 ? [property] : _config$properties,\n        scale = config.scale;\n    return _objectSpread(_objectSpread({}, config), {}, {\n      prop: prop,\n      styleFn: function styleFn(value, prop, props) {\n        var styles = {};\n        var useTransform = false;\n        var usedValue;\n        var scaleVal;\n\n        if (isFunction(value)) {\n          usedValue = value(props.theme);\n        } else {\n          var _scaleVal;\n\n          if (isString(scale)) scaleVal = get(props, \"theme.\".concat(scale, \".\").concat(value));\n          if (isObject(scale)) scaleVal = get(scale, \"\".concat(value));\n          useTransform = scaleVal !== undefined || scale === undefined;\n          usedValue = (_scaleVal = scaleVal) !== null && _scaleVal !== void 0 ? _scaleVal : value;\n        } // for each property look up the scale value from theme if passed and apply any\n        // final transforms to the value\n\n\n        properties.forEach(function (property) {\n          var finalValue = useTransform ? transform(usedValue, property, props) : usedValue;\n\n          if (isObject(finalValue)) {\n            Object.assign(styles, finalValue);\n          } else {\n            Object.assign(styles, _defineProperty({}, property, finalValue));\n          }\n        }); // return the resulting styles object\n\n        return styles;\n      }\n    });\n  },\n  compose: function compose() {\n    for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {\n      parsers[_key] = arguments[_key];\n    }\n\n    return this.createParser(parsers.reduce(function (carry, parser) {\n      return _objectSpread(_objectSpread({}, carry), parser.config);\n    }, {}));\n  },\n  createCss: function createCss(config) {\n    var parser = this.create(config);\n    var filteredProps = parser.propNames;\n    return function (cssProps) {\n      var cache;\n      var allKeys = Object.keys(cssProps);\n      /** Any key of the CSSProps that is not a System Prop or a Static CSS Property is treated as a nested selector */\n\n      var selectors = allKeys.filter(function (key) {\n        return !filteredProps.includes(key) && isObject(cssProps[key]);\n      });\n      /** Static CSS Properties get extracted if they match neither syntax */\n\n      var staticCss = getStaticCss(cssProps, ['theme'].concat(_toConsumableArray(selectors), _toConsumableArray(filteredProps)));\n      return function (_ref) {\n        var theme = _ref.theme;\n        if (cache) return cache;\n        var css = parser(_objectSpread(_objectSpread({}, cssProps), {}, {\n          theme: theme\n        }));\n        selectors.forEach(function (selector) {\n          var _cssProps$selector;\n\n          var selectorConfig = (_cssProps$selector = cssProps[selector]) !== null && _cssProps$selector !== void 0 ? _cssProps$selector : {};\n          css[selector] = _objectSpread(_objectSpread({}, getStaticCss(selectorConfig, filteredProps)), parser(_objectSpread(_objectSpread({}, selectorConfig), {}, {\n            theme: theme\n          })));\n        });\n        /** Merge the static and generated css and save it to the cache */\n\n        cache = _objectSpread(_objectSpread({}, staticCss), css);\n        return cache;\n      };\n    };\n  },\n  createVariant: function createVariant(config) {\n    var css = this.createCss(config);\n    return function (_ref2) {\n      var _ref2$prop = _ref2.prop,\n          prop = _ref2$prop === void 0 ? 'variant' : _ref2$prop,\n          defaultVariant = _ref2.defaultVariant,\n          _ref2$base = _ref2.base,\n          base = _ref2$base === void 0 ? {} : _ref2$base,\n          variants = _ref2.variants;\n      var baseFn = css(base);\n      var variantFns = {};\n      Object.keys(variants).forEach(function (key) {\n        var variantKey = key;\n        var cssProps = variants[variantKey];\n        variantFns[variantKey] = css(cssProps);\n      });\n      return function (props) {\n        var _variantFns;\n\n        var _props$prop = props[prop],\n            selected = _props$prop === void 0 ? defaultVariant : _props$prop;\n        var styles = {};\n        if (!selected) return styles;\n        return merge(styles, baseFn(props), variantFns === null || variantFns === void 0 ? void 0 : (_variantFns = variantFns[selected]) === null || _variantFns === void 0 ? void 0 : _variantFns.call(variantFns, props));\n      };\n    };\n  },\n  createStates: function createStates(config) {\n    var css = this.createCss(config);\n    return function (states) {\n      var orderedStates = Object.keys(states);\n      var stateFns = {};\n      orderedStates.forEach(function (key) {\n        var stateKey = key;\n        var cssProps = states[stateKey];\n        stateFns[stateKey] = css(cssProps);\n      });\n      return function (props) {\n        var styles = {};\n        orderedStates.forEach(function (state) {\n          merge(styles, props[state] && stateFns[state](props));\n        });\n        return styles;\n      };\n    };\n  },\n  create: function create(config) {\n    var transforms = {}; // Create a transform function for each of the props\n\n    for (var prop in config) {\n      if (typeof prop === 'string') {\n        transforms[prop] = this.createTransform(prop, config[prop]);\n      }\n    } // Create a parser that handles all the props within the config\n\n\n    return this.createParser(transforms);\n  }\n};","map":{"version":3,"sources":["/Users/akrah/Documents/dev/codefluent/node_modules/@codecademy/variance/dist/core.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","o","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","Array","from","test","iter","Symbol","iterator","isArray","len","length","i","arr2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","_typeof","get","identity","isFunction","isObject","isString","merge","getStaticCss","orderPropNames","arrayParser","isMediaArray","isMediaMap","objectParser","orderBreakpoints","parseBreakpoints","variance","createParser","config","propNames","breakpoints","parser","props","styles","theme","undefined","prop","property","assign","styleFn","array","map","createTransform","_config$transform","transform","_config$properties","properties","scale","useTransform","usedValue","scaleVal","_scaleVal","concat","finalValue","compose","_len","parsers","_key","reduce","carry","createCss","create","filteredProps","cssProps","cache","allKeys","selectors","includes","staticCss","_ref","css","selector","_cssProps$selector","selectorConfig","createVariant","_ref2","_ref2$prop","defaultVariant","_ref2$base","base","variants","baseFn","variantFns","variantKey","_variantFns","_props$prop","selected","createStates","states","orderedStates","stateFns","stateKey","state","transforms"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { get, identity, isFunction, isObject, isString, merge } from 'lodash';\nimport { getStaticCss } from './utils/getStaticProperties';\nimport { orderPropNames } from './utils/propNames';\nimport { arrayParser, isMediaArray, isMediaMap, objectParser, orderBreakpoints, parseBreakpoints } from './utils/responsive';\nexport var variance = {\n  // Parser to handle any set of configured props\n  createParser: function createParser(config) {\n    var propNames = orderPropNames(config);\n    var breakpoints;\n\n    var parser = function parser(props) {\n      var styles = {};\n      var theme = props.theme; // Attempt to cache the breakpoints if we have not yet or if theme has become available.\n\n      if (breakpoints === undefined || breakpoints === null && theme !== null && theme !== void 0 && theme.breakpoints) {\n        // Save the breakpoints if we can\n        breakpoints = parseBreakpoints(theme === null || theme === void 0 ? void 0 : theme.breakpoints);\n      } // Loops over all prop names on the configured config to check for configured styles\n\n\n      propNames.forEach(function (prop) {\n        var property = config[prop];\n        var value = get(props, prop);\n\n        switch (_typeof(value)) {\n          case 'string':\n          case 'number':\n            return Object.assign(styles, property.styleFn(value, prop, props));\n          // handle any props configured with the responsive notation\n\n          case 'object':\n            if (!breakpoints) {\n              return;\n            } // If it is an array the order of values is smallest to largest: [_, xs, ...]\n\n\n            if (isMediaArray(value)) {\n              return merge(styles, arrayParser(value, props, property, breakpoints.array));\n            } // Check to see if value is an object matching the responsive syntax and generate the styles.\n\n\n            if (isMediaMap(value)) {\n              return merge(styles, objectParser(value, props, property, breakpoints.map));\n            }\n\n        }\n      });\n      return breakpoints ? orderBreakpoints(styles, breakpoints.array) : styles;\n    }; // return the parser function with the resulting meta information for further composition\n\n\n    return Object.assign(parser, {\n      propNames: propNames,\n      config: config\n    });\n  },\n  // Given a single property configuration enrich the config with a transform function\n  // that traverses the properties the function is responsible for.\n  createTransform: function createTransform(prop, config) {\n    var _config$transform = config.transform,\n        transform = _config$transform === void 0 ? identity : _config$transform,\n        property = config.property,\n        _config$properties = config.properties,\n        properties = _config$properties === void 0 ? [property] : _config$properties,\n        scale = config.scale;\n    return _objectSpread(_objectSpread({}, config), {}, {\n      prop: prop,\n      styleFn: function styleFn(value, prop, props) {\n        var styles = {};\n        var useTransform = false;\n        var usedValue;\n        var scaleVal;\n\n        if (isFunction(value)) {\n          usedValue = value(props.theme);\n        } else {\n          var _scaleVal;\n\n          if (isString(scale)) scaleVal = get(props, \"theme.\".concat(scale, \".\").concat(value));\n          if (isObject(scale)) scaleVal = get(scale, \"\".concat(value));\n          useTransform = scaleVal !== undefined || scale === undefined;\n          usedValue = (_scaleVal = scaleVal) !== null && _scaleVal !== void 0 ? _scaleVal : value;\n        } // for each property look up the scale value from theme if passed and apply any\n        // final transforms to the value\n\n\n        properties.forEach(function (property) {\n          var finalValue = useTransform ? transform(usedValue, property, props) : usedValue;\n\n          if (isObject(finalValue)) {\n            Object.assign(styles, finalValue);\n          } else {\n            Object.assign(styles, _defineProperty({}, property, finalValue));\n          }\n        }); // return the resulting styles object\n\n        return styles;\n      }\n    });\n  },\n  compose: function compose() {\n    for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {\n      parsers[_key] = arguments[_key];\n    }\n\n    return this.createParser(parsers.reduce(function (carry, parser) {\n      return _objectSpread(_objectSpread({}, carry), parser.config);\n    }, {}));\n  },\n  createCss: function createCss(config) {\n    var parser = this.create(config);\n    var filteredProps = parser.propNames;\n    return function (cssProps) {\n      var cache;\n      var allKeys = Object.keys(cssProps);\n      /** Any key of the CSSProps that is not a System Prop or a Static CSS Property is treated as a nested selector */\n\n      var selectors = allKeys.filter(function (key) {\n        return !filteredProps.includes(key) && isObject(cssProps[key]);\n      });\n      /** Static CSS Properties get extracted if they match neither syntax */\n\n      var staticCss = getStaticCss(cssProps, ['theme'].concat(_toConsumableArray(selectors), _toConsumableArray(filteredProps)));\n      return function (_ref) {\n        var theme = _ref.theme;\n        if (cache) return cache;\n        var css = parser(_objectSpread(_objectSpread({}, cssProps), {}, {\n          theme: theme\n        }));\n        selectors.forEach(function (selector) {\n          var _cssProps$selector;\n\n          var selectorConfig = (_cssProps$selector = cssProps[selector]) !== null && _cssProps$selector !== void 0 ? _cssProps$selector : {};\n          css[selector] = _objectSpread(_objectSpread({}, getStaticCss(selectorConfig, filteredProps)), parser(_objectSpread(_objectSpread({}, selectorConfig), {}, {\n            theme: theme\n          })));\n        });\n        /** Merge the static and generated css and save it to the cache */\n\n        cache = _objectSpread(_objectSpread({}, staticCss), css);\n        return cache;\n      };\n    };\n  },\n  createVariant: function createVariant(config) {\n    var css = this.createCss(config);\n    return function (_ref2) {\n      var _ref2$prop = _ref2.prop,\n          prop = _ref2$prop === void 0 ? 'variant' : _ref2$prop,\n          defaultVariant = _ref2.defaultVariant,\n          _ref2$base = _ref2.base,\n          base = _ref2$base === void 0 ? {} : _ref2$base,\n          variants = _ref2.variants;\n      var baseFn = css(base);\n      var variantFns = {};\n      Object.keys(variants).forEach(function (key) {\n        var variantKey = key;\n        var cssProps = variants[variantKey];\n        variantFns[variantKey] = css(cssProps);\n      });\n      return function (props) {\n        var _variantFns;\n\n        var _props$prop = props[prop],\n            selected = _props$prop === void 0 ? defaultVariant : _props$prop;\n        var styles = {};\n        if (!selected) return styles;\n        return merge(styles, baseFn(props), variantFns === null || variantFns === void 0 ? void 0 : (_variantFns = variantFns[selected]) === null || _variantFns === void 0 ? void 0 : _variantFns.call(variantFns, props));\n      };\n    };\n  },\n  createStates: function createStates(config) {\n    var css = this.createCss(config);\n    return function (states) {\n      var orderedStates = Object.keys(states);\n      var stateFns = {};\n      orderedStates.forEach(function (key) {\n        var stateKey = key;\n        var cssProps = states[stateKey];\n        stateFns[stateKey] = css(cssProps);\n      });\n      return function (props) {\n        var styles = {};\n        orderedStates.forEach(function (state) {\n          merge(styles, props[state] && stateFns[state](props));\n        });\n        return styles;\n      };\n    };\n  },\n  create: function create(config) {\n    var transforms = {}; // Create a transform function for each of the props\n\n    for (var prop in config) {\n      if (typeof prop === 'string') {\n        transforms[prop] = this.createTransform(prop, config[prop]);\n      }\n    } // Create a parser that handles all the props within the config\n\n\n    return this.createParser(transforms);\n  }\n};"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"const getClusterInterval = (duration, clusterIntervalPercentage = 2) => {\n  return Math.max(clusterIntervalPercentage / 100 * duration);\n};\n\nconst getClusterIntervalWithLayoutOffset = (duration, layout) => {\n  if (layout === '240p') return getClusterInterval(duration, 10);\n  if (layout === '360p') return getClusterInterval(duration, 8);\n  if (layout === '480p') return getClusterInterval(duration, 6);\n  if (layout === '720p') return getClusterInterval(duration, 4);\n  return getClusterInterval(duration, 2);\n};\n\nconst cluster = (markers, clusterInterval = 5) => {\n  if (!markers.length) return [];\n  const clusters = [{\n    timeIndex: markers[0].timeIndex,\n    markers: []\n  }];\n  let cluster = clusters[0];\n\n  for (let i = 0; i < markers.length; i++) {\n    const marker = markers[i];\n\n    if (marker.timeIndex <= cluster.timeIndex + clusterInterval) {\n      cluster.markers.push(marker);\n    } else {\n      cluster = {\n        timeIndex: marker.timeIndex,\n        markers: [marker]\n      };\n      clusters.push(cluster);\n    }\n  }\n\n  return clusters;\n};\n\nconst clusterMarkers = (markers, duration, layout) => {\n  if (!markers.length) return [];\n  const sorted = markers.sort((a, b) => a.timeIndex - b.timeIndex);\n  const clusterInterval = getClusterIntervalWithLayoutOffset(duration, layout);\n  return cluster(sorted, clusterInterval);\n};\n\nmodule.exports = {\n  cluster,\n  getClusterInterval,\n  clusterMarkers\n};","map":{"version":3,"sources":["/Users/akrah/Documents/dev/readux/src/codefluent/src/portal/scenes/CoursePlayer/marker/marker-clustering.js"],"names":["getClusterInterval","duration","clusterIntervalPercentage","Math","max","getClusterIntervalWithLayoutOffset","layout","cluster","markers","clusterInterval","length","clusters","timeIndex","i","marker","push","clusterMarkers","sorted","sort","a","b","module","exports"],"mappings":"AAAA,MAAMA,kBAAkB,GAAG,CAACC,QAAD,EAAWC,yBAAyB,GAAG,CAAvC,KAA6C;AACpE,SAAOC,IAAI,CAACC,GAAL,CAAUF,yBAAyB,GAAG,GAA7B,GAAoCD,QAA7C,CAAP;AACD,CAFH;;AAIE,MAAMI,kCAAkC,GAAG,CAACJ,QAAD,EAAWK,MAAX,KAAsB;AAC/D,MAAIA,MAAM,KAAK,MAAf,EAAuB,OAAON,kBAAkB,CAACC,QAAD,EAAW,EAAX,CAAzB;AACvB,MAAIK,MAAM,KAAK,MAAf,EAAuB,OAAON,kBAAkB,CAACC,QAAD,EAAW,CAAX,CAAzB;AACvB,MAAIK,MAAM,KAAK,MAAf,EAAuB,OAAON,kBAAkB,CAACC,QAAD,EAAW,CAAX,CAAzB;AACvB,MAAIK,MAAM,KAAK,MAAf,EAAuB,OAAON,kBAAkB,CAACC,QAAD,EAAW,CAAX,CAAzB;AACvB,SAAOD,kBAAkB,CAACC,QAAD,EAAW,CAAX,CAAzB;AACD,CAND;;AAQA,MAAMM,OAAO,GAAG,CAACC,OAAD,EAAUC,eAAe,GAAG,CAA5B,KAAkC;AAChD,MAAI,CAACD,OAAO,CAACE,MAAb,EAAqB,OAAO,EAAP;AAErB,QAAMC,QAAQ,GAAG,CAAC;AAAEC,IAAAA,SAAS,EAAEJ,OAAO,CAAC,CAAD,CAAP,CAAWI,SAAxB;AAAmCJ,IAAAA,OAAO,EAAE;AAA5C,GAAD,CAAjB;AACA,MAAID,OAAO,GAAGI,QAAQ,CAAC,CAAD,CAAtB;;AAEA,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,OAAO,CAACE,MAA5B,EAAoCG,CAAC,EAArC,EAAyC;AACvC,UAAMC,MAAM,GAAGN,OAAO,CAACK,CAAD,CAAtB;;AACA,QAAIC,MAAM,CAACF,SAAP,IAAoBL,OAAO,CAACK,SAAR,GAAoBH,eAA5C,EAA6D;AAC3DF,MAAAA,OAAO,CAACC,OAAR,CAAgBO,IAAhB,CAAqBD,MAArB;AACD,KAFD,MAEO;AACLP,MAAAA,OAAO,GAAG;AAAEK,QAAAA,SAAS,EAAEE,MAAM,CAACF,SAApB;AAA+BJ,QAAAA,OAAO,EAAE,CAACM,MAAD;AAAxC,OAAV;AACAH,MAAAA,QAAQ,CAACI,IAAT,CAAcR,OAAd;AACD;AACF;;AACD,SAAOI,QAAP;AACD,CAhBD;;AAkBA,MAAMK,cAAc,GAAG,CAACR,OAAD,EAAUP,QAAV,EAAoBK,MAApB,KAA+B;AACpD,MAAI,CAACE,OAAO,CAACE,MAAb,EAAqB,OAAO,EAAP;AAErB,QAAMO,MAAM,GAAGT,OAAO,CAACU,IAAR,CAAa,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACP,SAAF,GAAcQ,CAAC,CAACR,SAAvC,CAAf;AACA,QAAMH,eAAe,GAAGJ,kCAAkC,CAACJ,QAAD,EAAWK,MAAX,CAA1D;AACA,SAAOC,OAAO,CAACU,MAAD,EAASR,eAAT,CAAd;AACD,CAND;;AAQAY,MAAM,CAACC,OAAP,GAAiB;AACff,EAAAA,OADe;AAEfP,EAAAA,kBAFe;AAGfgB,EAAAA;AAHe,CAAjB","sourcesContent":["const getClusterInterval = (duration, clusterIntervalPercentage = 2) => {\n    return Math.max((clusterIntervalPercentage / 100) * duration)\n  }\n  \n  const getClusterIntervalWithLayoutOffset = (duration, layout) => {\n    if (layout === '240p') return getClusterInterval(duration, 10)\n    if (layout === '360p') return getClusterInterval(duration, 8)\n    if (layout === '480p') return getClusterInterval(duration, 6)\n    if (layout === '720p') return getClusterInterval(duration, 4)\n    return getClusterInterval(duration, 2)\n  }\n  \n  const cluster = (markers, clusterInterval = 5) => {\n    if (!markers.length) return []\n  \n    const clusters = [{ timeIndex: markers[0].timeIndex, markers: [] }]\n    let cluster = clusters[0]\n  \n    for (let i = 0; i < markers.length; i++) {\n      const marker = markers[i]\n      if (marker.timeIndex <= cluster.timeIndex + clusterInterval) {\n        cluster.markers.push(marker)\n      } else {\n        cluster = { timeIndex: marker.timeIndex, markers: [marker] }\n        clusters.push(cluster)\n      }\n    }\n    return clusters\n  }\n  \n  const clusterMarkers = (markers, duration, layout) => {\n    if (!markers.length) return []\n  \n    const sorted = markers.sort((a, b) => a.timeIndex - b.timeIndex)\n    const clusterInterval = getClusterIntervalWithLayoutOffset(duration, layout)\n    return cluster(sorted, clusterInterval)\n  }\n  \n  module.exports = {\n    cluster,\n    getClusterInterval,\n    clusterMarkers,\n  }\n  "]},"metadata":{},"sourceType":"module"}
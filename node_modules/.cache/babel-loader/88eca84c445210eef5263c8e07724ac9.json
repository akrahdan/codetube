{"ast":null,"code":"import _regeneratorRuntime from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _toConsumableArray from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty2 from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _createForOfIteratorHelper from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport isPlainObject from 'is-plain-object';\nimport { reverse } from 'esrever';\nimport { produce, createDraft, finishDraft, isDraft } from 'immer';\nimport isEqual from 'fast-deep-equal';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\n\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: function isInline() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    apply: function apply(op) {\n      var _iterator = _createForOfIteratorHelper(Editor.pathRefs(editor)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var ref = _step.value;\n          PathRef.transform(ref, op);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(Editor.pointRefs(editor)),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _ref = _step2.value;\n          PointRef.transform(_ref, op);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(Editor.rangeRefs(editor)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _ref2 = _step3.value;\n          RangeRef.transform(_ref2, op);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var set = new Set();\n      var dirtyPaths = [];\n\n      var add = function add(path) {\n        if (path) {\n          var key = path.join(',');\n\n          if (!set.has(key)) {\n            set.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var newDirtyPaths = getDirtyPaths(op);\n\n      var _iterator4 = _createForOfIteratorHelper(oldDirtyPaths),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var path = _step4.value;\n          var newPath = Path.transform(path, op);\n          add(newPath);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      var _iterator5 = _createForOfIteratorHelper(newDirtyPaths),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _path = _step5.value;\n          add(_path);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(function () {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: function addMark(key, value) {\n      var selection = editor.selection;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, _defineProperty2({}, key, value), {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread(_objectSpread({}, Editor.marks(editor) || {}), {}, _defineProperty2({}, key, value));\n\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n    deleteBackward: function deleteBackward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit: unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: function deleteForward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit: unit\n        });\n      }\n    },\n    deleteFragment: function deleteFragment(direction) {\n      var selection = editor.selection;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n          reverse: direction === 'backward'\n        });\n      }\n    },\n    getFragment: function getFragment() {\n      var selection = editor.selection;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: function insertBreak() {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: function insertFragment(fragment) {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: function insertNode(node) {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: function insertText(text) {\n      var selection = editor.selection,\n          marks = editor.marks;\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          var inline = Editor.above(editor, {\n            match: function match(n) {\n              return Editor.isInline(editor, n);\n            },\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var _inline = _slicedToArray(inline, 2),\n                inlinePath = _inline[1];\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n\n        if (marks) {\n          var node = _objectSpread({\n            text: text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: function normalizeNode(entry) {\n      var _entry = _slicedToArray(entry, 2),\n          node = _entry[0],\n          path = _entry[1]; // There are no core normalizations for text nodes.\n\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = node.children[i];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (isLast && _child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: function removeMark(key) {\n      var selection = editor.selection;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\n\nvar getDirtyPaths = function getDirtyPaths(op) {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var path = op.path;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var node = op.node,\n            _path2 = op.path;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref3) {\n          var _ref6 = _slicedToArray(_ref3, 2),\n              p = _ref6[1];\n\n          return _path2.concat(p);\n        });\n        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n      }\n\n    case 'merge_node':\n      {\n        var _path3 = op.path;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [].concat(_toConsumableArray(ancestors), [previousPath]);\n      }\n\n    case 'move_node':\n      {\n        var _path4 = op.path,\n            newPath = op.newPath;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        var _iterator6 = _createForOfIteratorHelper(Path.ancestors(_path4)),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var ancestor = _step6.value;\n            var p = Path.transform(ancestor, op);\n            oldAncestors.push(p);\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        var _iterator7 = _createForOfIteratorHelper(Path.ancestors(newPath)),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _ancestor = _step7.value;\n\n            var _p = Path.transform(_ancestor, op);\n\n            newAncestors.push(_p);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [].concat(oldAncestors, newAncestors, [resultPath]);\n      }\n\n    case 'remove_node':\n      {\n        var _path5 = op.path;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return _toConsumableArray(_ancestors);\n      }\n\n    case 'split_node':\n      {\n        var _path6 = op.path;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [].concat(_toConsumableArray(_levels), [nextPath]);\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\r\n * Constants for string distance checking.\r\n */\n\n\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\nvar ZERO_WIDTH_JOINER = 0x200d;\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\n\nvar getCharacterDistance = function getCharacterDistance(text) {\n  var offset = 0; // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n\n  var prev = null;\n  var charCode = text.charCodeAt(0);\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n\n      if (prev === 'SURR' || prev === 'BMP') {\n        break;\n      }\n\n      offset += 2;\n      prev = modifier ? 'MOD' : 'SURR';\n      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n\n      continue;\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1;\n      prev = 'ZWJ';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'BMP';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'VAR';\n      charCode = text.charCodeAt(offset);\n      continue;\n    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n\n\n    if (prev === 'MOD') {\n      offset += 1;\n      break;\n    } // If while loop ever gets here, we're done (e.g latin chars).\n\n\n    break;\n  }\n\n  return offset || 1;\n};\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\n\nvar getWordDistance = function getWordDistance(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char;\n\n  while (char = text.charAt(i)) {\n    var l = getCharacterDistance(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWordCharacter(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\n\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharacterDistance(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n\n    if (isWordCharacter(next, rest)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Determines if `code` is a surrogate\r\n */\n\n\nvar isSurrogate = function isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n};\n/**\r\n * Does `code` form Modifier with next one.\r\n *\r\n * https://emojipedia.org/modifiers/\r\n */\n\n\nvar isModifier = function isModifier(code, text, offset) {\n  if (code === 0xd83c) {\n    var next = text.charCodeAt(offset + 1);\n    return next <= 0xdfff && next >= 0xdffb;\n  }\n\n  return false;\n};\n/**\r\n * Is `code` a Variation Selector.\r\n *\r\n * https://codepoints.net/variation_selectors\r\n */\n\n\nvar isVariationSelector = function isVariationSelector(code) {\n  return code <= 0xfe0f && code >= 0xfe00;\n};\n/**\r\n * Is `code` one of the BMP codes used in emoji sequences.\r\n *\r\n * https://emojipedia.org/emoji-zwj-sequences/\r\n */\n\n\nvar isBMPEmoji = function isBMPEmoji(code) {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return code === 0x2764 || // heart (❤)\n  code === 0x2642 || // male (♂)\n  code === 0x2640 || // female (♀)\n  code === 0x2620 || // scull (☠)\n  code === 0x2695 || // medical (⚕)\n  code === 0x2708 || // plane (✈️)\n  code === 0x25ef // large circle (◯)\n  ;\n};\n\nvar Element = {\n  /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */\n  isAncestor: function isAncestor(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children);\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement: function isElement(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Element.isElement(val);\n    });\n  },\n\n  /**\r\n   * Check if a set of props is a partial of Element.\r\n   */\n  isElementProps: function isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar IS_EDITOR_CACHE = new WeakMap();\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above: function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids,\n        _options$mode = options.mode,\n        mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n        _options$at = options.at,\n        at = _options$at === void 0 ? editor.selection : _options$at,\n        match = options.match;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    var _iterator8 = _createForOfIteratorHelper(Editor.levels(editor, {\n      at: path,\n      voids: voids,\n      match: match,\n      reverse: reverse\n    })),\n        _step8;\n\n    try {\n      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n        var _step8$value = _slicedToArray(_step8.value, 2),\n            n = _step8$value[0],\n            p = _step8$value[1];\n\n        if (!Text.isText(n) && !Path.equals(path, p)) {\n          return [n, p];\n        }\n      }\n    } catch (err) {\n      _iterator8.e(err);\n    } finally {\n      _iterator8.f();\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark: function addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after: function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance;\n    var d = 0;\n    var target;\n\n    var _iterator9 = _createForOfIteratorHelper(Editor.positions(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {\n      at: range\n    }))),\n        _step9;\n\n    try {\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        var p = _step9.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before: function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance2 = options.distance,\n        distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n    var d = 0;\n    var target;\n\n    var _iterator10 = _createForOfIteratorHelper(Editor.positions(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {\n      at: range,\n      reverse: true\n    }))),\n        _step10;\n\n    try {\n      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n        var p = _step10.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator10.e(err);\n    } finally {\n      _iterator10.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward: function deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward: function deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit2 = options.unit,\n        unit = _options$unit2 === void 0 ? 'character' : _options$unit2;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment: function deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$direction = options.direction,\n        direction = _options$direction === void 0 ? 'forward' : _options$direction;\n    editor.deleteFragment(direction);\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges: function edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end: function end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first: function first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment: function fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks: function hasBlocks(editor, element) {\n    return element.children.some(function (n) {\n      return Editor.isBlock(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines: function hasInlines(editor, element) {\n    return element.children.some(function (n) {\n      return Text.isText(n) || Editor.isInline(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts: function hasTexts(editor, element) {\n    return element.children.every(function (n) {\n      return Text.isText(n);\n    });\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak: function insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode: function insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText: function insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock: function isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor: function isEditor(value) {\n    if (!isPlainObject(value)) return false;\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor;\n    }\n\n    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd: function isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge: function isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty: function isEmpty(editor, element) {\n    var children = element.children;\n\n    var _children = _slicedToArray(children, 1),\n        first = _children[0];\n\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline: function isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing: function isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart: function isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid: function isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last: function last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf: function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  levels: /*#__PURE__*/_regeneratorRuntime.mark(function levels(editor) {\n    var options,\n        _options$at2,\n        at,\n        _options$reverse,\n        reverse,\n        _options$voids2,\n        voids,\n        match,\n        levels,\n        path,\n        _iterator11,\n        _step11,\n        _step11$value,\n        n,\n        p,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function levels$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n            match = options.match;\n\n            if (match == null) {\n              match = function match() {\n                return true;\n              };\n            }\n\n            if (at) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 6:\n            levels = [];\n            path = Editor.path(editor, at);\n            _iterator11 = _createForOfIteratorHelper(Node.levels(editor, path));\n            _context.prev = 9;\n\n            _iterator11.s();\n\n          case 11:\n            if ((_step11 = _iterator11.n()).done) {\n              _context.next = 20;\n              break;\n            }\n\n            _step11$value = _slicedToArray(_step11.value, 2), n = _step11$value[0], p = _step11$value[1];\n\n            if (match(n, p)) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 18);\n\n          case 15:\n            levels.push([n, p]);\n\n            if (!(!voids && Editor.isVoid(editor, n))) {\n              _context.next = 18;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 20);\n\n          case 18:\n            _context.next = 11;\n            break;\n\n          case 20:\n            _context.next = 25;\n            break;\n\n          case 22:\n            _context.prev = 22;\n            _context.t0 = _context[\"catch\"](9);\n\n            _iterator11.e(_context.t0);\n\n          case 25:\n            _context.prev = 25;\n\n            _iterator11.f();\n\n            return _context.finish(25);\n\n          case 28:\n            if (reverse) {\n              levels.reverse();\n            }\n\n            return _context.delegateYield(levels, \"t1\", 30);\n\n          case 30:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, levels, null, [[9, 22, 25, 28]]);\n  }),\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks: function marks(editor) {\n    var marks = editor.marks,\n        selection = editor.selection;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var _Editor$nodes = Editor.nodes(editor, {\n        match: Text.isText\n      }),\n          _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n          match = _Editor$nodes2[0];\n\n      if (match) {\n        var _match = _slicedToArray(match, 1),\n            _node = _match[0];\n\n        var _rest = _objectWithoutProperties(_node, [\"text\"]);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var anchor = selection.anchor;\n    var path = anchor.path;\n\n    var _Editor$leaf = Editor.leaf(editor, path),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n        node = _Editor$leaf2[0];\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        }\n      });\n\n      if (prev && block) {\n        var _prev2 = _slicedToArray(prev, 2),\n            prevNode = _prev2[0],\n            prevPath = _prev2[1];\n\n        var _block = _slicedToArray(block, 2),\n            blockPath = _block[1];\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, [\"text\"]);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next: function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode2 = options.mode,\n        mode = _options$mode2 === void 0 ? 'lowest' : _options$mode2,\n        _options$voids3 = options.voids,\n        voids = _options$voids3 === void 0 ? false : _options$voids3;\n    var match = options.match,\n        _options$at3 = options.at,\n        at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n    if (!at) {\n      return;\n    }\n\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids: voids\n    });\n    if (!pointAfterLocation) return;\n\n    var _Editor$last = Editor.last(editor, []),\n        _Editor$last2 = _slicedToArray(_Editor$last, 2),\n        to = _Editor$last2[1];\n\n    var span = [pointAfterLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent = Editor.parent(editor, at),\n            _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n            parent = _Editor$parent2[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes3 = Editor.nodes(editor, {\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n        next = _Editor$nodes4[0];\n\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node: function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  nodes: /*#__PURE__*/_regeneratorRuntime.mark(function nodes(editor) {\n    var options,\n        _options$at4,\n        at,\n        _options$mode3,\n        mode,\n        _options$universal,\n        universal,\n        _options$reverse2,\n        reverse,\n        _options$voids4,\n        voids,\n        match,\n        from,\n        to,\n        first,\n        last,\n        nodeEntries,\n        matches,\n        hit,\n        _iterator12,\n        _step12,\n        _step12$value,\n        node,\n        path,\n        isLower,\n        emit,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function nodes$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? 'all' : _options$mode3, _options$universal = options.universal, universal = _options$universal === void 0 ? false : _options$universal, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;\n            match = options.match;\n\n            if (!match) {\n              match = function match() {\n                return true;\n              };\n            }\n\n            if (at) {\n              _context2.next = 6;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 6:\n            if (Span.isSpan(at)) {\n              from = at[0];\n              to = at[1];\n            } else {\n              first = Editor.path(editor, at, {\n                edge: 'start'\n              });\n              last = Editor.path(editor, at, {\n                edge: 'end'\n              });\n              from = reverse ? last : first;\n              to = reverse ? first : last;\n            }\n\n            nodeEntries = Node.nodes(editor, {\n              reverse: reverse,\n              from: from,\n              to: to,\n              pass: function pass(_ref) {\n                var _ref7 = _slicedToArray(_ref, 1),\n                    n = _ref7[0];\n\n                return voids ? false : Editor.isVoid(editor, n);\n              }\n            });\n            matches = [];\n            _iterator12 = _createForOfIteratorHelper(nodeEntries);\n            _context2.prev = 10;\n\n            _iterator12.s();\n\n          case 12:\n            if ((_step12 = _iterator12.n()).done) {\n              _context2.next = 37;\n              break;\n            }\n\n            _step12$value = _slicedToArray(_step12.value, 2), node = _step12$value[0], path = _step12$value[1];\n            isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n            if (!(mode === 'highest' && isLower)) {\n              _context2.next = 17;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 35);\n\n          case 17:\n            if (match(node, path)) {\n              _context2.next = 23;\n              break;\n            }\n\n            if (!(universal && !isLower && Text.isText(node))) {\n              _context2.next = 22;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 22:\n            return _context2.abrupt(\"continue\", 35);\n\n          case 23:\n            if (!(mode === 'lowest' && isLower)) {\n              _context2.next = 26;\n              break;\n            }\n\n            hit = [node, path];\n            return _context2.abrupt(\"continue\", 35);\n\n          case 26:\n            // In lowest mode we emit the last hit, once it's guaranteed lowest.\n            emit = mode === 'lowest' ? hit : [node, path];\n\n            if (!emit) {\n              _context2.next = 34;\n              break;\n            }\n\n            if (!universal) {\n              _context2.next = 32;\n              break;\n            }\n\n            matches.push(emit);\n            _context2.next = 34;\n            break;\n\n          case 32:\n            _context2.next = 34;\n            return emit;\n\n          case 34:\n            hit = [node, path];\n\n          case 35:\n            _context2.next = 12;\n            break;\n\n          case 37:\n            _context2.next = 42;\n            break;\n\n          case 39:\n            _context2.prev = 39;\n            _context2.t0 = _context2[\"catch\"](10);\n\n            _iterator12.e(_context2.t0);\n\n          case 42:\n            _context2.prev = 42;\n\n            _iterator12.f();\n\n            return _context2.finish(42);\n\n          case 45:\n            if (!(mode === 'lowest' && hit)) {\n              _context2.next = 52;\n              break;\n            }\n\n            if (!universal) {\n              _context2.next = 50;\n              break;\n            }\n\n            matches.push(hit);\n            _context2.next = 52;\n            break;\n\n          case 50:\n            _context2.next = 52;\n            return hit;\n\n          case 52:\n            if (!universal) {\n              _context2.next = 54;\n              break;\n            }\n\n            return _context2.delegateYield(matches, \"t1\", 54);\n\n          case 54:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, nodes, null, [[10, 39, 42, 45]]);\n  }),\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize: function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$force = options.force,\n        force = _options$force === void 0 ? false : _options$force;\n\n    var getDirtyPaths = function getDirtyPaths(editor) {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), function (_ref2) {\n        var _ref8 = _slicedToArray(_ref2, 2),\n            p = _ref8[1];\n\n        return p;\n      });\n      DIRTY_PATHS.set(editor, allPaths);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, function () {\n      /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */\n      var _iterator13 = _createForOfIteratorHelper(getDirtyPaths(editor)),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var dirtyPath = _step13.value;\n\n          if (Node.has(editor, dirtyPath)) {\n            var _Editor$node = Editor.node(editor, dirtyPath),\n                _Editor$node2 = _slicedToArray(_Editor$node, 2),\n                node = _Editor$node2[0],\n                _ = _Editor$node2[1]; // Add a text child to elements with no children.\n            // This is safe to do in any order, by definition it can't cause other paths to change.\n\n\n            if (Element.isElement(node) && node.children.length === 0) {\n              var child = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, child, {\n                at: dirtyPath.concat(0),\n                voids: true\n              });\n            }\n          }\n        }\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var _dirtyPath = getDirtyPaths(editor).pop(); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n\n        if (Node.has(editor, _dirtyPath)) {\n          var entry = Editor.node(editor, _dirtyPath);\n          editor.normalizeNode(entry);\n        }\n\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent: function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path: function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var depth = options.depth,\n        edge = options.edge;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var _Node$first = Node.first(editor, at),\n            _Node$first2 = _slicedToArray(_Node$first, 2),\n            firstPath = _Node$first2[1];\n\n        at = firstPath;\n      } else if (edge === 'end') {\n        var _Node$last = Node.last(editor, at),\n            _Node$last2 = _slicedToArray(_Node$last, 2),\n            lastPath = _Node$last2[1];\n\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n  hasPath: function hasPath(editor, path) {\n    return Node.has(editor, path);\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef: function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    var ref = {\n      current: path,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs: function pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point: function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'start' : _options$edge;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var _Node$last3 = Node.last(editor, at),\n            _Node$last4 = _slicedToArray(_Node$last3, 2),\n            lastPath = _Node$last4[1];\n\n        path = lastPath;\n      } else {\n        var _Node$first3 = Node.first(editor, at),\n            _Node$first4 = _slicedToArray(_Node$first3, 2),\n            firstPath = _Node$first4[1];\n\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path: path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef: function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity2 = options.affinity,\n        affinity = _options$affinity2 === void 0 ? 'forward' : _options$affinity2;\n    var ref = {\n      current: point,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs: function pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */\n  positions: /*#__PURE__*/_regeneratorRuntime.mark(function positions(editor) {\n    var options,\n        _options$at5,\n        at,\n        _options$unit3,\n        unit,\n        _options$reverse3,\n        reverse$1,\n        _options$voids5,\n        voids,\n        range,\n        _Range$edges3,\n        _Range$edges4,\n        start,\n        end,\n        first,\n        isNewBlock,\n        blockText,\n        distance,\n        leafTextRemaining,\n        leafTextOffset,\n        _iterator14,\n        _step14,\n        _step14$value,\n        node,\n        path,\n        e,\n        s,\n        isFirst,\n        calcDistance,\n        _args3 = arguments;\n\n    return _regeneratorRuntime.wrap(function positions$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            calcDistance = function _calcDistance(text, unit) {\n              if (unit === 'character') {\n                return getCharacterDistance(text);\n              } else if (unit === 'word') {\n                return getWordDistance(text);\n              } else if (unit === 'line' || unit === 'block') {\n                return text.length;\n              }\n\n              return 1;\n            };\n\n            options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, _options$unit3 = options.unit, unit = _options$unit3 === void 0 ? 'offset' : _options$unit3, _options$reverse3 = options.reverse, reverse$1 = _options$reverse3 === void 0 ? false : _options$reverse3, _options$voids5 = options.voids, voids = _options$voids5 === void 0 ? false : _options$voids5;\n\n            if (at) {\n              _context3.next = 5;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 5:\n            /**\r\n             * Algorithm notes:\r\n             *\r\n             * Each step `distance` is dynamic depending on the underlying text\r\n             * and the `unit` specified.  Each step, e.g., a line or word, may\r\n             * span multiple text nodes, so we iterate through the text both on\r\n             * two levels in step-sync:\r\n             *\r\n             * `leafText` stores the text on a text leaf level, and is advanced\r\n             * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n             *\r\n             * `blockText` stores the text on a block level, and is shortened\r\n             * by `distance` every time it is advanced.\r\n             *\r\n             * We only maintain a window of one blockText and one leafText because\r\n             * a block node always appears before all of its leaf nodes.\r\n             */\n            range = Editor.range(editor, at);\n            _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n            first = reverse$1 ? end : start;\n            isNewBlock = false;\n            blockText = '';\n            distance = 0; // Distance for leafText to catch up to blockText.\n\n            leafTextRemaining = 0;\n            leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n            // of block nodes in blockText, and text nodes in leafText.\n            // Exploits the fact that nodes are sequenced in such a way that we first\n            // encounter the block node, then all of its text nodes, so when iterating\n            // through the blockText and leafText we just need to remember a window of\n            // one block node and leaf node, respectively.\n\n            _iterator14 = _createForOfIteratorHelper(Editor.nodes(editor, {\n              at: at,\n              reverse: reverse$1,\n              voids: voids\n            }));\n            _context3.prev = 14;\n\n            _iterator14.s();\n\n          case 16:\n            if ((_step14 = _iterator14.n()).done) {\n              _context3.next = 51;\n              break;\n            }\n\n            _step14$value = _slicedToArray(_step14.value, 2), node = _step14$value[0], path = _step14$value[1];\n\n            if (!Element.isElement(node)) {\n              _context3.next = 26;\n              break;\n            }\n\n            if (!(!voids && editor.isVoid(node))) {\n              _context3.next = 23;\n              break;\n            }\n\n            _context3.next = 22;\n            return Editor.start(editor, path);\n\n          case 22:\n            return _context3.abrupt(\"continue\", 49);\n\n          case 23:\n            if (!editor.isInline(node)) {\n              _context3.next = 25;\n              break;\n            }\n\n            return _context3.abrupt(\"continue\", 49);\n\n          case 25:\n            // Block element node - set `blockText` to its text content.\n            if (Editor.hasInlines(editor, node)) {\n              // We always exhaust block nodes before encountering a new one:\n              //   console.assert(blockText === '',\n              //     `blockText='${blockText}' - `+\n              //     `not exhausted before new block node`, path)\n              // Ensure range considered is capped to `range`, in the\n              // start/end edge cases where block extends beyond range.\n              // Equivalent to this, but presumably more performant:\n              //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n              //   blockRange = Range.intersection(range, blockRange) // intersect\n              //   blockText = Editor.string(editor, blockRange, { voids })\n              e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n              s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n              blockText = Editor.string(editor, {\n                anchor: s,\n                focus: e\n              }, {\n                voids: voids\n              });\n              blockText = reverse$1 ? reverse(blockText) : blockText;\n              isNewBlock = true;\n            }\n\n          case 26:\n            if (!Text.isText(node)) {\n              _context3.next = 49;\n              break;\n            }\n\n            isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n            //   console.assert(leafTextRemaining <= 0,\n            //     `leafTextRemaining=${leafTextRemaining} - `+\n            //     `not exhausted before new leaf text node`, path)\n            // Reset `leafText` counters for new text node.\n\n            if (isFirst) {\n              leafTextRemaining = reverse$1 ? first.offset : node.text.length - first.offset;\n              leafTextOffset = first.offset; // Works for reverse too.\n            } else {\n              leafTextRemaining = node.text.length;\n              leafTextOffset = reverse$1 ? leafTextRemaining : 0;\n            } // Yield position at the start of node (potentially).\n\n\n            if (!(isFirst || isNewBlock || unit === 'offset')) {\n              _context3.next = 33;\n              break;\n            }\n\n            _context3.next = 32;\n            return {\n              path: path,\n              offset: leafTextOffset\n            };\n\n          case 32:\n            isNewBlock = false;\n\n          case 33:\n            if (!true) {\n              _context3.next = 49;\n              break;\n            }\n\n            if (!(distance === 0)) {\n              _context3.next = 39;\n              break;\n            }\n\n            if (!(blockText === '')) {\n              _context3.next = 37;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 49);\n\n          case 37:\n            distance = calcDistance(blockText, unit);\n            blockText = blockText.slice(distance);\n\n          case 39:\n            // Advance `leafText` by the current `distance`.\n            leafTextOffset = reverse$1 ? leafTextOffset - distance : leafTextOffset + distance;\n            leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n            // and set distance to the overflow amount, so we'll (maybe)\n            // catch up to blockText in the next leaf text node.\n\n            if (!(leafTextRemaining < 0)) {\n              _context3.next = 44;\n              break;\n            }\n\n            distance = -leafTextRemaining;\n            return _context3.abrupt(\"break\", 49);\n\n          case 44:\n            // Successfully walked `distance` offsets through `leafText`\n            // to catch up with `blockText`, so we can reset `distance`\n            // and yield this position in this node.\n            distance = 0;\n            _context3.next = 47;\n            return {\n              path: path,\n              offset: leafTextOffset\n            };\n\n          case 47:\n            _context3.next = 33;\n            break;\n\n          case 49:\n            _context3.next = 16;\n            break;\n\n          case 51:\n            _context3.next = 56;\n            break;\n\n          case 53:\n            _context3.prev = 53;\n            _context3.t0 = _context3[\"catch\"](14);\n\n            _iterator14.e(_context3.t0);\n\n          case 56:\n            _context3.prev = 56;\n\n            _iterator14.f();\n\n            return _context3.finish(56);\n\n          case 59:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, positions, null, [[14, 53, 56, 59]]);\n  }),\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous: function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode4 = options.mode,\n        mode = _options$mode4 === void 0 ? 'lowest' : _options$mode4,\n        _options$voids6 = options.voids,\n        voids = _options$voids6 === void 0 ? false : _options$voids6;\n    var match = options.match,\n        _options$at6 = options.at,\n        at = _options$at6 === void 0 ? editor.selection : _options$at6;\n\n    if (!at) {\n      return;\n    }\n\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids: voids\n    });\n\n    if (!pointBeforeLocation) {\n      return;\n    }\n\n    var _Editor$first = Editor.first(editor, []),\n        _Editor$first2 = _slicedToArray(_Editor$first, 2),\n        to = _Editor$first2[1]; // The search location is from the start of the document to the path of\n    // the point before the location passed in\n\n\n    var span = [pointBeforeLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent3 = Editor.parent(editor, at),\n            _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n            parent = _Editor$parent4[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes5 = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 1),\n        previous = _Editor$nodes6[0];\n\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range: function range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef: function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity3 = options.affinity,\n        affinity = _options$affinity3 === void 0 ? 'forward' : _options$affinity3;\n    var ref = {\n      current: range,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs: function rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark: function removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start: function start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */\n  string: function string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids7 = options.voids,\n        voids = _options$voids7 === void 0 ? false : _options$voids7;\n    var range = Editor.range(editor, at);\n\n    var _Range$edges5 = Range.edges(range),\n        _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n        start = _Range$edges6[0],\n        end = _Range$edges6[1];\n\n    var text = '';\n\n    var _iterator15 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids: voids\n    })),\n        _step15;\n\n    try {\n      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n        var _step15$value = _slicedToArray(_step15.value, 2),\n            node = _step15$value[0],\n            path = _step15$value[1];\n\n        var t = node.text;\n\n        if (Path.equals(path, end.path)) {\n          t = t.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          t = t.slice(start.offset);\n        }\n\n        text += t;\n      }\n    } catch (err) {\n      _iterator15.e(err);\n    } finally {\n      _iterator15.f();\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange: function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids8 = options.voids,\n        voids = _options$voids8 === void 0 ? false : _options$voids8;\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, []);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    var _iterator16 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids: voids\n    })),\n        _step16;\n\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var _step16$value = _slicedToArray(_step16.value, 2),\n            node = _step16$value[0],\n            path = _step16$value[1];\n\n        if (skip) {\n          skip = false;\n          continue;\n        }\n\n        if (node.text !== '' || Path.isBefore(path, blockPath)) {\n          end = {\n            path: path,\n            offset: node.text.length\n          };\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  void: function _void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$1(_objectSpread$1({}, options), {}, {\n      match: function match(n) {\n        return Editor.isVoid(editor, n);\n      }\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    NORMALIZING.set(editor, false);\n\n    try {\n      fn();\n    } finally {\n      NORMALIZING.set(editor, value);\n    }\n\n    Editor.normalize(editor);\n  }\n};\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\nvar IS_NODE_LIST_CACHE = new WeakMap();\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\n  ancestors: /*#__PURE__*/_regeneratorRuntime.mark(function ancestors(root, path) {\n    var options,\n        _iterator17,\n        _step17,\n        p,\n        n,\n        entry,\n        _args4 = arguments;\n\n    return _regeneratorRuntime.wrap(function ancestors$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n            _iterator17 = _createForOfIteratorHelper(Path.ancestors(path, options));\n            _context4.prev = 2;\n\n            _iterator17.s();\n\n          case 4:\n            if ((_step17 = _iterator17.n()).done) {\n              _context4.next = 12;\n              break;\n            }\n\n            p = _step17.value;\n            n = Node.ancestor(root, p);\n            entry = [n, p];\n            _context4.next = 10;\n            return entry;\n\n          case 10:\n            _context4.next = 4;\n            break;\n\n          case 12:\n            _context4.next = 17;\n            break;\n\n          case 14:\n            _context4.prev = 14;\n            _context4.t0 = _context4[\"catch\"](2);\n\n            _iterator17.e(_context4.t0);\n\n          case 17:\n            _context4.prev = 17;\n\n            _iterator17.f();\n\n            return _context4.finish(17);\n\n          case 20:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, ancestors, null, [[2, 14, 17, 20]]);\n  }),\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(JSON.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(JSON.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  children: /*#__PURE__*/_regeneratorRuntime.mark(function children(root, path) {\n    var options,\n        _options$reverse4,\n        reverse,\n        ancestor,\n        children,\n        index,\n        child,\n        childPath,\n        _args5 = arguments;\n\n    return _regeneratorRuntime.wrap(function children$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};\n            _options$reverse4 = options.reverse, reverse = _options$reverse4 === void 0 ? false : _options$reverse4;\n            ancestor = Node.ancestor(root, path);\n            children = ancestor.children;\n            index = reverse ? children.length - 1 : 0;\n\n          case 5:\n            if (!(reverse ? index >= 0 : index < children.length)) {\n              _context5.next = 13;\n              break;\n            }\n\n            child = Node.child(ancestor, index);\n            childPath = path.concat(index);\n            _context5.next = 10;\n            return [child, childPath];\n\n          case 10:\n            index = reverse ? index - 1 : index + 1;\n            _context5.next = 5;\n            break;\n\n          case 13:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, children);\n  }),\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  descendants: /*#__PURE__*/_regeneratorRuntime.mark(function descendants(root) {\n    var options,\n        _iterator18,\n        _step18,\n        _step18$value,\n        node,\n        path,\n        _args6 = arguments;\n\n    return _regeneratorRuntime.wrap(function descendants$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n            _iterator18 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context6.prev = 2;\n\n            _iterator18.s();\n\n          case 4:\n            if ((_step18 = _iterator18.n()).done) {\n              _context6.next = 11;\n              break;\n            }\n\n            _step18$value = _slicedToArray(_step18.value, 2), node = _step18$value[0], path = _step18$value[1];\n\n            if (!(path.length !== 0)) {\n              _context6.next = 9;\n              break;\n            }\n\n            _context6.next = 9;\n            return [node, path];\n\n          case 9:\n            _context6.next = 4;\n            break;\n\n          case 11:\n            _context6.next = 16;\n            break;\n\n          case 13:\n            _context6.prev = 13;\n            _context6.t0 = _context6[\"catch\"](2);\n\n            _iterator18.e(_context6.t0);\n\n          case 16:\n            _context6.prev = 16;\n\n            _iterator18.f();\n\n            return _context6.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, descendants, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  elements: /*#__PURE__*/_regeneratorRuntime.mark(function elements(root) {\n    var options,\n        _iterator19,\n        _step19,\n        _step19$value,\n        node,\n        path,\n        _args7 = arguments;\n\n    return _regeneratorRuntime.wrap(function elements$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n            _iterator19 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context7.prev = 2;\n\n            _iterator19.s();\n\n          case 4:\n            if ((_step19 = _iterator19.n()).done) {\n              _context7.next = 11;\n              break;\n            }\n\n            _step19$value = _slicedToArray(_step19.value, 2), node = _step19$value[0], path = _step19$value[1];\n\n            if (!Element.isElement(node)) {\n              _context7.next = 9;\n              break;\n            }\n\n            _context7.next = 9;\n            return [node, path];\n\n          case 9:\n            _context7.next = 4;\n            break;\n\n          case 11:\n            _context7.next = 16;\n            break;\n\n          case 13:\n            _context7.prev = 13;\n            _context7.t0 = _context7[\"catch\"](2);\n\n            _iterator19.e(_context7.t0);\n\n          case 16:\n            _context7.prev = 16;\n\n            _iterator19.f();\n\n            return _context7.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, elements, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Extract props from a Node.\r\n   */\n  extractProps: function extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, [\"children\"]);\n\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, [\"text\"]);\n\n      return properties;\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(JSON.stringify(root)));\n    }\n\n    var newRoot = produce({\n      children: root.children\n    }, function (r) {\n      var _Range$edges9 = Range.edges(range),\n          _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n          start = _Range$edges10[0],\n          end = _Range$edges10[1];\n\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref9 = _slicedToArray(_ref, 2),\n              path = _ref9[1];\n\n          return !Range.includes(range, path);\n        }\n      });\n\n      var _iterator20 = _createForOfIteratorHelper(nodeEntries),\n          _step20;\n\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var _step20$value = _slicedToArray(_step20.value, 2),\n              path = _step20$value[1];\n\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get: function get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(JSON.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has: function has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList: function isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(function (val) {\n      return Node.isNode(val);\n    });\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  levels: /*#__PURE__*/_regeneratorRuntime.mark(function levels(root, path) {\n    var options,\n        _iterator21,\n        _step21,\n        p,\n        n,\n        _args8 = arguments;\n\n    return _regeneratorRuntime.wrap(function levels$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {};\n            _iterator21 = _createForOfIteratorHelper(Path.levels(path, options));\n            _context8.prev = 2;\n\n            _iterator21.s();\n\n          case 4:\n            if ((_step21 = _iterator21.n()).done) {\n              _context8.next = 11;\n              break;\n            }\n\n            p = _step21.value;\n            n = Node.get(root, p);\n            _context8.next = 9;\n            return [n, p];\n\n          case 9:\n            _context8.next = 4;\n            break;\n\n          case 11:\n            _context8.next = 16;\n            break;\n\n          case 13:\n            _context8.prev = 13;\n            _context8.t0 = _context8[\"catch\"](2);\n\n            _iterator21.e(_context8.t0);\n\n          case 16:\n            _context8.prev = 16;\n\n            _iterator21.f();\n\n            return _context8.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, levels, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  nodes: /*#__PURE__*/_regeneratorRuntime.mark(function nodes(root) {\n    var options,\n        pass,\n        _options$reverse5,\n        reverse,\n        _options$from,\n        from,\n        to,\n        visited,\n        p,\n        n,\n        nextIndex,\n        newPath,\n        _newPath,\n        _args9 = arguments;\n\n    return _regeneratorRuntime.wrap(function nodes$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n            pass = options.pass, _options$reverse5 = options.reverse, reverse = _options$reverse5 === void 0 ? false : _options$reverse5;\n            _options$from = options.from, from = _options$from === void 0 ? [] : _options$from, to = options.to;\n            visited = new Set();\n            p = [];\n            n = root;\n\n          case 6:\n            if (!true) {\n              _context9.next = 37;\n              break;\n            }\n\n            if (!(to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to)))) {\n              _context9.next = 9;\n              break;\n            }\n\n            return _context9.abrupt(\"break\", 37);\n\n          case 9:\n            if (visited.has(n)) {\n              _context9.next = 12;\n              break;\n            }\n\n            _context9.next = 12;\n            return [n, p];\n\n          case 12:\n            if (!(!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false))) {\n              _context9.next = 19;\n              break;\n            }\n\n            visited.add(n);\n            nextIndex = reverse ? n.children.length - 1 : 0;\n\n            if (Path.isAncestor(p, from)) {\n              nextIndex = from[p.length];\n            }\n\n            p = p.concat(nextIndex);\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 19:\n            if (!(p.length === 0)) {\n              _context9.next = 21;\n              break;\n            }\n\n            return _context9.abrupt(\"break\", 37);\n\n          case 21:\n            if (reverse) {\n              _context9.next = 27;\n              break;\n            }\n\n            newPath = Path.next(p);\n\n            if (!Node.has(root, newPath)) {\n              _context9.next = 27;\n              break;\n            }\n\n            p = newPath;\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 27:\n            if (!(reverse && p[p.length - 1] !== 0)) {\n              _context9.next = 32;\n              break;\n            }\n\n            _newPath = Path.previous(p);\n            p = _newPath;\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 32:\n            // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n            _context9.next = 6;\n            break;\n\n          case 37:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, nodes);\n  }),\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string: function string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  texts: /*#__PURE__*/_regeneratorRuntime.mark(function texts(root) {\n    var options,\n        _iterator22,\n        _step22,\n        _step22$value,\n        node,\n        path,\n        _args10 = arguments;\n\n    return _regeneratorRuntime.wrap(function texts$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n            _iterator22 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context10.prev = 2;\n\n            _iterator22.s();\n\n          case 4:\n            if ((_step22 = _iterator22.n()).done) {\n              _context10.next = 11;\n              break;\n            }\n\n            _step22$value = _slicedToArray(_step22.value, 2), node = _step22$value[0], path = _step22$value[1];\n\n            if (!Text.isText(node)) {\n              _context10.next = 9;\n              break;\n            }\n\n            _context10.next = 9;\n            return [node, path];\n\n          case 9:\n            _context10.next = 4;\n            break;\n\n          case 11:\n            _context10.next = 16;\n            break;\n\n          case 13:\n            _context10.prev = 13;\n            _context10.t0 = _context10[\"catch\"](2);\n\n            _iterator22.e(_context10.t0);\n\n          case 16:\n            _context10.prev = 16;\n\n            _iterator22.f();\n\n            return _context10.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, texts, null, [[2, 13, 16, 19]]);\n  })\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation: function isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Operation.isOperation(val);\n    });\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n              path = op.path; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var properties = op.properties,\n              newProperties = op.newProperties;\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n              _newProperties = op.newProperties;\n\n          if (_properties == null) {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$2(_objectSpread$2({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$2(_objectSpread$2({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse6 = options.reverse,\n        reverse = _options$reverse6 === void 0 ? false : _options$reverse6;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common: function common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n\n  /**\r\n   * Check if the path of previous sibling node exists\r\n   */\n  hasPrevious: function hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse7 = options.reverse,\n        reverse = _options$reverse7 === void 0 ? false : _options$reverse7;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(path, function (p) {\n      var _options$affinity4 = options.affinity,\n          affinity = _options$affinity4 === void 0 ? 'forward' : _options$affinity4; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (path.length === 0) {\n        return;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var op = operation.path;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var _op = operation.path;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var _op2 = operation.path,\n                position = operation.position;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var _op3 = operation.path,\n                _position = operation.position;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ;else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var _op4 = operation.path,\n                onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                copy[_op4.length - 1] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              } else {\n                p[_op4.length - 1] += 1;\n              }\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$3(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint: function isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(point, function (p) {\n      var _options$affinity5 = options.affinity,\n          affinity = _options$affinity5 === void 0 ? 'forward' : _options$affinity5;\n      var path = p.path,\n          offset = p.offset;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$3(_objectSpread$3({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$4(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse8 = options.reverse,\n        reverse = _options$reverse8 === void 0 ? false : _options$reverse8;\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end: function end(range) {\n    var _Range$edges11 = Range.edges(range),\n        _Range$edges12 = _slicedToArray(_Range$edges11, 2),\n        end = _Range$edges12[1];\n\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var _Range$edges13 = Range.edges(range),\n          _Range$edges14 = _slicedToArray(_Range$edges13, 2),\n          rs = _Range$edges14[0],\n          re = _Range$edges14[1];\n\n      var _Range$edges15 = Range.edges(target),\n          _Range$edges16 = _slicedToArray(_Range$edges15, 2),\n          ts = _Range$edges16[0],\n          te = _Range$edges16[1];\n\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var _Range$edges17 = Range.edges(range),\n        _Range$edges18 = _slicedToArray(_Range$edges17, 2),\n        start = _Range$edges18[0],\n        end = _Range$edges18[1];\n\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection: function intersection(range, another) {\n    var rest = _objectWithoutProperties(range, [\"anchor\", \"focus\"]);\n\n    var _Range$edges19 = Range.edges(range),\n        _Range$edges20 = _slicedToArray(_Range$edges19, 2),\n        s1 = _Range$edges20[0],\n        e1 = _Range$edges20[1];\n\n    var _Range$edges21 = Range.edges(another),\n        _Range$edges22 = _slicedToArray(_Range$edges21, 2),\n        s2 = _Range$edges22[0],\n        e2 = _Range$edges22[1];\n\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$4({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange: function isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  points: /*#__PURE__*/_regeneratorRuntime.mark(function points(range) {\n    return _regeneratorRuntime.wrap(function points$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return [range.anchor, 'anchor'];\n\n          case 2:\n            _context11.next = 4;\n            return [range.focus, 'focus'];\n\n          case 4:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, points);\n  }),\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start: function start(range) {\n    var _Range$edges23 = Range.edges(range),\n        _Range$edges24 = _slicedToArray(_Range$edges23, 1),\n        start = _Range$edges24[0];\n\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform: function transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity6 = options.affinity,\n        affinity = _options$affinity6 === void 0 ? 'inward' : _options$affinity6;\n    var affinityAnchor;\n    var affinityFocus;\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      } else {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      } else {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      }\n    } else {\n      affinityAnchor = affinity;\n      affinityFocus = affinity;\n    }\n\n    return produce(range, function (r) {\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$5(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$5(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   */\n  equals: function equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$loose = options.loose,\n        loose = _options$loose === void 0 ? false : _options$loose;\n\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, [\"text\"]);\n\n      return rest;\n    }\n\n    return isEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText: function isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && value.every(function (val) {\n      return Text.isText(val);\n    });\n  },\n\n  /**\r\n   * Check if some props are a partial of Text.\r\n   */\n  isTextProps: function isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations: function decorations(node, _decorations) {\n    var leaves = [_objectSpread$5({}, node)];\n\n    var _iterator23 = _createForOfIteratorHelper(_decorations),\n        _step23;\n\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var dec = _step23.value;\n\n        var rest = _objectWithoutProperties(dec, [\"anchor\", \"focus\"]);\n\n        var _Range$edges25 = Range.edges(dec),\n            _Range$edges26 = _slicedToArray(_Range$edges25, 2),\n            start = _Range$edges26[0],\n            end = _Range$edges26[1];\n\n        var next = [];\n        var o = 0;\n\n        var _iterator24 = _createForOfIteratorHelper(leaves),\n            _step24;\n\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var leaf = _step24.value;\n            var length = leaf.text.length;\n            var offset = o;\n            o += length; // If the range encompases the entire leaf, add the range.\n\n            if (start.offset <= offset && end.offset >= o) {\n              Object.assign(leaf, rest);\n              next.push(leaf);\n              continue;\n            } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n            if (start.offset !== end.offset && (start.offset === o || end.offset === offset) || start.offset > o || end.offset < offset || end.offset === offset && offset !== 0) {\n              next.push(leaf);\n              continue;\n            } // Otherwise we need to split the leaf, at the start, end, or both,\n            // and add the range to the middle intersecting section. Do the end\n            // split first since we don't need to update the offset that way.\n\n\n            var middle = leaf;\n            var before = void 0;\n            var after = void 0;\n\n            if (end.offset < o) {\n              var off = end.offset - offset;\n              after = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n                text: middle.text.slice(off)\n              });\n              middle = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n                text: middle.text.slice(0, off)\n              });\n            }\n\n            if (start.offset > offset) {\n              var _off = start.offset - offset;\n\n              before = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n                text: middle.text.slice(0, _off)\n              });\n              middle = _objectSpread$5(_objectSpread$5({}, middle), {}, {\n                text: middle.text.slice(_off)\n              });\n            }\n\n            Object.assign(middle, rest);\n\n            if (before) {\n              next.push(before);\n            }\n\n            next.push(middle);\n\n            if (after) {\n              next.push(after);\n            }\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n\n        leaves = next;\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n\n    return leaves;\n  }\n};\n\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$6(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$6(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$6(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar applyToDraft = function applyToDraft(editor, selection, op) {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var path = op.path,\n            node = op.node;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n\n        parent.children.splice(index, 0, node);\n\n        if (selection) {\n          var _iterator25 = _createForOfIteratorHelper(Range.points(selection)),\n              _step25;\n\n          try {\n            for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n              var _step25$value = _slicedToArray(_step25.value, 2),\n                  point = _step25$value[0],\n                  key = _step25$value[1];\n\n              selection[key] = Point.transform(point, op);\n            }\n          } catch (err) {\n            _iterator25.e(err);\n          } finally {\n            _iterator25.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'insert_text':\n      {\n        var _path = op.path,\n            offset = op.offset,\n            text = op.text;\n        if (text.length === 0) break;\n\n        var _node = Node.leaf(editor, _path);\n\n        var before = _node.text.slice(0, offset);\n\n        var after = _node.text.slice(offset);\n\n        _node.text = before + text + after;\n\n        if (selection) {\n          var _iterator26 = _createForOfIteratorHelper(Range.points(selection)),\n              _step26;\n\n          try {\n            for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n              var _step26$value = _slicedToArray(_step26.value, 2),\n                  _point = _step26$value[0],\n                  _key = _step26$value[1];\n\n              selection[_key] = Point.transform(_point, op);\n            }\n          } catch (err) {\n            _iterator26.e(err);\n          } finally {\n            _iterator26.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'merge_node':\n      {\n        var _path2 = op.path;\n\n        var _node2 = Node.get(editor, _path2);\n\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n\n        var _parent = Node.parent(editor, _path2);\n\n        var _index = _path2[_path2.length - 1];\n\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          var _prev$children;\n\n          (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node2.children));\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(_node2, \" \").concat(prev));\n        }\n\n        _parent.children.splice(_index, 1);\n\n        if (selection) {\n          var _iterator27 = _createForOfIteratorHelper(Range.points(selection)),\n              _step27;\n\n          try {\n            for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n              var _step27$value = _slicedToArray(_step27.value, 2),\n                  _point2 = _step27$value[0],\n                  _key2 = _step27$value[1];\n\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          } catch (err) {\n            _iterator27.e(err);\n          } finally {\n            _iterator27.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'move_node':\n      {\n        var _path3 = op.path,\n            newPath = op.newPath;\n\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n\n        var _node3 = Node.get(editor, _path3);\n\n        var _parent2 = Node.parent(editor, _path3);\n\n        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n\n        _parent2.children.splice(_index2, 1);\n\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n\n        if (selection) {\n          var _iterator28 = _createForOfIteratorHelper(Range.points(selection)),\n              _step28;\n\n          try {\n            for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n              var _step28$value = _slicedToArray(_step28.value, 2),\n                  _point3 = _step28$value[0],\n                  _key3 = _step28$value[1];\n\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          } catch (err) {\n            _iterator28.e(err);\n          } finally {\n            _iterator28.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_node':\n      {\n        var _path4 = op.path;\n        var _index3 = _path4[_path4.length - 1];\n\n        var _parent3 = Node.parent(editor, _path4);\n\n        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n\n\n        if (selection) {\n          var _iterator29 = _createForOfIteratorHelper(Range.points(selection)),\n              _step29;\n\n          try {\n            for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n              var _step29$value = _slicedToArray(_step29.value, 2),\n                  _point4 = _step29$value[0],\n                  _key4 = _step29$value[1];\n\n              var result = Point.transform(_point4, op);\n\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n\n                var next = void 0;\n\n                var _iterator30 = _createForOfIteratorHelper(Node.texts(editor)),\n                    _step30;\n\n                try {\n                  for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                    var _step30$value = _slicedToArray(_step30.value, 2),\n                        n = _step30$value[0],\n                        p = _step30$value[1];\n\n                    if (Path.compare(p, _path4) === -1) {\n                      _prev = [n, p];\n                    } else {\n                      next = [n, p];\n                      break;\n                    }\n                  }\n                } catch (err) {\n                  _iterator30.e(err);\n                } finally {\n                  _iterator30.f();\n                }\n\n                if (_prev) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          } catch (err) {\n            _iterator29.e(err);\n          } finally {\n            _iterator29.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_text':\n      {\n        var _path5 = op.path,\n            _offset = op.offset,\n            _text = op.text;\n        if (_text.length === 0) break;\n\n        var _node4 = Node.leaf(editor, _path5);\n\n        var _before = _node4.text.slice(0, _offset);\n\n        var _after = _node4.text.slice(_offset + _text.length);\n\n        _node4.text = _before + _after;\n\n        if (selection) {\n          var _iterator31 = _createForOfIteratorHelper(Range.points(selection)),\n              _step31;\n\n          try {\n            for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n              var _step31$value = _slicedToArray(_step31.value, 2),\n                  _point5 = _step31$value[0],\n                  _key5 = _step31$value[1];\n\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          } catch (err) {\n            _iterator31.e(err);\n          } finally {\n            _iterator31.f();\n          }\n        }\n\n        break;\n      }\n\n    case 'set_node':\n      {\n        var _path6 = op.path,\n            properties = op.properties,\n            newProperties = op.newProperties;\n\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n\n        var _node5 = Node.get(editor, _path6);\n\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n\n          var value = newProperties[_key6];\n\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        } // properties that were previously defined, but are now missing, must be deleted\n\n\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n\n        break;\n      }\n\n    case 'set_selection':\n      {\n        var _newProperties = op.newProperties;\n\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _objectSpread$6({}, _newProperties);\n          }\n\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'split_node':\n      {\n        var _path7 = op.path,\n            position = op.position,\n            _properties = op.properties;\n\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n\n        var _node6 = Node.get(editor, _path7);\n\n        var _parent4 = Node.parent(editor, _path7);\n\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n\n          var _after2 = _node6.text.slice(position);\n\n          _node6.text = _before2;\n          newNode = _objectSpread$6(_objectSpread$6({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n\n          var _after3 = _node6.children.slice(position);\n\n          _node6.children = _before3;\n          newNode = _objectSpread$6(_objectSpread$6({}, _properties), {}, {\n            children: _after3\n          });\n        }\n\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n\n        if (selection) {\n          var _iterator32 = _createForOfIteratorHelper(Range.points(selection)),\n              _step32;\n\n          try {\n            for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n              var _step32$value = _slicedToArray(_step32.value, 2),\n                  _point6 = _step32$value[0],\n                  _key9 = _step32$value[1];\n\n              selection[_key9] = Point.transform(_point6, op);\n            }\n          } catch (err) {\n            _iterator32.e(err);\n          } finally {\n            _iterator32.f();\n          }\n        }\n\n        break;\n      }\n  }\n\n  return selection;\n};\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform: function transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = finishDraft(editor.children);\n\n      if (selection) {\n        editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n};\n\nfunction ownKeys$7(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$7(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$7(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$7(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes: function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging,\n          _options$voids9 = options.voids,\n          voids = _options$voids9 === void 0 ? false : _options$voids9,\n          _options$mode5 = options.mode,\n          mode = _options$mode5 === void 0 ? 'lowest' : _options$mode5;\n      var at = options.at,\n          match = options.match,\n          select = options.select;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var _nodes = nodes,\n          _nodes2 = _slicedToArray(_nodes, 1),\n          node = _nodes2[0]; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges27 = Range.edges(at),\n              _Range$edges28 = _slicedToArray(_Range$edges27, 2),\n              end = _Range$edges28[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = function match(n) {\n              return Text.isText(n);\n            };\n          } else if (editor.isInline(node)) {\n            match = function match(n) {\n              return Text.isText(n) || Editor.isInline(editor, n);\n            };\n          } else {\n            match = function match(n) {\n              return Editor.isBlock(editor, n);\n            };\n          }\n        }\n\n        var _Editor$nodes7 = Editor.nodes(editor, {\n          at: at.path,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n            _Editor$nodes8 = _slicedToArray(_Editor$nodes7, 1),\n            entry = _Editor$nodes8[0];\n\n        if (entry) {\n          var _entry2 = _slicedToArray(entry, 2),\n              _matchPath = _entry2[1];\n\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at: at,\n            match: match,\n            mode: mode,\n            voids: voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      var _iterator33 = _createForOfIteratorHelper(nodes),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _node = _step33.value;\n\n          var _path = parentPath.concat(index);\n\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path,\n            node: _node\n          });\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes: function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at7 = options.at,\n          at = _options$at7 === void 0 ? editor.selection : _options$at7,\n          _options$mode6 = options.mode,\n          mode = _options$mode6 === void 0 ? 'lowest' : _options$mode6,\n          _options$voids10 = options.voids,\n          voids = _options$voids10 === void 0 ? false : _options$voids10;\n      var match = options.match;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref10 = _slicedToArray(_ref, 2),\n            p = _ref10[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n        var pathRef = _pathRefs[_i];\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n\n        var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2),\n            parent = _parentNodeEntry[0],\n            parentPath = _parentNodeEntry[1];\n\n        var index = path[path.length - 1];\n        var length = parent.children.length;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids: voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids: voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids: voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids: voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids: voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids: voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes: function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at8 = options.at,\n          at = _options$at8 === void 0 ? editor.selection : _options$at8;\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2,\n          _options$voids11 = options.voids,\n          voids = _options$voids11 === void 0 ? false : _options$voids11,\n          _options$mode7 = options.mode,\n          mode = _options$mode7 === void 0 ? 'lowest' : _options$mode7;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var _Editor$parent5 = Editor.parent(editor, at),\n              _Editor$parent6 = _slicedToArray(_Editor$parent5, 1),\n              parent = _Editor$parent6[0];\n\n          match = function match(n) {\n            return parent.children.includes(n);\n          };\n        } else {\n          match = function match(n) {\n            return Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges29 = Range.edges(at),\n              _Range$edges30 = _slicedToArray(_Range$edges29, 2),\n              end = _Range$edges30[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var _Editor$nodes9 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      }),\n          _Editor$nodes10 = _slicedToArray(_Editor$nodes9, 1),\n          current = _Editor$nodes10[0];\n\n      var prev = Editor.previous(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var _current = _slicedToArray(current, 2),\n          node = _current[0],\n          path = _current[1];\n\n      var _prev3 = _slicedToArray(prev, 2),\n          prevNode = _prev3[0],\n          prevPath = _prev3[1];\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), function (_ref2) {\n        var _ref11 = _slicedToArray(_ref2, 1),\n            n = _ref11[0];\n\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: function match(n) {\n          return levels.includes(n) && hasSingleChildNest(editor, n);\n        }\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"text\"]);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"children\"]);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(JSON.stringify(node), \" \").concat(JSON.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids: voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids: voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids: voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position: position,\n          properties: properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes: function moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var to = options.to,\n          _options$at9 = options.at,\n          at = _options$at9 === void 0 ? editor.selection : _options$at9,\n          _options$mode8 = options.mode,\n          mode = _options$mode8 === void 0 ? 'lowest' : _options$mode8,\n          _options$voids12 = options.voids,\n          voids = _options$voids12 === void 0 ? false : _options$voids12;\n      var match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(targets, function (_ref3) {\n        var _ref12 = _slicedToArray(_ref3, 2),\n            p = _ref12[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++) {\n        var pathRef = _pathRefs2[_i2];\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path: path,\n            newPath: newPath\n          });\n        }\n\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes: function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging3 = options.hanging,\n          hanging = _options$hanging3 === void 0 ? false : _options$hanging3,\n          _options$voids13 = options.voids,\n          voids = _options$voids13 === void 0 ? false : _options$voids13,\n          _options$mode9 = options.mode,\n          mode = _options$mode9 === void 0 ? 'lowest' : _options$mode9;\n      var _options$at10 = options.at,\n          at = _options$at10 === void 0 ? editor.selection : _options$at10,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(depths, function (_ref4) {\n        var _ref13 = _slicedToArray(_ref4, 2),\n            p = _ref13[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++) {\n        var pathRef = _pathRefs3[_i3];\n        var path = pathRef.unref();\n\n        if (path) {\n          var _Editor$node3 = Editor.node(editor, path),\n              _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n              node = _Editor$node4[0];\n\n          editor.apply({\n            type: 'remove_node',\n            path: path,\n            node: node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes: function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at11 = options.at,\n          at = _options$at11 === void 0 ? editor.selection : _options$at11;\n      var _options$hanging4 = options.hanging,\n          hanging = _options$hanging4 === void 0 ? false : _options$hanging4,\n          _options$mode10 = options.mode,\n          mode = _options$mode10 === void 0 ? 'lowest' : _options$mode10,\n          _options$split = options.split,\n          split = _options$split === void 0 ? false : _options$split,\n          _options$voids14 = options.voids,\n          voids = _options$voids14 === void 0 ? false : _options$voids14;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (split && Range.isRange(at)) {\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n\n        var _Range$edges31 = Range.edges(at),\n            _Range$edges32 = _slicedToArray(_Range$edges31, 2),\n            start = _Range$edges32[0],\n            end = _Range$edges32[1];\n\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          mode: splitMode,\n          voids: voids,\n          always: !endAtEndOfNode\n        });\n        var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          mode: splitMode,\n          voids: voids,\n          always: !startAtStartOfNode\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var _iterator34 = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      })),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var _step34$value = _slicedToArray(_step34.value, 2),\n              node = _step34$value[0],\n              path = _step34$value[1];\n\n          var properties = {};\n          var newProperties = {}; // You can't set properties on the editor node.\n\n          if (path.length === 0) {\n            continue;\n          }\n\n          for (var k in props) {\n            if (k === 'children' || k === 'text') {\n              continue;\n            }\n\n            if (props[k] !== node[k]) {\n              // Omit new properties from the old property list rather than set them to undefined\n              if (node.hasOwnProperty(k)) properties[k] = node[k];\n              newProperties[k] = props[k];\n            }\n          }\n\n          if (Object.keys(newProperties).length !== 0) {\n            editor.apply({\n              type: 'set_node',\n              path: path,\n              properties: properties,\n              newProperties: newProperties\n            });\n          }\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes: function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode11 = options.mode,\n          mode = _options$mode11 === void 0 ? 'lowest' : _options$mode11,\n          _options$voids15 = options.voids,\n          voids = _options$voids15 === void 0 ? false : _options$voids15;\n      var match = options.match,\n          _options$at12 = options.at,\n          at = _options$at12 === void 0 ? editor.selection : _options$at12,\n          _options$height = options.height,\n          height = _options$height === void 0 ? 0 : _options$height,\n          _options$always = options.always,\n          always = _options$always === void 0 ? false : _options$always;\n\n      if (match == null) {\n        match = function match(n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n\n        var _Editor$parent7 = Editor.parent(editor, path),\n            _Editor$parent8 = _slicedToArray(_Editor$parent7, 1),\n            parent = _Editor$parent8[0];\n\n        match = function match(n) {\n          return n === parent;\n        };\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n\n      var _Editor$nodes11 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      }),\n          _Editor$nodes12 = _slicedToArray(_Editor$nodes11, 1),\n          highest = _Editor$nodes12[0];\n\n      if (!highest) {\n        return;\n      }\n\n      var voidMatch = Editor.void(editor, {\n        at: at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n\n      if (!voids && voidMatch) {\n        var _voidMatch = _slicedToArray(voidMatch, 2),\n            voidNode = _voidMatch[0],\n            voidPath = _voidMatch[1];\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids: voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n\n          at = after;\n          always = true;\n        }\n\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n\n      var afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n\n      var _highest = _slicedToArray(highest, 2),\n          highestPath = _highest[1];\n\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n      var _iterator35 = _createForOfIteratorHelper(Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids: voids\n      })),\n          _step35;\n\n      try {\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          var _step35$value = _slicedToArray(_step35.value, 2),\n              node = _step35$value[0],\n              _path2 = _step35$value[1];\n\n          var split = false;\n\n          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n            break;\n          }\n\n          var _point = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point, _path2);\n\n          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n            split = true;\n            var properties = Node.extractProps(node);\n            editor.apply({\n              type: 'split_node',\n              path: _path2,\n              position: position,\n              properties: properties\n            });\n          }\n\n          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n        }\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n\n        Transforms.select(editor, _point2);\n      }\n\n      beforeRef.unref();\n      afterRef.unref();\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes: function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    var _iterator36 = _createForOfIteratorHelper(props),\n        _step36;\n\n    try {\n      for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n        var key = _step36.value;\n        obj[key] = null;\n      }\n    } catch (err) {\n      _iterator36.e(err);\n    } finally {\n      _iterator36.f();\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes: function unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode12 = options.mode,\n          mode = _options$mode12 === void 0 ? 'lowest' : _options$mode12,\n          _options$split2 = options.split,\n          split = _options$split2 === void 0 ? false : _options$split2,\n          _options$voids16 = options.voids,\n          voids = _options$voids16 === void 0 ? false : _options$voids16;\n      var _options$at13 = options.at,\n          at = _options$at13 === void 0 ? editor.selection : _options$at13,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref5) {\n        var _ref14 = _slicedToArray(_ref5, 2),\n            p = _ref14[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n\n        var _Editor$node5 = Editor.node(editor, path),\n            _Editor$node6 = _slicedToArray(_Editor$node5, 1),\n            node = _Editor$node6[0];\n\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: function match(n) {\n            return Element.isAncestor(node) && node.children.includes(n);\n          },\n          voids: voids\n        });\n      };\n\n      for (var _i4 = 0, _pathRefs4 = pathRefs; _i4 < _pathRefs4.length; _i4++) {\n        var pathRef = _pathRefs4[_i4];\n\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes: function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode13 = options.mode,\n          mode = _options$mode13 === void 0 ? 'lowest' : _options$mode13,\n          _options$split3 = options.split,\n          split = _options$split3 === void 0 ? false : _options$split3,\n          _options$voids17 = options.voids,\n          voids = _options$voids17 === void 0 ? false : _options$voids17;\n      var match = options.match,\n          _options$at14 = options.at,\n          at = _options$at14 === void 0 ? editor.selection : _options$at14;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = function match(n) {\n            return Editor.isInline(editor, n) || Text.isText(n);\n          };\n        } else {\n          match = function match(n) {\n            return Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var _Range$edges33 = Range.edges(at),\n            _Range$edges34 = _slicedToArray(_Range$edges33, 2),\n            start = _Range$edges34[0],\n            end = _Range$edges34[1];\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          voids: voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          voids: voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at: at,\n        match: editor.isInline(element) ? function (n) {\n          return Editor.isBlock(editor, n);\n        } : function (n) {\n          return Editor.isEditor(n);\n        },\n        mode: 'lowest',\n        voids: voids\n      }));\n\n      for (var _i5 = 0, _roots = roots; _i5 < _roots.length; _i5++) {\n        var _roots$_i = _slicedToArray(_roots[_i5], 2),\n            rootPath = _roots$_i[1];\n\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match: match,\n          mode: mode,\n          voids: voids\n        }));\n\n        if (matches.length > 0) {\n          (function () {\n            var _matches = _slicedToArray(matches, 1),\n                first = _matches[0];\n\n            var last = matches[matches.length - 1];\n\n            var _first = _slicedToArray(first, 2),\n                firstPath = _first[1];\n\n            var _last = _slicedToArray(last, 2),\n                lastPath = _last[1];\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n\n            var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1),\n                commonNode = _commonNodeEntry[0];\n\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$7(_objectSpread$7({}, element), {}, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids: voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: function match(n) {\n                return Element.isAncestor(commonNode) && commonNode.children.includes(n);\n              },\n              to: wrapperPath.concat(0),\n              voids: voids\n            });\n          })();\n        }\n      }\n    });\n  }\n};\n\nvar hasSingleChildNest = function hasSingleChildNest(editor, node) {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\n\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges35 = Range.edges(range),\n        _Range$edges36 = _slicedToArray(_Range$edges35, 2),\n        end = _Range$edges36[1];\n\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = function matchPath(editor, path) {\n  var _Editor$node7 = Editor.node(editor, path),\n      _Editor$node8 = _slicedToArray(_Editor$node7, 1),\n      node = _Editor$node8[0];\n\n  return function (n) {\n    return n === node;\n  };\n};\n\nfunction ownKeys$8(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$8(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$8(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$8(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse: function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$edge2 = options.edge,\n        edge = _options$edge2 === void 0 ? 'anchor' : _options$edge2;\n    var selection = editor.selection;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var _Range$edges37 = Range.edges(selection),\n          _Range$edges38 = _slicedToArray(_Range$edges37, 1),\n          start = _Range$edges38[0];\n\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var _Range$edges39 = Range.edges(selection),\n          _Range$edges40 = _slicedToArray(_Range$edges39, 2),\n          end = _Range$edges40[1];\n\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move: function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var selection = editor.selection;\n    var _options$distance3 = options.distance,\n        distance = _options$distance3 === void 0 ? 1 : _options$distance3,\n        _options$unit4 = options.unit,\n        unit = _options$unit4 === void 0 ? 'character' : _options$unit4,\n        _options$reverse9 = options.reverse,\n        reverse = _options$reverse9 === void 0 ? false : _options$reverse9;\n    var _options$edge3 = options.edge,\n        edge = _options$edge3 === void 0 ? null : _options$edge3;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var opts = {\n      distance: distance,\n      unit: unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select: function select(editor, target) {\n    var selection = editor.selection;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(JSON.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint: function setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var selection = editor.selection;\n    var _options$edge4 = options.edge,\n        edge = _options$edge4 === void 0 ? 'both' : _options$edge4;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, _defineProperty2({}, edge === 'anchor' ? 'anchor' : 'focus', _objectSpread$8(_objectSpread$8({}, point), props)));\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection: function setSelection(editor, props) {\n    var selection = editor.selection;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n};\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  delete: function _delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$reverse10 = options.reverse,\n          reverse = _options$reverse10 === void 0 ? false : _options$reverse10,\n          _options$unit5 = options.unit,\n          unit = _options$unit5 === void 0 ? 'character' : _options$unit5,\n          _options$distance4 = options.distance,\n          distance = _options$distance4 === void 0 ? 1 : _options$distance4,\n          _options$voids18 = options.voids,\n          voids = _options$voids18 === void 0 ? false : _options$voids18;\n      var _options$at15 = options.at,\n          at = _options$at15 === void 0 ? editor.selection : _options$at15,\n          _options$hanging5 = options.hanging,\n          hanging = _options$hanging5 === void 0 ? false : _options$hanging5;\n\n      if (!at) {\n        return;\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at: at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var _furthestVoid = _slicedToArray(furthestVoid, 2),\n              voidPath = _furthestVoid[1];\n\n          at = voidPath;\n        } else {\n          var opts = {\n            unit: unit,\n            distance: distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at: at,\n          voids: voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        var _Range$edges41 = Range.edges(at),\n            _Range$edges42 = _slicedToArray(_Range$edges41, 2),\n            _end = _Range$edges42[1];\n\n        var endOfDoc = Editor.end(editor, []);\n\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids: voids\n          });\n        }\n      }\n\n      var _Range$edges43 = Range.edges(at),\n          _Range$edges44 = _slicedToArray(_Range$edges43, 2),\n          start = _Range$edges44[0],\n          end = _Range$edges44[1];\n\n      var startBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: start,\n        voids: voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: end,\n        voids: voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      var _iterator37 = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        voids: voids\n      })),\n          _step37;\n\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var entry = _step37.value;\n\n          var _entry3 = _slicedToArray(entry, 2),\n              node = _entry3[0],\n              path = _entry3[1];\n\n          if (lastPath && Path.compare(path, lastPath) === 0) {\n            continue;\n          }\n\n          if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n            matches.push(entry);\n            lastPath = path;\n          }\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref15 = _slicedToArray(_ref, 2),\n            p = _ref15[1];\n\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n\n        var _Editor$leaf3 = Editor.leaf(editor, _point),\n            _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n            _node = _Editor$leaf4[0];\n\n        var _path = _point.path;\n        var _start = start,\n            offset = _start.offset;\n\n        var text = _node.text.slice(offset);\n\n        if (text.length > 0) editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset: offset,\n          text: text\n        });\n      }\n\n      for (var _i6 = 0, _pathRefs5 = pathRefs; _i6 < _pathRefs5.length; _i6++) {\n        var pathRef = _pathRefs5[_i6];\n\n        var _path2 = pathRef.unref();\n\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids: voids\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n\n        var _Editor$leaf5 = Editor.leaf(editor, _point2),\n            _Editor$leaf6 = _slicedToArray(_Editor$leaf5, 1),\n            _node2 = _Editor$leaf6[0];\n\n        var _path3 = _point2.path;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        if (_text.length > 0) editor.apply({\n          type: 'remove_text',\n          path: _path3,\n          offset: _offset,\n          text: _text\n        });\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids: voids\n        });\n      }\n\n      var point = reverse ? startRef.unref() || endRef.unref() : endRef.unref() || startRef.unref();\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging6 = options.hanging,\n          hanging = _options$hanging6 === void 0 ? false : _options$hanging6,\n          _options$voids19 = options.voids,\n          voids = _options$voids19 === void 0 ? false : _options$voids19;\n      var _options$at16 = options.at,\n          at = _options$at16 === void 0 ? editor.selection : _options$at16;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges45 = Range.edges(at),\n              _Range$edges46 = _slicedToArray(_Range$edges45, 2),\n              end = _Range$edges46[1];\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor.void(editor, {\n        at: at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at: at,\n        match: function match(n) {\n          return Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (inlineElementMatch) {\n        var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2),\n            _inlinePath = _inlineElementMatch[1];\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: at,\n        voids: voids\n      });\n\n      var _blockMatch = _slicedToArray(blockMatch, 2),\n          blockPath = _blockMatch[1];\n\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n\n      var _Node$first5 = Node.first({\n        children: fragment\n      }, []),\n          _Node$first6 = _slicedToArray(_Node$first5, 2),\n          firstPath = _Node$first6[1];\n\n      var _Node$last5 = Node.last({\n        children: fragment\n      }, []),\n          _Node$last6 = _slicedToArray(_Node$last5, 2),\n          lastPath = _Node$last6[1];\n\n      var matches = [];\n\n      var matcher = function matcher(_ref2) {\n        var _ref16 = _slicedToArray(_ref2, 2),\n            n = _ref16[0],\n            p = _ref16[1];\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      var _iterator38 = _createForOfIteratorHelper(Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })),\n          _step38;\n\n      try {\n        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n          var entry = _step38.value;\n\n          if (entry[1].length > 0 && matcher(entry)) {\n            matches.push(entry);\n          }\n        }\n      } catch (err) {\n        _iterator38.e(err);\n      } finally {\n        _iterator38.f();\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var _i7 = 0, _matches2 = matches; _i7 < _matches2.length; _i7++) {\n        var _matches2$_i = _slicedToArray(_matches2[_i7], 1),\n            node = _matches2$_i[0];\n\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var _Editor$nodes13 = Editor.nodes(editor, {\n        at: at,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      }),\n          _Editor$nodes14 = _slicedToArray(_Editor$nodes13, 1),\n          inlineMatch = _Editor$nodes14[0];\n\n      var _inlineMatch = _slicedToArray(inlineMatch, 2),\n          inlinePath = _inlineMatch[1];\n\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at: at,\n        match: function match(n) {\n          return hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids: voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        mode: 'lowest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current);\n        } else {\n          path = Path.previous(startRef.current);\n        }\n\n        var _end2 = Editor.end(editor, path);\n\n        Transforms.select(editor, _end2);\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$voids20 = options.voids,\n          voids = _options$voids20 === void 0 ? false : _options$voids20;\n      var _options$at17 = options.at,\n          at = _options$at17 === void 0 ? editor.selection : _options$at17;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at: at,\n            voids: voids\n          });\n          at = pointRef.unref();\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at: at\n      })) {\n        return;\n      }\n\n      var _at = at,\n          path = _at.path,\n          offset = _at.offset;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys$9(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$9(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$9(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$9(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Transforms = _objectSpread$9(_objectSpread$9(_objectSpread$9(_objectSpread$9({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\nexport { Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, Transforms, createEditor };","map":{"version":3,"sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/utils/weak-maps.ts","../src/create-editor.ts","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../src/utils/string.ts","../src/interfaces/element.ts","../src/interfaces/editor.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/path-ref.ts","../src/interfaces/point.ts","../src/interfaces/point-ref.ts","../src/interfaces/range.ts","../src/interfaces/range-ref.ts","../src/interfaces/text.ts","../src/transforms/general.ts","../src/transforms/node.ts","../src/transforms/selection.ts","../src/transforms/text.ts","../src/transforms/index.ts"],"names":["DIRTY_PATHS","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","createEditor","editor","children","operations","selection","marks","isInline","isVoid","onChange","apply","op","Editor","PathRef","PointRef","RangeRef","set","dirtyPaths","add","path","key","oldDirtyPaths","newDirtyPaths","getDirtyPaths","newPath","Path","Transforms","Promise","addMark","Range","value","match","Text","split","deleteBackward","unit","reverse","deleteForward","deleteFragment","direction","getFragment","Node","insertBreak","always","insertFragment","fragment","insertNode","node","insertText","text","inline","n","mode","point","anchor","focus","normalizeNode","entry","Element","child","at","voids","shouldHaveInlines","i","currentNode","prev","isLast","isInlineOrText","newChild","loose","removeMark","levels","descendants","ancestors","previousPath","oldAncestors","newAncestors","p","newParent","newIndex","resultPath","nextPath","objectWithoutPropertiesLoose","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","ZERO_WIDTH_JOINER","getCharacterDistance","offset","charCode","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","length","started","char","l","rest","isWordCharacter","next","remaining","code","isAncestor","isPlainObject","isElement","isElementList","Array","val","isElementProps","props","matches","element","IS_EDITOR_CACHE","above","options","after","edge","range","distance","d","target","before","edges","end","first","hasBlocks","hasInlines","hasTexts","isBlock","isEditor","cachedIsEditor","Operation","isEnd","Point","isEdge","isEmpty","isNormalizing","isStart","start","last","leaf","isText","block","pointAfterLocation","span","parent","universal","Span","from","to","nodeEntries","pass","isLower","hit","emit","normalize","force","allPaths","dirtyPath","max","m","parentPath","depth","hasPath","pathRef","affinity","ref","current","unref","pathRefs","refs","pointRef","pointRefs","isNewBlock","blockText","leafTextRemaining","leafTextOffset","e","s","reverseText","isFirst","calcDistance","previous","pointBeforeLocation","rangeRef","rangeRefs","string","t","unhangRange","endBlock","blockPath","skip","void","withoutNormalizing","fn","Location","isLocation","isSpan","IS_NODE_LIST_CACHE","ancestor","JSON","c","root","index","childPath","common","descendant","extractProps","properties","newRoot","produce","r","get","has","isNode","isNodeList","cachedResult","visited","nextIndex","isNodeOperation","isOperation","isOperationList","isSelectionOperation","isTextOperation","inverse","type","inversePath","inverseNewPath","newProperties","paths","another","av","bv","compare","min","Math","endsAfter","as","bs","endsAt","endsBefore","equals","hasPrevious","isAfter","isBefore","isChild","isCommon","isDescendant","isParent","isPath","isSibling","al","bl","list","relative","transform","operation","position","onp","copy","result","isPoint","includes","isAfterStart","isBeforeEnd","intersection","isBackward","isCollapsed","isExpanded","isForward","isRange","affinityAnchor","affinityFocus","isEqual","omitText","isTextList","isTextProps","decorations","leaves","o","Object","middle","off","applyToDraft","prevPath","truePath","newNode","GeneralTransforms","createDraft","finishDraft","isDraft","NodeTransforms","insertNodes","hanging","select","nodes","isAtEnd","liftNodes","matchPath","parentNodeEntry","toPath","splitPath","mergeNodes","commonPath","isPreviousSibling","emptyAncestor","hasSingleChildNest","emptyRef","prevNode","moveNodes","toRef","targets","removeNodes","depths","setNodes","splitMode","endAtEndOfNode","startAtStartOfNode","k","splitNodes","height","deleteRange","beforeRef","voidMatch","nudge","afterPath","siblingHeight","voidPath","afterRef","lowestPath","highestPath","unsetNodes","obj","unwrapNodes","wrapNodes","roots","a","commonNodeEntry","wrapperPath","lastPath","wrapper","commonNode","SelectionTransforms","collapse","deselect","move","opts","setPoint","setSelection","oldProps","newProps","TextTransforms","delete","furthestVoid","endOfDoc","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","isInlineStart","isInlineEnd","middleRef"],"mappings":"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","sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Transforms.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: (direction?: 'forward' | 'backward') => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, { reverse: direction === 'backward' })\n      }\n    },\n\n    getFragment: () => {\n      const { selection } = editor\n\n      if (selection) {\n        return Node.fragment(editor, selection)\n      }\n      return []\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const currentNode = Node.get(editor, path)\n        if (Text.isText(currentNode)) continue\n        const child = node.children[i] as Descendant\n        const prev = currentNode.children[n - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          if (!FLUSHING.get(editor)) {\n            editor.onChange()\n          }\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation): Path[] => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      const newParent = newAncestors[newAncestors.length - 1]\n      const newIndex = newPath[newPath.length - 1]\n      const resultPath = newParent.concat(newIndex)\n\n      return [...oldAncestors, ...newAncestors, resultPath]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose.js\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path, Descendant, ExtendedType, Ancestor } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface BaseElement {\n  children: Descendant[]\n}\n\nexport type Element = ExtendedType<'Element', BaseElement>\n\nexport interface ElementInterface {\n  isAncestor: (value: any) => value is Ancestor\n  isElement: (value: any) => value is Element\n  isElementList: (value: any) => value is Element[]\n  isElementProps: (props: any) => props is Partial<Element>\n  matches: (element: Element, props: Partial<Element>) => boolean\n}\n\nexport const Element: ElementInterface = {\n  /**\n   * Check if a value implements the 'Ancestor' interface.\n   */\n\n  isAncestor(value: any): value is Ancestor {\n    return isPlainObject(value) && Node.isNodeList(value.children)\n  },\n\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return Array.isArray(value) && value.every(val => Element.isElement(val))\n  },\n\n  /**\n   * Check if a set of props is a partial of Element.\n   */\n\n  isElementProps(props: any): props is Partial<Element> {\n    return (props as Partial<Element>).children !== undefined\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import isPlainObject from 'is-plain-object'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  ExtendedType,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n  Transforms,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\nimport { Descendant } from './node'\nimport { Element } from './element'\n\nexport type BaseSelection = Range | null\n\nexport type Selection = ExtendedType<'Selection', BaseSelection>\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface BaseEditor {\n  children: Descendant[]\n  selection: Selection\n  operations: Operation[]\n  marks: Omit<Text, 'text'> | null\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: (direction?: 'forward' | 'backward') => void\n  getFragment: () => Descendant[]\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport type Editor = ExtendedType<'Editor', BaseEditor>\n\nexport interface EditorInterface {\n  above: <T extends Ancestor>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  addMark: (editor: Editor, key: string, value: any) => void\n  after: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  before: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    }\n  ) => Point | undefined\n  deleteBackward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteForward: (\n    editor: Editor,\n    options?: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    }\n  ) => void\n  deleteFragment: (\n    editor: Editor,\n    options?: {\n      direction?: 'forward' | 'backward'\n    }\n  ) => void\n  edges: (editor: Editor, at: Location) => [Point, Point]\n  end: (editor: Editor, at: Location) => Point\n  first: (editor: Editor, at: Location) => NodeEntry\n  fragment: (editor: Editor, at: Location) => Descendant[]\n  hasBlocks: (editor: Editor, element: Element) => boolean\n  hasInlines: (editor: Editor, element: Element) => boolean\n  hasPath: (editor: Editor, path: Path) => boolean\n  hasTexts: (editor: Editor, element: Element) => boolean\n  insertBreak: (editor: Editor) => void\n  insertFragment: (editor: Editor, fragment: Node[]) => void\n  insertNode: (editor: Editor, node: Node) => void\n  insertText: (editor: Editor, text: string) => void\n  isBlock: (editor: Editor, value: any) => value is Element\n  isEditor: (value: any) => value is Editor\n  isEnd: (editor: Editor, point: Point, at: Location) => boolean\n  isEdge: (editor: Editor, point: Point, at: Location) => boolean\n  isEmpty: (editor: Editor, element: Element) => boolean\n  isInline: (editor: Editor, value: any) => value is Element\n  isNormalizing: (editor: Editor) => boolean\n  isStart: (editor: Editor, point: Point, at: Location) => boolean\n  isVoid: (editor: Editor, value: any) => value is Element\n  last: (editor: Editor, at: Location) => NodeEntry\n  leaf: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Text>\n  levels: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  marks: (editor: Editor) => Omit<Text, 'text'> | null\n  next: <T extends Descendant>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  node: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry\n  nodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<NodeEntry<T>, void, undefined>\n  normalize: (\n    editor: Editor,\n    options?: {\n      force?: boolean\n    }\n  ) => void\n  parent: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => NodeEntry<Ancestor>\n  path: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      depth?: number\n      edge?: 'start' | 'end'\n    }\n  ) => Path\n  pathRef: (\n    editor: Editor,\n    path: Path,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PathRef\n  pathRefs: (editor: Editor) => Set<PathRef>\n  point: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      edge?: 'start' | 'end'\n    }\n  ) => Point\n  pointRef: (\n    editor: Editor,\n    point: Point,\n    options?: {\n      affinity?: 'backward' | 'forward' | null\n    }\n  ) => PointRef\n  pointRefs: (editor: Editor) => Set<PointRef>\n  positions: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    }\n  ) => Generator<Point, void, undefined>\n  previous: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<T> | undefined\n  range: (editor: Editor, at: Location, to?: Location) => Range\n  rangeRef: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    }\n  ) => RangeRef\n  rangeRefs: (editor: Editor) => Set<RangeRef>\n  removeMark: (editor: Editor, key: string) => void\n  start: (editor: Editor, at: Location) => Point\n  string: (\n    editor: Editor,\n    at: Location,\n    options?: {\n      voids?: boolean\n    }\n  ) => string\n  unhangRange: (\n    editor: Editor,\n    range: Range,\n    options?: {\n      voids?: boolean\n    }\n  ) => Range\n  void: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => NodeEntry<Element> | undefined\n  withoutNormalizing: (editor: Editor, fn: () => void) => void\n}\n\nconst IS_EDITOR_CACHE = new WeakMap<object, boolean>()\n\nexport const Editor: EditorInterface = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      voids?: boolean\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(\n    editor: Editor,\n    options: {\n      direction?: 'forward' | 'backward'\n    } = {}\n  ): void {\n    const { direction = 'forward' } = options\n    editor.deleteFragment(direction)\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    if (!isPlainObject(value)) return false\n    const cachedIsEditor = IS_EDITOR_CACHE.get(value)\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor\n    }\n    const isEditor =\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    IS_EDITOR_CACHE.set(value, isEditor)\n    return isEditor\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Omit<Text, 'text'> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Descendant>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointAfterLocation = Editor.after(editor, at, { voids })\n\n    if (!pointAfterLocation) return\n\n    const [, to] = Editor.last(editor, [])\n\n    const span: Span = [pointAfterLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<NodeEntry<T>, void, undefined> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of nodeEntries) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ): void {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      /*\n        Fix dirty elements with no children.\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\n        Running an initial pass avoids the catch-22 race condition.\n      */\n      for (const dirtyPath of getDirtyPaths(editor)) {\n        if (Node.has(editor, dirtyPath)) {\n          const [node, _] = Editor.node(editor, dirtyPath)\n\n          // Add a text child to elements with no children.\n          // This is safe to do in any order, by definition it can't cause other paths to change.\n          if (Element.isElement(node) && node.children.length === 0) {\n            const child = { text: '' }\n            Transforms.insertNodes(editor, child, {\n              at: dirtyPath.concat(0),\n              voids: true,\n            })\n          }\n        }\n      }\n\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const dirtyPath = getDirtyPaths(editor).pop()!\n\n        // If the node doesn't exist in the tree, it does not need to be normalized.\n        if (Node.has(editor, dirtyPath)) {\n          const entry = Editor.node(editor, dirtyPath)\n          editor.normalizeNode(entry)\n        }\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  hasPath(editor: Editor, path: Path): boolean {\n    return Node.has(editor, path)\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Return all the positions in `at` range where a `Point` can be placed.\n   *\n   * By default, moves forward by individual offsets at a time, but\n   * the `unit` option can be used to to move by character, word, line, or block.\n   *\n   * The `reverse` option can be used to change iteration direction.\n   *\n   * Note: By default void nodes are treated as a single point and iteration\n   * will not happen inside their content unless you pass in true for the\n   * `voids` option, then iteration will occur.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Generator<Point, void, undefined> {\n    const {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    /**\n     * Algorithm notes:\n     *\n     * Each step `distance` is dynamic depending on the underlying text\n     * and the `unit` specified.  Each step, e.g., a line or word, may\n     * span multiple text nodes, so we iterate through the text both on\n     * two levels in step-sync:\n     *\n     * `leafText` stores the text on a text leaf level, and is advanced\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\n     *\n     * `blockText` stores the text on a block level, and is shortened\n     * by `distance` every time it is advanced.\n     *\n     * We only maintain a window of one blockText and one leafText because\n     * a block node always appears before all of its leaf nodes.\n     */\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let isNewBlock = false\n    let blockText = ''\n    let distance = 0 // Distance for leafText to catch up to blockText.\n    let leafTextRemaining = 0\n    let leafTextOffset = 0\n\n    // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n    for (const [node, path] of Editor.nodes(editor, { at, reverse, voids })) {\n      /*\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n        if (editor.isInline(node)) continue\n\n        // Block element node - set `blockText` to its text content.\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          blockText = Editor.string(editor, { anchor: s, focus: e }, { voids })\n          blockText = reverse ? reverseText(blockText) : blockText\n          isNewBlock = true\n        }\n      }\n\n      /*\n       * TEXT LEAF NODE - Iterate through text content, yielding\n       * positions every `distance` offset according to `unit`.\n       */\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n\n        // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n\n        // Reset `leafText` counters for new text node.\n        if (isFirst) {\n          leafTextRemaining = reverse\n            ? first.offset\n            : node.text.length - first.offset\n          leafTextOffset = first.offset // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length\n          leafTextOffset = reverse ? leafTextRemaining : 0\n        }\n\n        // Yield position at the start of node (potentially).\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset: leafTextOffset }\n          isNewBlock = false\n        }\n\n        // Yield positions every (dynamically calculated) `distance` offset.\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break\n            distance = calcDistance(blockText, unit)\n            blockText = blockText.slice(distance)\n          }\n\n          // Advance `leafText` by the current `distance`.\n          leafTextOffset = reverse\n            ? leafTextOffset - distance\n            : leafTextOffset + distance\n          leafTextRemaining = leafTextRemaining - distance\n\n          // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining\n            break\n          }\n\n          // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n          distance = 0\n          yield { path, offset: leafTextOffset }\n        }\n      }\n    }\n    // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n    function calcDistance(text: string, unit: string) {\n      if (unit === 'character') {\n        return getCharacterDistance(text)\n      } else if (unit === 'word') {\n        return getWordDistance(text)\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length\n      }\n      return 1\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const pointBeforeLocation = Editor.before(editor, at, { voids })\n\n    if (!pointBeforeLocation) {\n      return\n    }\n\n    const [, to] = Editor.first(editor, [])\n\n    // The search location is from the start of the document to the path of\n    // the point before the location passed in\n    const span: Span = [pointBeforeLocation.path, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: by default the text of void nodes is considered to be an empty\n   * string, regardless of content, unless you pass in true for the voids option\n   */\n\n  string(\n    editor: Editor,\n    at: Location,\n    options: {\n      voids?: boolean\n    } = {}\n  ): string {\n    const { voids = false } = options\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    try {\n      fn()\n    } finally {\n      NORMALIZING.set(editor, value)\n    }\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\nexport type NodeMatch<T extends Node> =\n  | ((node: Node, path: Path) => node is T)\n  | ((node: Node, path: Path) => boolean)\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport interface LocationInterface {\n  isLocation: (value: any) => value is Location\n}\n\nexport const Location: LocationInterface = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport interface SpanInterface {\n  isSpan: (value: any) => value is Span\n}\n\nexport const Span: SpanInterface = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Path, Range, Text } from '..'\nimport { Element, ElementEntry } from './element'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type BaseNode = Editor | Element | Text\nexport type Node = Editor | Element | Text\n\nexport interface NodeInterface {\n  ancestor: (root: Node, path: Path) => Ancestor\n  ancestors: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Ancestor>, void, undefined>\n  child: (root: Node, index: number) => Descendant\n  children: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  common: (root: Node, path: Path, another: Path) => NodeEntry\n  descendant: (root: Node, path: Path) => Descendant\n  descendants: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Descendant>, void, undefined>\n  elements: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<ElementEntry, void, undefined>\n  extractProps: (node: Node) => NodeProps\n  first: (root: Node, path: Path) => NodeEntry\n  fragment: (root: Node, range: Range) => Descendant[]\n  get: (root: Node, path: Path) => Node\n  has: (root: Node, path: Path) => boolean\n  isNode: (value: any) => value is Node\n  isNodeList: (value: any) => value is Node[]\n  last: (root: Node, path: Path) => NodeEntry\n  leaf: (root: Node, path: Path) => Text\n  levels: (\n    root: Node,\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  matches: (node: Node, props: Partial<Node>) => boolean\n  nodes: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry, void, undefined>\n  parent: (root: Node, path: Path) => Ancestor\n  string: (node: Node) => string\n  texts: (\n    root: Node,\n    options?: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    }\n  ) => Generator<NodeEntry<Text>, void, undefined>\n}\n\nconst IS_NODE_LIST_CACHE = new WeakMap<any[], boolean>()\n\nexport const Node: NodeInterface = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Ancestor>, void, undefined> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Descendant>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return a generator of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<ElementEntry, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Extract props from a Node.\n   */\n\n  extractProps(node: Node): NodeProps {\n    if (Element.isAncestor(node)) {\n      const { children, ...properties } = node\n\n      return properties\n    } else {\n      const { text, ...properties } = node\n\n      return properties\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce({ children: root.children }, r => {\n      const [start, end] = Range.edges(range)\n      const nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null\n      }\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    if (!Array.isArray(value)) {\n      return false\n    }\n    const cachedResult = IS_NODE_LIST_CACHE.get(value)\n    if (cachedResult !== undefined) {\n      return cachedResult\n    }\n    const isNodeList = value.every(val => Node.isNode(val))\n    IS_NODE_LIST_CACHE.set(value, isNodeList)\n    return isNodeList\n  },\n\n  /**\n   * Get the last node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return a generator of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) &&\n        Element.isElementProps(props) &&\n        Element.matches(node, props)) ||\n      (Text.isText(node) &&\n        Text.isTextProps(props) &&\n        Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return a generator of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry, void, undefined> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't descended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return a generator of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Generator<NodeEntry<Text>, void, undefined> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n\n/**\n * Convenience type for returning the props of a node.\n */\nexport type NodeProps =\n  | Omit<Editor, 'children'>\n  | Omit<Element, 'children'>\n  | Omit<Text, 'text'>\n","import { ExtendedType, Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type BaseInsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n}\n\nexport type InsertNodeOperation = ExtendedType<\n  'InsertNodeOperation',\n  BaseInsertNodeOperation\n>\n\nexport type BaseInsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type InsertTextOperation = ExtendedType<\n  'InsertTextOperation',\n  BaseInsertTextOperation\n>\n\nexport type BaseMergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type MergeNodeOperation = ExtendedType<\n  'MergeNodeOperation',\n  BaseMergeNodeOperation\n>\n\nexport type BaseMoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n}\n\nexport type MoveNodeOperation = ExtendedType<\n  'MoveNodeOperation',\n  BaseMoveNodeOperation\n>\n\nexport type BaseRemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n}\n\nexport type RemoveNodeOperation = ExtendedType<\n  'RemoveNodeOperation',\n  BaseRemoveNodeOperation\n>\n\nexport type BaseRemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n}\n\nexport type RemoveTextOperation = ExtendedType<\n  'RemoveTextOperation',\n  BaseRemoveTextOperation\n>\n\nexport type BaseSetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n}\n\nexport type SetNodeOperation = ExtendedType<\n  'SetNodeOperation',\n  BaseSetNodeOperation\n>\n\nexport type BaseSetSelectionOperation =\n  | {\n      type: 'set_selection'\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      properties: Range\n      newProperties: null\n    }\n\nexport type SetSelectionOperation = ExtendedType<\n  'SetSelectionOperation',\n  BaseSetSelectionOperation\n>\n\nexport type BaseSplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n}\n\nexport type SplitNodeOperation = ExtendedType<\n  'SplitNodeOperation',\n  BaseSplitNodeOperation\n>\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport interface OperationInterface {\n  isNodeOperation: (value: any) => value is NodeOperation\n  isOperation: (value: any) => value is Operation\n  isOperationList: (value: any) => value is Operation[]\n  isSelectionOperation: (value: any) => value is SelectionOperation\n  isTextOperation: (value: any) => value is TextOperation\n  inverse: (op: Operation) => Operation\n}\n\nexport const Operation: OperationInterface = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) && value.every(val => Operation.isOperation(val))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport interface PathInterface {\n  ancestors: (path: Path, options?: { reverse?: boolean }) => Path[]\n  common: (path: Path, another: Path) => Path\n  compare: (path: Path, another: Path) => -1 | 0 | 1\n  endsAfter: (path: Path, another: Path) => boolean\n  endsAt: (path: Path, another: Path) => boolean\n  endsBefore: (path: Path, another: Path) => boolean\n  equals: (path: Path, another: Path) => boolean\n  hasPrevious: (path: Path) => boolean\n  isAfter: (path: Path, another: Path) => boolean\n  isAncestor: (path: Path, another: Path) => boolean\n  isBefore: (path: Path, another: Path) => boolean\n  isChild: (path: Path, another: Path) => boolean\n  isCommon: (path: Path, another: Path) => boolean\n  isDescendant: (path: Path, another: Path) => boolean\n  isParent: (path: Path, another: Path) => boolean\n  isPath: (value: any) => value is Path\n  isSibling: (path: Path, another: Path) => boolean\n  levels: (\n    path: Path,\n    options?: {\n      reverse?: boolean\n    }\n  ) => Path[]\n  next: (path: Path) => Path\n  parent: (path: Path) => Path\n  previous: (path: Path) => Path\n  relative: (path: Path, ancestor: Path) => Path\n  transform: (\n    path: Path,\n    operation: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Path | null\n}\n\nexport const Path: PathInterface = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if the path of previous sibling node exists\n   */\n\n  hasPrevious(path: Path): boolean {\n    return path[path.length - 1] > 0\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              copy[op.length - 1] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.isSibling(op, onp) &&\n            (Path.isAncestor(onp, p) || Path.equals(onp, p))\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            } else {\n              p[op.length - 1] += 1\n            }\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport interface PathRefInterface {\n  transform: (ref: PathRef, op: Operation) => void\n}\n\nexport const PathRef: PathRefInterface = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { ExtendedType, Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface BasePoint {\n  path: Path\n  offset: number\n}\n\nexport type Point = ExtendedType<'Point', BasePoint>\n\nexport interface PointInterface {\n  compare: (point: Point, another: Point) => -1 | 0 | 1\n  isAfter: (point: Point, another: Point) => boolean\n  isBefore: (point: Point, another: Point) => boolean\n  equals: (point: Point, another: Point) => boolean\n  isPoint: (value: any) => value is Point\n  transform: (\n    point: Point,\n    op: Operation,\n    options?: { affinity?: 'forward' | 'backward' | null }\n  ) => Point | null\n}\n\nexport const Point: PointInterface = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport interface PointRefInterface {\n  transform: (ref: PointRef, op: Operation) => void\n}\n\nexport const PointRef: PointRefInterface = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { ExtendedType, Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface BaseRange {\n  anchor: Point\n  focus: Point\n}\n\nexport type Range = ExtendedType<'Range', BaseRange>\n\nexport interface RangeInterface {\n  edges: (\n    range: Range,\n    options?: {\n      reverse?: boolean\n    }\n  ) => [Point, Point]\n  end: (range: Range) => Point\n  equals: (range: Range, another: Range) => boolean\n  includes: (range: Range, target: Path | Point | Range) => boolean\n  intersection: (range: Range, another: Range) => Range | null\n  isBackward: (range: Range) => boolean\n  isCollapsed: (range: Range) => boolean\n  isExpanded: (range: Range) => boolean\n  isForward: (range: Range) => boolean\n  isRange: (value: any) => value is Range\n  points: (range: Range) => Generator<PointEntry, void, undefined>\n  start: (range: Range) => Point\n  transform: (\n    range: Range,\n    op: Operation,\n    options?: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    }\n  ) => Range | null\n}\n\nexport const Range: RangeInterface = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Generator<PointEntry, void, undefined> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: {\n      affinity?: 'forward' | 'backward' | 'outward' | 'inward' | null\n    } = {}\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport interface RangeRefInterface {\n  transform: (ref: RangeRef, op: Operation) => void\n}\n\nexport const RangeRef: RangeRefInterface = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport isEqual from 'fast-deep-equal'\nimport { Range } from '..'\nimport { ExtendedType } from './custom-types'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface BaseText {\n  text: string\n}\n\nexport type Text = ExtendedType<'Text', BaseText>\n\nexport interface TextInterface {\n  equals: (text: Text, another: Text, options?: { loose?: boolean }) => boolean\n  isText: (value: any) => value is Text\n  isTextList: (value: any) => value is Text[]\n  isTextProps: (props: any) => props is Partial<Text>\n  matches: (text: Text, props: Partial<Text>) => boolean\n  decorations: (node: Text, decorations: Range[]) => Text[]\n}\n\nexport const Text: TextInterface = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    function omitText(obj: Record<any, any>) {\n      const { text, ...rest } = obj\n\n      return rest\n    }\n\n    return isEqual(\n      loose ? omitText(text) : text,\n      loose ? omitText(another) : another\n    )\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && value.every(val => Text.isText(val))\n  },\n\n  /**\n   * Check if some props are a partial of Text.\n   */\n\n  isTextProps(props: any): props is Partial<Text> {\n    return (props as Partial<Text>).text !== undefined\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= o) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n        if (\n          (start.offset !== end.offset &&\n            (start.offset === o || end.offset === offset)) ||\n          start.offset > o ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < o) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Selection,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Ancestor,\n} from '..'\n\nexport interface GeneralTransforms {\n  transform: (editor: Editor, op: Operation) => void\n}\n\nconst applyToDraft = (editor: Editor, selection: Selection, op: Operation) => {\n  switch (op.type) {\n    case 'insert_node': {\n      const { path, node } = op\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (index > parent.children.length) {\n        throw new Error(\n          `Cannot apply an \"insert_node\" operation at path [${path}] because the destination is past the end of the node.`\n        )\n      }\n\n      parent.children.splice(index, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'insert_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset)\n      node.text = before + text + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const node = Node.get(editor, path)\n      const prevPath = Path.previous(path)\n      const prev = Node.get(editor, prevPath)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      if (Text.isText(node) && Text.isText(prev)) {\n        prev.text += node.text\n      } else if (!Text.isText(node) && !Text.isText(prev)) {\n        prev.children.push(...node.children)\n      } else {\n        throw new Error(\n          `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interfaces: ${node} ${prev}`\n        )\n      }\n\n      parent.children.splice(index, 1)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.isAncestor(path, newPath)) {\n        throw new Error(\n          `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n\n      // This is tricky, but since the `path` and `newPath` both refer to\n      // the same snapshot in time, there's a mismatch. After either\n      // removing the original position, the second step's path can be out\n      // of date. So instead of using the `op.newPath` directly, we\n      // transform `op.path` to ascertain what the `newPath` would be after\n      // the operation was applied.\n      parent.children.splice(index, 1)\n      const truePath = Path.transform(path, op)!\n      const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n      const newIndex = truePath[truePath.length - 1]\n\n      newParent.children.splice(newIndex, 0, node)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const index = path[path.length - 1]\n      const parent = Node.parent(editor, path)\n      parent.children.splice(index, 1)\n\n      // Transform all of the points in the value, but if the point was in the\n      // node that was removed we need to update the range or remove it.\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          const result = Point.transform(point, op)\n\n          if (selection != null && result != null) {\n            selection[key] = result\n          } else {\n            let prev: NodeEntry<Text> | undefined\n            let next: NodeEntry<Text> | undefined\n\n            for (const [n, p] of Node.texts(editor)) {\n              if (Path.compare(p, path) === -1) {\n                prev = [n, p]\n              } else {\n                next = [n, p]\n                break\n              }\n            }\n\n            if (prev) {\n              point.path = prev[1]\n              point.offset = prev[0].text.length\n            } else if (next) {\n              point.path = next[1]\n              point.offset = 0\n            } else {\n              selection = null\n            }\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      if (text.length === 0) break\n      const node = Node.leaf(editor, path)\n      const before = node.text.slice(0, offset)\n      const after = node.text.slice(offset + text.length)\n      node.text = before + after\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n\n    case 'set_node': {\n      const { path, properties, newProperties } = op\n\n      if (path.length === 0) {\n        throw new Error(`Cannot set properties on the root node!`)\n      }\n\n      const node = Node.get(editor, path)\n\n      for (const key in newProperties) {\n        if (key === 'children' || key === 'text') {\n          throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n        }\n\n        const value = newProperties[key]\n\n        if (value == null) {\n          delete node[key]\n        } else {\n          node[key] = value\n        }\n      }\n\n      // properties that were previously defined, but are now missing, must be deleted\n      for (const key in properties) {\n        if (!newProperties.hasOwnProperty(key)) {\n          delete node[key]\n        }\n      }\n\n      break\n    }\n\n    case 'set_selection': {\n      const { newProperties } = op\n\n      if (newProperties == null) {\n        selection = newProperties\n      } else {\n        if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = { ...newProperties }\n        }\n\n        for (const key in newProperties) {\n          const value = newProperties[key]\n\n          if (value == null) {\n            if (key === 'anchor' || key === 'focus') {\n              throw new Error(`Cannot remove the \"${key}\" selection property`)\n            }\n\n            delete selection[key]\n          } else {\n            selection[key] = value\n          }\n        }\n      }\n\n      break\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n\n      if (path.length === 0) {\n        throw new Error(\n          `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n        )\n      }\n\n      const node = Node.get(editor, path)\n      const parent = Node.parent(editor, path)\n      const index = path[path.length - 1]\n      let newNode: Descendant\n\n      if (Text.isText(node)) {\n        const before = node.text.slice(0, position)\n        const after = node.text.slice(position)\n        node.text = before\n        newNode = {\n          ...(properties as Partial<Text>),\n          text: after,\n        }\n      } else {\n        const before = node.children.slice(0, position)\n        const after = node.children.slice(position)\n        node.children = before\n\n        newNode = {\n          ...(properties as Partial<Element>),\n          children: after,\n        }\n      }\n\n      parent.children.splice(index + 1, 0, newNode)\n\n      if (selection) {\n        for (const [point, key] of Range.points(selection)) {\n          selection[key] = Point.transform(point, op)!\n        }\n      }\n\n      break\n    }\n  }\n  return selection\n}\n\nexport const GeneralTransforms: GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation): void {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    try {\n      selection = applyToDraft(editor, selection, op)\n    } finally {\n      editor.children = finishDraft(editor.children)\n\n      if (selection) {\n        editor.selection = isDraft(selection)\n          ? (finishDraft(selection) as Range)\n          : selection\n      } else {\n        editor.selection = null\n      }\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n  NodeEntry,\n  Ancestor,\n} from '..'\nimport { NodeMatch } from '../interfaces/editor'\n\nexport interface NodeTransforms {\n  insertNodes: <T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    }\n  ) => void\n  liftNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    }\n  ) => void\n  mergeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  moveNodes: <T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) => void\n  removeNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  setNodes: <T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  splitNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    }\n  ) => void\n  unsetNodes: <T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  unwrapNodes: <T extends Node>(\n    editor: Editor,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n  wrapNodes: <T extends Node>(\n    editor: Editor,\n    element: Element,\n    options?: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const NodeTransforms: NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes<T extends Node>(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const parentNodeEntry = Editor.node(editor, Path.parent(path))\n        const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n),\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n\n        if (\n          toRef.current &&\n          Path.isSibling(newPath, path) &&\n          Path.isAfter(newPath, path)\n        ) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current)\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes<T extends Node>(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        const endAtEndOfNode = Editor.isEnd(editor, end, end.path)\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode,\n        })\n        const startAtStartOfNode = Editor.isStart(editor, start, start.path)\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            // Omit new properties from the old property list rather than set them to undefined\n            if (node.hasOwnProperty(k)) properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const properties = Node.extractProps(node)\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes<T extends Node>(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path)\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes<T extends Node>(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'lowest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const commonNodeEntry = Editor.node(editor, commonPath)\n          const [commonNode] = commonNodeEntry\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n =>\n              Element.isAncestor(commonNode) && commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\nconst hasSingleChildNest = (editor: Editor, node: Node): boolean => {\n  if (Element.isElement(node)) {\n    const element = node as Element\n    if (Editor.isVoid(editor, node)) {\n      return true\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0])\n    } else {\n      return false\n    }\n  } else if (Editor.isEditor(node)) {\n    return false\n  } else {\n    return true\n  }\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport interface SelectionTransforms {\n  collapse: (\n    editor: Editor,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  deselect: (editor: Editor) => void\n  move: (\n    editor: Editor,\n    options?: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  select: (editor: Editor, target: Location) => void\n  setPoint: (\n    editor: Editor,\n    props: Partial<Point>,\n    options?: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) => void\n  setSelection: (editor: Editor, props: Partial<Range>) => void\n}\n\nexport const SelectionTransforms: SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor): void {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location): void {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ): void {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n    })\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>): void {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport interface TextTransforms {\n  delete: (\n    editor: Editor,\n    options?: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertFragment: (\n    editor: Editor,\n    fragment: Node[],\n    options?: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    }\n  ) => void\n  insertText: (\n    editor: Editor,\n    text: string,\n    options?: {\n      at?: Location\n      voids?: boolean\n    }\n  ) => void\n}\n\nexport const TextTransforms: TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        const [, end] = Range.edges(at)\n        const endOfDoc = Editor.end(editor, [])\n\n        if (!Point.equals(end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, { voids })\n        }\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        if (text.length > 0)\n          editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = reverse\n        ? startRef.unref() || endRef.unref()\n        : endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ): void {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      if (text.length > 0)\n        editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms: GeneralTransforms &\n  NodeTransforms &\n  SelectionTransforms &\n  TextTransforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n"]},"metadata":{},"sourceType":"module"}
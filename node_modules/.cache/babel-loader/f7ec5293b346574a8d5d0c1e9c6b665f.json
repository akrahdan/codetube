{"ast":null,"code":"var _jsxFileName = \"/Users/akrah/Documents/dev/codefluent/src/components/overrides/Markdown/libs/overrides/index.tsx\";\nimport HtmlToReact from 'html-to-react';\nimport camelCaseMap from 'html-to-react/lib/camel-case-attribute-names';\nimport { get } from 'lodash';\nimport React from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions();\n// Mapping of html attributes to their camelCase variants\nconst attributeMap = { ...camelCaseMap,\n  for: 'htmlFor',\n  class: 'className'\n};\n\nconst processAttributeValue = value => {\n  if (value === 'true') {\n    return true;\n  }\n\n  if (value === 'false') {\n    return false;\n  }\n\n  return value || true;\n}; // Convert html attributes to valid react props\n\n\nexport const processAttributes = (attributes = {}) => Object.keys(attributes).reduce((acc, attr) => {\n  const reactAttr = attributeMap[attr.replace(/[-:]/, '')] || attr;\n  return { ...acc,\n    [reactAttr]: processAttributeValue(attributes[attr])\n  };\n}, {}); // generic html tag override\n\nexport const createTagOverride = (tagName, Override) => ({\n  shouldProcessNode(node) {\n    if (!Override) return false;\n\n    if (Override.shouldProcessNode) {\n      return Override.shouldProcessNode(node);\n    }\n\n    return node.name === tagName.toLowerCase();\n  },\n\n  processNode(node, children, key) {\n    if (!Override) return null;\n    const props = { ...processAttributes(node.attribs),\n      children,\n      key\n    };\n\n    if (Override.processNode) {\n      return Override.processNode(node, props);\n    }\n\n    if (!Override.component) return null;\n    return /*#__PURE__*/_jsxDEV(Override.component, { ...props\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 12\n    }, this);\n  }\n\n}); // Allows <CodeBlock></CodeBlock> override and overrides of standard fenced codeblocks\n\nexport const createCodeBlockOverride = (tagName, Override) => createTagOverride(tagName, {\n  shouldProcessNode(node) {\n    return node.name === 'code' && get(node, 'parent.name') === 'pre' || node.name === tagName.toLowerCase();\n  },\n\n  processNode(node, props) {\n    var _props$className, _props$children;\n\n    const [, language = undefined] = ((_props$className = props.className) === null || _props$className === void 0 ? void 0 : _props$className.match(/language-([^\\s]+)/)) || [];\n    if (!Override.component) return null;\n    return /*#__PURE__*/_jsxDEV(Override.component, { ...props,\n      language: language,\n      children: (_props$children = props.children) === null || _props$children === void 0 ? void 0 : _props$children[0]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 9\n    }, this);\n  },\n\n  ...Override\n});\n\nconst processText = text => {\n  // Replace &mdash; due to legacy markdown that didn't use smart dashes\n  return text.replace(/&mdash;/g, '\\u2014');\n};\n\nexport const standardOverrides = [{\n  shouldProcessNode(node) {\n    // Parse text outside of code blocks\n    if (node.parent && ['code', 'pre'].indexOf(node.parent.name) >= 0) {\n      return false;\n    }\n\n    if (node.type === 'text') return true;\n    return false;\n  },\n\n  processNode(node) {\n    return processText(node.data);\n  }\n\n}, {\n  shouldProcessNode() {\n    return true;\n  },\n\n  processNode: processNodeDefinitions.processDefaultNode\n}];","map":{"version":3,"sources":["/Users/akrah/Documents/dev/codefluent/src/components/overrides/Markdown/libs/overrides/index.tsx"],"names":["HtmlToReact","camelCaseMap","get","React","processNodeDefinitions","ProcessNodeDefinitions","attributeMap","for","class","processAttributeValue","value","processAttributes","attributes","Object","keys","reduce","acc","attr","reactAttr","replace","createTagOverride","tagName","Override","shouldProcessNode","node","name","toLowerCase","processNode","children","key","props","attribs","component","createCodeBlockOverride","language","undefined","className","match","processText","text","standardOverrides","parent","indexOf","type","data","processDefaultNode"],"mappings":"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","sourcesContent":["import HtmlToReact from 'html-to-react';\nimport camelCaseMap from 'html-to-react/lib/camel-case-attribute-names';\nimport { get } from 'lodash';\nimport React from 'react';\n\nconst processNodeDefinitions = new HtmlToReact.ProcessNodeDefinitions();\n\nexport interface AttributesMap {\n  [key: string]: string | boolean;\n}\n\nexport interface HTMLToReactNode {\n  data: string;\n  type: string;\n  name?: string;\n  children?: HTMLToReactNode[];\n  attribs?: any;\n  next: HTMLToReactNode;\n  prev: HTMLToReactNode;\n  parent: HTMLToReactNode;\n}\n\n// Mapping of html attributes to their camelCase variants\nconst attributeMap: { [key: string]: string } = {\n  ...camelCaseMap,\n  for: 'htmlFor',\n  class: 'className',\n};\n\nexport type OverrideSettingsBase = {\n  component?: React.ComponentType<any>;\n  allowedAttributes?: string[];\n  processNode?: (node: HTMLToReactNode, props: object) => React.ReactNode;\n  shouldProcessNode?: (node: HTMLToReactNode) => boolean;\n};\n\nexport interface OverrideSettingsComponent extends OverrideSettingsBase {\n  component: React.ComponentType<any>;\n}\n\nexport interface OverrideSettingsProcessNode extends OverrideSettingsBase {\n  processNode: (node: HTMLToReactNode, props: object) => React.ReactNode;\n}\n\nexport type OverrideSettings =\n  | OverrideSettingsComponent\n  | OverrideSettingsProcessNode;\n\nexport type ManyOverrideSettings = {\n  [i: string]: OverrideSettings;\n};\n\nconst processAttributeValue = (value: string | boolean) => {\n  if (value === 'true') {\n    return true;\n  }\n\n  if (value === 'false') {\n    return false;\n  }\n\n  return value || true;\n};\n\n// Convert html attributes to valid react props\nexport const processAttributes = (attributes: AttributesMap = {}) =>\n  Object.keys(attributes).reduce((acc, attr) => {\n    const reactAttr = attributeMap[attr.replace(/[-:]/, '')] || attr;\n\n    return {\n      ...acc,\n      [reactAttr]: processAttributeValue(attributes[attr]),\n    };\n  }, {});\n\n// generic html tag override\nexport const createTagOverride = (\n  tagName: string,\n  Override: OverrideSettings\n) => ({\n  shouldProcessNode(node: HTMLToReactNode) {\n    if (!Override) return false;\n\n    if (Override.shouldProcessNode) {\n      return Override.shouldProcessNode(node);\n    }\n    return node.name === tagName.toLowerCase();\n  },\n  processNode(\n    node: HTMLToReactNode,\n    children: HTMLToReactNode[],\n    key: React.Key\n  ) {\n    if (!Override) return null;\n\n    const props = {\n      ...processAttributes(node.attribs),\n      children,\n      key,\n    };\n\n    if (Override.processNode) {\n      return Override.processNode(node, props);\n    }\n\n    if (!Override.component) return null;\n\n    return <Override.component {...props} />;\n  },\n});\n\n// Allows <CodeBlock></CodeBlock> override and overrides of standard fenced codeblocks\nexport const createCodeBlockOverride = (\n  tagName: string,\n  Override: OverrideSettings\n) =>\n  createTagOverride(tagName, {\n    shouldProcessNode(node: HTMLToReactNode) {\n      return (\n        (node.name === 'code' && get(node, 'parent.name') === 'pre') ||\n        node.name === tagName.toLowerCase()\n      );\n    },\n\n    processNode(node: HTMLToReactNode, props: any) {\n      const [, language = undefined] =\n        props.className?.match(/language-([^\\s]+)/) || [];\n\n      if (!Override.component) return null;\n\n      return (\n        <Override.component {...props} language={language}>\n          {props.children?.[0]}\n        </Override.component>\n      );\n    },\n    ...Override,\n  });\n\nconst processText = (text: string) => {\n  // Replace &mdash; due to legacy markdown that didn't use smart dashes\n  return text.replace(/&mdash;/g, '\\u2014');\n};\n\nexport const standardOverrides = [\n  {\n    shouldProcessNode(node: HTMLToReactNode) {\n      // Parse text outside of code blocks\n      if (node.parent && ['code', 'pre'].indexOf(node.parent.name!) >= 0) {\n        return false;\n      }\n      if (node.type === 'text') return true;\n      return false;\n    },\n    processNode(node: HTMLToReactNode) {\n      return processText(node.data);\n    },\n  },\n  {\n    shouldProcessNode() {\n      return true;\n    },\n    processNode: processNodeDefinitions.processDefaultNode,\n  },\n];\n"]},"metadata":{},"sourceType":"module"}
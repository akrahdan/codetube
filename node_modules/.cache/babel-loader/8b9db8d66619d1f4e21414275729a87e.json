{"ast":null,"code":"import _slicedToArray from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _createForOfIteratorHelper from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _inherits from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _classCallCheck from \"/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport isPlainObject from 'is-plain-object';\nimport { Text, Range, createEditor as createEditor$1, Node, Element } from 'slate';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n/**\r\n * A weak map to hold anchor tokens.\r\n */\n\n\nvar ANCHOR = new WeakMap();\n/**\r\n * A weak map to hold focus tokens.\r\n */\n\nvar FOCUS = new WeakMap();\n/**\r\n * All tokens inherit from a single constructor for `instanceof` checking.\r\n */\n\nvar Token = function Token() {\n  _classCallCheck(this, Token);\n};\n/**\r\n * Anchor tokens represent the selection's anchor point.\r\n */\n\n\nvar AnchorToken = /*#__PURE__*/function (_Token) {\n  _inherits(AnchorToken, _Token);\n\n  var _super = _createSuper(AnchorToken);\n\n  function AnchorToken() {\n    var _this;\n\n    _classCallCheck(this, AnchorToken);\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _this = _super.call(this);\n    var offset = props.offset,\n        path = props.path;\n    _this.offset = offset;\n    _this.path = path;\n    return _this;\n  }\n\n  return AnchorToken;\n}(Token);\n/**\r\n * Focus tokens represent the selection's focus point.\r\n */\n\n\nvar FocusToken = /*#__PURE__*/function (_Token2) {\n  _inherits(FocusToken, _Token2);\n\n  var _super2 = _createSuper(FocusToken);\n\n  function FocusToken() {\n    var _this2;\n\n    _classCallCheck(this, FocusToken);\n\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _this2 = _super2.call(this);\n    var offset = props.offset,\n        path = props.path;\n    _this2.offset = offset;\n    _this2.path = path;\n    return _this2;\n  }\n\n  return FocusToken;\n}(Token);\n/**\r\n * Add an anchor token to the end of a text node.\r\n */\n\n\nvar addAnchorToken = function addAnchorToken(text, token) {\n  var offset = text.text.length;\n  ANCHOR.set(text, [offset, token]);\n};\n/**\r\n * Get the offset if a text node has an associated anchor token.\r\n */\n\n\nvar getAnchorOffset = function getAnchorOffset(text) {\n  return ANCHOR.get(text);\n};\n/**\r\n * Add a focus token to the end of a text node.\r\n */\n\n\nvar addFocusToken = function addFocusToken(text, token) {\n  var offset = text.text.length;\n  FOCUS.set(text, [offset, token]);\n};\n/**\r\n * Get the offset if a text node has an associated focus token.\r\n */\n\n\nvar getFocusOffset = function getFocusOffset(text) {\n  return FOCUS.get(text);\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\r\n * Resolve the descedants of a node by normalizing the children that can be\r\n * passed into a hyperscript creator function.\r\n */\n\n\nvar STRINGS = new WeakSet();\n\nvar resolveDescendants = function resolveDescendants(children) {\n  var nodes = [];\n\n  var addChild = function addChild(child) {\n    if (child == null) {\n      return;\n    }\n\n    var prev = nodes[nodes.length - 1];\n\n    if (typeof child === 'string') {\n      var text = {\n        text: child\n      };\n      STRINGS.add(text);\n      child = text;\n    }\n\n    if (Text.isText(child)) {\n      var c = child; // HACK: fix typescript complaining\n\n      if (Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && Text.equals(prev, c, {\n        loose: true\n      })) {\n        prev.text += c.text;\n      } else {\n        nodes.push(c);\n      }\n    } else if (Element.isElement(child)) {\n      nodes.push(child);\n    } else if (child instanceof Token) {\n      var n = nodes[nodes.length - 1];\n\n      if (!Text.isText(n)) {\n        addChild('');\n        n = nodes[nodes.length - 1];\n      }\n\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child);\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child);\n      }\n    } else {\n      throw new Error(\"Unexpected hyperscript child object: \".concat(child));\n    }\n  };\n\n  var _iterator = _createForOfIteratorHelper(children.flat(Infinity)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var child = _step.value;\n      addChild(child);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return nodes;\n};\n/**\r\n * Create an anchor token.\r\n */\n\n\nfunction createAnchor(tagName, attributes, children) {\n  return new AnchorToken(attributes);\n}\n/**\r\n * Create an anchor and a focus token.\r\n */\n\n\nfunction createCursor(tagName, attributes, children) {\n  return [new AnchorToken(attributes), new FocusToken(attributes)];\n}\n/**\r\n * Create an `Element` object.\r\n */\n\n\nfunction createElement(tagName, attributes, children) {\n  return _objectSpread(_objectSpread({}, attributes), {}, {\n    children: resolveDescendants(children)\n  });\n}\n/**\r\n * Create a focus token.\r\n */\n\n\nfunction createFocus(tagName, attributes, children) {\n  return new FocusToken(attributes);\n}\n/**\r\n * Create a fragment.\r\n */\n\n\nfunction createFragment(tagName, attributes, children) {\n  return resolveDescendants(children);\n}\n/**\r\n * Create a `Selection` object.\r\n */\n\n\nfunction createSelection(tagName, attributes, children) {\n  var anchor = children.find(function (c) {\n    return c instanceof AnchorToken;\n  });\n  var focus = children.find(function (c) {\n    return c instanceof FocusToken;\n  });\n\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n  }\n\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n  }\n\n  return _objectSpread({\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path\n    }\n  }, attributes);\n}\n/**\r\n * Create a `Text` object.\r\n */\n\n\nfunction createText(tagName, attributes, children) {\n  var nodes = resolveDescendants(children);\n\n  if (nodes.length > 1) {\n    throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n  }\n\n  var _nodes = _slicedToArray(nodes, 1),\n      node = _nodes[0];\n\n  if (node == null) {\n    node = {\n      text: ''\n    };\n  }\n\n  if (!Text.isText(node)) {\n    throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n  } // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n\n\n  STRINGS.delete(node);\n  Object.assign(node, attributes);\n  return node;\n}\n/**\r\n * Create a top-level `Editor` object.\r\n */\n\n\nfunction createEditor(tagName, attributes, children) {\n  var otherChildren = [];\n  var selectionChild;\n\n  var _iterator2 = _createForOfIteratorHelper(children),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var child = _step2.value;\n\n      if (Range.isRange(child)) {\n        selectionChild = child;\n      } else {\n        otherChildren.push(child);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var descendants = resolveDescendants(otherChildren);\n  var selection = {};\n  var editor = createEditor$1();\n  Object.assign(editor, attributes);\n  editor.children = descendants; // Search the document's texts to see if any of them have tokens associated\n  // that need incorporated into the selection.\n\n  var _iterator3 = _createForOfIteratorHelper(Node.texts(editor)),\n      _step3;\n\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var _step3$value = _slicedToArray(_step3.value, 2),\n          node = _step3$value[0],\n          path = _step3$value[1];\n\n      var anchor = getAnchorOffset(node);\n      var focus = getFocusOffset(node);\n\n      if (anchor != null) {\n        var _anchor = _slicedToArray(anchor, 1),\n            offset = _anchor[0];\n\n        selection.anchor = {\n          path: path,\n          offset: offset\n        };\n      }\n\n      if (focus != null) {\n        var _focus = _slicedToArray(focus, 1),\n            _offset = _focus[0];\n\n        selection.focus = {\n          path: path,\n          offset: _offset\n        };\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n\n  if (selectionChild != null) {\n    editor.selection = selectionChild;\n  } else if (Range.isRange(selection)) {\n    editor.selection = selection;\n  }\n\n  return editor;\n}\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\r\n * The default creators for Slate objects.\r\n */\n\n\nvar DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor,\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */\n\nvar createHyperscript = function createHyperscript() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$elements = options.elements,\n      elements = _options$elements === void 0 ? {} : _options$elements;\n  var elementCreators = normalizeElements(elements);\n\n  var creators = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, DEFAULT_CREATORS), elementCreators), options.creators);\n\n  var jsx = createFactory(creators);\n  return jsx;\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */\n\n\nvar createFactory = function createFactory(creators) {\n  var jsx = function jsx(tagName, attributes) {\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n\n    var creator = creators[tagName];\n\n    if (!creator) {\n      throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n    }\n\n    if (attributes == null) {\n      attributes = {};\n    }\n\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children);\n      attributes = {};\n    }\n\n    children = children.filter(function (child) {\n      return Boolean(child);\n    }).flat();\n    var ret = creator(tagName, attributes, children);\n    return ret;\n  };\n\n  return jsx;\n};\n/**\r\n * Normalize a dictionary of element shorthands into creator functions.\r\n */\n\n\nvar normalizeElements = function normalizeElements(elements) {\n  var creators = {};\n\n  var _loop = function _loop(tagName) {\n    var props = elements[tagName];\n\n    if (typeof props !== 'object') {\n      throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName, \">  tag you passed: \").concat(props));\n    }\n\n    creators[tagName] = function (tagName, attributes, children) {\n      return createElement('element', _objectSpread$1(_objectSpread$1({}, props), attributes), children);\n    };\n  };\n\n  for (var tagName in elements) {\n    _loop(tagName);\n  }\n\n  return creators;\n};\n/**\r\n * The default hyperscript factory that ships with Slate, without custom tags.\r\n */\n\n\nvar jsx = createHyperscript();\nexport { createHyperscript, jsx };","map":{"version":3,"sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/tokens.ts","../src/creators.ts","../src/hyperscript.ts","../src/index.ts"],"names":["ANCHOR","FOCUS","Token","AnchorToken","constructor","props","path","FocusToken","addAnchorToken","offset","text","getAnchorOffset","addFocusToken","getFocusOffset","STRINGS","resolveDescendants","children","nodes","addChild","child","prev","Text","c","loose","Element","n","createAnchor","tagName","attributes","createCursor","createElement","createFocus","createFragment","createSelection","anchor","focus","createText","node","Object","createEditor","otherChildren","Range","selectionChild","descendants","selection","editor","makeEditor","Node","DEFAULT_CREATORS","cursor","element","fragment","createHyperscript","options","elements","elementCreators","normalizeElements","creators","jsx","createFactory","creator","isPlainObject","Boolean","ret"],"mappings":"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","sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { Node, Path, Text } from 'slate'\n\n/**\n * A weak map to hold anchor tokens.\n */\n\nconst ANCHOR: WeakMap<Node, [number, AnchorToken]> = new WeakMap()\n\n/**\n * A weak map to hold focus tokens.\n */\n\nconst FOCUS: WeakMap<Node, [number, FocusToken]> = new WeakMap()\n\n/**\n * All tokens inherit from a single constructor for `instanceof` checking.\n */\n\nexport class Token {}\n\n/**\n * Anchor tokens represent the selection's anchor point.\n */\n\nexport class AnchorToken extends Token {\n  offset?: number\n  path?: Path\n\n  constructor(\n    props: {\n      offset?: number\n      path?: Path\n    } = {}\n  ) {\n    super()\n    const { offset, path } = props\n    this.offset = offset\n    this.path = path\n  }\n}\n\n/**\n * Focus tokens represent the selection's focus point.\n */\n\nexport class FocusToken extends Token {\n  offset?: number\n  path?: Path\n\n  constructor(\n    props: {\n      offset?: number\n      path?: Path\n    } = {}\n  ) {\n    super()\n    const { offset, path } = props\n    this.offset = offset\n    this.path = path\n  }\n}\n\n/**\n * Add an anchor token to the end of a text node.\n */\n\nexport const addAnchorToken = (text: Text, token: AnchorToken) => {\n  const offset = text.text.length\n  ANCHOR.set(text, [offset, token])\n}\n\n/**\n * Get the offset if a text node has an associated anchor token.\n */\n\nexport const getAnchorOffset = (\n  text: Text\n): [number, AnchorToken] | undefined => {\n  return ANCHOR.get(text)\n}\n\n/**\n * Add a focus token to the end of a text node.\n */\n\nexport const addFocusToken = (text: Text, token: FocusToken) => {\n  const offset = text.text.length\n  FOCUS.set(text, [offset, token])\n}\n\n/**\n * Get the offset if a text node has an associated focus token.\n */\n\nexport const getFocusOffset = (\n  text: Text\n): [number, FocusToken] | undefined => {\n  return FOCUS.get(text)\n}\n","import {\n  Element,\n  Descendant,\n  Node,\n  Range,\n  Text,\n  Editor,\n  createEditor as makeEditor,\n} from 'slate'\nimport {\n  AnchorToken,\n  FocusToken,\n  Token,\n  addAnchorToken,\n  addFocusToken,\n  getAnchorOffset,\n  getFocusOffset,\n} from './tokens'\n\n/**\n * Resolve the descedants of a node by normalizing the children that can be\n * passed into a hyperscript creator function.\n */\n\nconst STRINGS: WeakSet<Text> = new WeakSet()\n\nconst resolveDescendants = (children: any[]): Descendant[] => {\n  const nodes: Node[] = []\n\n  const addChild = (child: Node | Token): void => {\n    if (child == null) {\n      return\n    }\n\n    const prev = nodes[nodes.length - 1]\n\n    if (typeof child === 'string') {\n      const text = { text: child }\n      STRINGS.add(text)\n      child = text\n    }\n\n    if (Text.isText(child)) {\n      const c = child // HACK: fix typescript complaining\n\n      if (\n        Text.isText(prev) &&\n        STRINGS.has(prev) &&\n        STRINGS.has(c) &&\n        Text.equals(prev, c, { loose: true })\n      ) {\n        prev.text += c.text\n      } else {\n        nodes.push(c)\n      }\n    } else if (Element.isElement(child)) {\n      nodes.push(child)\n    } else if (child instanceof Token) {\n      let n = nodes[nodes.length - 1]\n\n      if (!Text.isText(n)) {\n        addChild('')\n        n = nodes[nodes.length - 1] as Text\n      }\n\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child)\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child)\n      }\n    } else {\n      throw new Error(`Unexpected hyperscript child object: ${child}`)\n    }\n  }\n\n  for (const child of children.flat(Infinity)) {\n    addChild(child)\n  }\n\n  return nodes\n}\n\n/**\n * Create an anchor token.\n */\n\nexport function createAnchor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): AnchorToken {\n  return new AnchorToken(attributes)\n}\n\n/**\n * Create an anchor and a focus token.\n */\n\nexport function createCursor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Token[] {\n  return [new AnchorToken(attributes), new FocusToken(attributes)]\n}\n\n/**\n * Create an `Element` object.\n */\n\nexport function createElement(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Element {\n  return { ...attributes, children: resolveDescendants(children) }\n}\n\n/**\n * Create a focus token.\n */\n\nexport function createFocus(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): FocusToken {\n  return new FocusToken(attributes)\n}\n\n/**\n * Create a fragment.\n */\n\nexport function createFragment(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Descendant[] {\n  return resolveDescendants(children)\n}\n\n/**\n * Create a `Selection` object.\n */\n\nexport function createSelection(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Range {\n  const anchor: AnchorToken = children.find(c => c instanceof AnchorToken)\n  const focus: FocusToken = children.find(c => c instanceof FocusToken)\n\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\n      `The <selection> hyperscript tag must have an <anchor> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    )\n  }\n\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\n      `The <selection> hyperscript tag must have a <focus> tag as a child with \\`path\\` and \\`offset\\` attributes defined.`\n    )\n  }\n\n  return {\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path,\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path,\n    },\n    ...attributes,\n  }\n}\n\n/**\n * Create a `Text` object.\n */\n\nexport function createText(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Text {\n  const nodes = resolveDescendants(children)\n\n  if (nodes.length > 1) {\n    throw new Error(\n      `The <text> hyperscript tag must only contain a single node's worth of children.`\n    )\n  }\n\n  let [node] = nodes\n\n  if (node == null) {\n    node = { text: '' }\n  }\n\n  if (!Text.isText(node)) {\n    throw new Error(`\n    The <text> hyperscript tag can only contain text content as children.`)\n  }\n\n  // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n  STRINGS.delete(node)\n\n  Object.assign(node, attributes)\n  return node\n}\n\n/**\n * Create a top-level `Editor` object.\n */\n\nexport function createEditor(\n  tagName: string,\n  attributes: { [key: string]: any },\n  children: any[]\n): Editor {\n  const otherChildren: any[] = []\n  let selectionChild: Range | undefined\n\n  for (const child of children) {\n    if (Range.isRange(child)) {\n      selectionChild = child\n    } else {\n      otherChildren.push(child)\n    }\n  }\n\n  const descendants = resolveDescendants(otherChildren)\n  const selection: Partial<Range> = {}\n  const editor = makeEditor()\n  Object.assign(editor, attributes)\n  editor.children = descendants as Element[]\n\n  // Search the document's texts to see if any of them have tokens associated\n  // that need incorporated into the selection.\n  for (const [node, path] of Node.texts(editor)) {\n    const anchor = getAnchorOffset(node)\n    const focus = getFocusOffset(node)\n\n    if (anchor != null) {\n      const [offset] = anchor\n      selection.anchor = { path, offset }\n    }\n\n    if (focus != null) {\n      const [offset] = focus\n      selection.focus = { path, offset }\n    }\n  }\n\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\n      `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<anchor />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n    )\n  }\n\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\n      `Slate hyperscript ranges must have both \\`<anchor />\\` and \\`<focus />\\` defined if one is defined, but you only defined \\`<focus />\\`. For collapsed selections, use \\`<cursor />\\` instead.`\n    )\n  }\n\n  if (selectionChild != null) {\n    editor.selection = selectionChild\n  } else if (Range.isRange(selection)) {\n    editor.selection = selection\n  }\n\n  return editor\n}\n","import isPlainObject from 'is-plain-object'\nimport { Element } from 'slate'\nimport {\n  createAnchor,\n  createCursor,\n  createEditor,\n  createElement,\n  createFocus,\n  createFragment,\n  createSelection,\n  createText,\n} from './creators'\n\n/**\n * The default creators for Slate objects.\n */\n\nconst DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor,\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText,\n}\n\n/**\n * `HyperscriptCreators` are dictionaries of `HyperscriptCreator` functions\n * keyed by tag name.\n */\n\ntype HyperscriptCreators<T = any> = Record<\n  string,\n  (tagName: string, attributes: { [key: string]: any }, children: any[]) => T\n>\n\n/**\n * `HyperscriptShorthands` are dictionaries of properties applied to specific\n * kind of object, keyed by tag name. They allow you to easily define custom\n * hyperscript tags for your domain.\n */\n\ntype HyperscriptShorthands = Record<string, Record<string, any>>\n\n/**\n * Create a Slate hyperscript function with `options`.\n */\n\nconst createHyperscript = (\n  options: {\n    creators?: HyperscriptCreators\n    elements?: HyperscriptShorthands\n  } = {}\n) => {\n  const { elements = {} } = options\n  const elementCreators = normalizeElements(elements)\n  const creators = {\n    ...DEFAULT_CREATORS,\n    ...elementCreators,\n    ...options.creators,\n  }\n\n  const jsx = createFactory(creators)\n  return jsx\n}\n\n/**\n * Create a Slate hyperscript function with `options`.\n */\n\nconst createFactory = <T extends HyperscriptCreators>(creators: T) => {\n  const jsx = <S extends keyof T & string>(\n    tagName: S,\n    attributes?: Object,\n    ...children: any[]\n  ): ReturnType<T[S]> => {\n    const creator = creators[tagName]\n\n    if (!creator) {\n      throw new Error(`No hyperscript creator found for tag: <${tagName}>`)\n    }\n\n    if (attributes == null) {\n      attributes = {}\n    }\n\n    if (!isPlainObject(attributes)) {\n      children = [attributes].concat(children)\n      attributes = {}\n    }\n\n    children = children.filter(child => Boolean(child)).flat()\n    const ret = creator(tagName, attributes, children)\n    return ret\n  }\n\n  return jsx\n}\n\n/**\n * Normalize a dictionary of element shorthands into creator functions.\n */\n\nconst normalizeElements = (elements: HyperscriptShorthands) => {\n  const creators: HyperscriptCreators<Element> = {}\n\n  for (const tagName in elements) {\n    const props = elements[tagName]\n\n    if (typeof props !== 'object') {\n      throw new Error(\n        `Properties specified for a hyperscript shorthand should be an object, but for the custom element <${tagName}>  tag you passed: ${props}`\n      )\n    }\n\n    creators[tagName] = (\n      tagName: string,\n      attributes: { [key: string]: any },\n      children: any[]\n    ) => {\n      return createElement('element', { ...props, ...attributes }, children)\n    }\n  }\n\n  return creators\n}\n\nexport { createHyperscript, HyperscriptCreators, HyperscriptShorthands }\n","import {\n  createHyperscript,\n  HyperscriptCreators,\n  HyperscriptShorthands,\n} from './hyperscript'\n\n/**\n * The default hyperscript factory that ships with Slate, without custom tags.\n */\n\nconst jsx = createHyperscript()\n\nexport { jsx, createHyperscript, HyperscriptCreators, HyperscriptShorthands }\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var t = require(\"react\");\n\nfunction n(t, n) {\n  for (var r in n) t[r] = n[r];\n\n  return t;\n}\n\nvar r = {\n  store: function () {}\n},\n    o = function (n) {\n  function r() {\n    n.apply(this, arguments);\n  }\n\n  return n && (r.__proto__ = n), (r.prototype = Object.create(n && n.prototype)).constructor = r, r.prototype.getChildContext = function () {\n    return {\n      store: this.props.store\n    };\n  }, r.prototype.render = function () {\n    return t.Children.only(this.props.children);\n  }, r;\n}(t.Component);\n\no.childContextTypes = r, exports.connect = function (o, e) {\n  var i;\n  return \"function\" != typeof o && (\"string\" == typeof (i = o || []) && (i = i.split(/\\s*,\\s*/)), o = function (t) {\n    for (var n = {}, r = 0; r < i.length; r++) n[i[r]] = t[i[r]];\n\n    return n;\n  }), function (i) {\n    function c(r, c) {\n      var p = this;\n      t.Component.call(this, r, c);\n\n      var u = c.store,\n          s = o(u ? u.getState() : {}, r),\n          f = e ? function (t, n) {\n        \"function\" == typeof t && (t = t(n));\n        var r = {};\n\n        for (var o in t) r[o] = n.action(t[o]);\n\n        return r;\n      }(e, u) : {\n        store: u\n      },\n          a = function () {\n        var t = o(u ? u.getState() : {}, r);\n\n        for (var n in t) if (t[n] !== s[n]) return s = t, p.forceUpdate();\n\n        for (var e in s) if (!(e in t)) return s = t, p.forceUpdate();\n      };\n\n      this.UNSAFE_componentWillReceiveProps = function (t) {\n        r = t, a();\n      }, this.componentDidMount = function () {\n        u.subscribe(a);\n      }, this.componentWillUnmount = function () {\n        u.unsubscribe(a);\n      }, this.render = function () {\n        return t.createElement(i, n(n(n({}, f), p.props), s));\n      };\n    }\n\n    return c.contextTypes = r, (c.prototype = Object.create(t.Component.prototype)).constructor = c;\n  };\n}, exports.Provider = o;","map":{"version":3,"sources":["src/util.js","src/integrations/react.js"],"names":["actions","store","mapped","let","i","action","properties","split","state","selected","length","assign","obj","props","CONTEXT_TYPES","mapStateToProps","Child","Wrapper","context","Component","call","this","getState","boundActions","mapActions","update","forceUpdate","UNSAFE_componentWillReceiveProps","p","componentDidMount","subscribe","componentWillUnmount","unsubscribe","render","createElement","contextTypes","prototype","Object","create","constructor","Provider","getChildContext","Children","only","children","childContextTypes"],"mappings":"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","sourcesContent":["// Bind an object/factory of actions to the store and wrap them.\nexport function mapActions(actions, store) {\n\tif (typeof actions==='function') actions = actions(store);\n\tlet mapped = {};\n\tfor (let i in actions) {\n\t\tmapped[i] = store.action(actions[i]);\n\t}\n\treturn mapped;\n}\n\n\n// select('foo,bar') creates a function of the form: ({ foo, bar }) => ({ foo, bar })\nexport function select(properties) {\n\tif (typeof properties==='string') properties = properties.split(/\\s*,\\s*/);\n\treturn state => {\n\t\tlet selected = {};\n\t\tfor (let i=0; i<properties.length; i++) {\n\t\t\tselected[properties[i]] = state[properties[i]];\n\t\t}\n\t\treturn selected;\n\t};\n}\n\n\n// Lighter Object.assign stand-in\nexport function assign(obj, props) {\n\tfor (let i in props) obj[i] = props[i];\n\treturn obj;\n}\n","import { createElement, Children, Component } from 'react';\nimport { assign, mapActions, select } from '../util';\n\nconst CONTEXT_TYPES = {\n\tstore: () => {}\n};\n\n/** Wire a component up to the store. Passes state as props, re-renders on change.\n *  @param {Function|Array|String} mapStateToProps  A function mapping of store state to prop values, or an array/CSV of properties to map.\n *  @param {Function|Object} [actions] \t\t\t\tAction functions (pure state mappings), or a factory returning them. Every action function gets current state as the first parameter and any other params next\n *  @returns {Component} ConnectedComponent\n *  @example\n *    const Foo = connect('foo,bar')( ({ foo, bar }) => <div /> )\n *  @example\n *    const actions = { someAction }\n *    const Foo = connect('foo,bar', actions)( ({ foo, bar, someAction }) => <div /> )\n *  @example\n *    @connect( state => ({ foo: state.foo, bar: state.bar }) )\n *    export class Foo { render({ foo, bar }) { } }\n */\nexport function connect(mapStateToProps, actions) {\n\tif (typeof mapStateToProps!=='function') {\n\t\tmapStateToProps = select(mapStateToProps || []);\n\t}\n\treturn Child => {\n\t\tfunction Wrapper(props, context) {\n\t\t\tComponent.call(this, props, context);\n\t\t\tconst store = context.store;\n\t\t\tlet state = mapStateToProps(store ? store.getState() : {}, props);\n\t\t\tconst boundActions = actions ? mapActions(actions, store) : { store };\n\t\t\tlet update = () => {\n\t\t\t\tlet mapped = mapStateToProps(store ? store.getState() : {}, props);\n\t\t\t\tfor (let i in mapped) if (mapped[i]!==state[i]) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.forceUpdate();\n\t\t\t\t}\n\t\t\t\tfor (let i in state) if (!(i in mapped)) {\n\t\t\t\t\tstate = mapped;\n\t\t\t\t\treturn this.forceUpdate();\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.UNSAFE_componentWillReceiveProps = p => {\n\t\t\t\tprops = p;\n\t\t\t\tupdate();\n\t\t\t};\n\t\t\tthis.componentDidMount = () => {\n\t\t\t\tstore.subscribe(update);\n\t\t\t};\n\t\t\tthis.componentWillUnmount = () => {\n\t\t\t\tstore.unsubscribe(update);\n\t\t\t};\n\t\t\tthis.render = () => createElement(Child, assign(assign(assign({}, boundActions), this.props), state));\n\t\t}\n\t\tWrapper.contextTypes = CONTEXT_TYPES;\n\t\treturn (Wrapper.prototype = Object.create(Component.prototype)).constructor = Wrapper;\n\t};\n}\n\n\n/** Provider exposes a store (passed as `props.store`) into context.\n *\n *  Generally, an entire application is wrapped in a single `<Provider>` at the root.\n *  @class\n *  @extends Component\n *  @param {Object} props\n *  @param {Store} props.store\t\tA {Store} instance to expose via context.\n */\nexport class Provider extends Component {\n\tgetChildContext() {\n\t\treturn { store: this.props.store };\n\t}\n\trender() {\n\t\treturn Children.only(this.props.children);\n\t}\n}\nProvider.childContextTypes = CONTEXT_TYPES;\n"]},"metadata":{},"sourceType":"script"}
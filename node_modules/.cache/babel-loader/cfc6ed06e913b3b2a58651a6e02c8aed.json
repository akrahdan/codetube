{"ast":null,"code":"import isPlainObject from 'is-plain-object';\nimport { Operation, Editor, Path } from 'slate';\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));\n  }\n\n};\n/**\r\n * Weakmaps for attaching state to the editor.\r\n */\n\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor(value) {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n\n  /**\r\n   * Redo to the previous saved state.\r\n   */\n  redo(editor) {\n    editor.redo();\n  },\n\n  /**\r\n   * Undo to the previous saved state.\r\n   */\n  undo(editor) {\n    editor.undo();\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n\n};\n/**\r\n * The `withHistory` plugin keeps track of the operation history of a Slate\r\n * editor as operations are applied to it, using undo and redo stacks.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withHistory = editor => {\n  var e = editor;\n  var {\n    apply\n  } = e;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n\n  e.redo = () => {\n    var {\n      history\n    } = e;\n    var {\n      redos\n    } = history;\n\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (var op of batch) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.pop();\n      history.undos.push(batch);\n    }\n  };\n\n  e.undo = () => {\n    var {\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          var inverseOps = batch.map(Operation.inverse).reverse();\n\n          for (var op of inverseOps) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.push(batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = op => {\n    var {\n      operations,\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch[lastBatch.length - 1];\n    var overwrite = shouldOverwrite(op, lastOp);\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n\n    if (save == null) {\n      save = shouldSave(op);\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp) || overwrite;\n        }\n      }\n\n      if (lastBatch && merge) {\n        if (overwrite) {\n          lastBatch.pop();\n        }\n\n        lastBatch.push(op);\n      } else {\n        var batch = [op];\n        undos.push(batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      if (shouldClear(op)) {\n        history.redos = [];\n      }\n    }\n\n    apply(op);\n  };\n\n  return e;\n};\n/**\r\n * Check whether to merge an operation into the previous operation.\r\n */\n\n\nvar shouldMerge = (op, prev) => {\n  if (op.type === 'set_selection') {\n    return true;\n  }\n\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation needs to be saved to the history.\r\n */\n\n\nvar shouldSave = (op, prev) => {\n  if (op.type === 'set_selection' && (op.properties == null || op.newProperties == null)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Check whether an operation should overwrite the previous one.\r\n */\n\n\nvar shouldOverwrite = (op, prev) => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation should clear the redos stack.\r\n */\n\n\nvar shouldClear = op => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n\nexport { HISTORY, History, HistoryEditor, MERGING, SAVING, withHistory };","map":{"version":3,"sources":["../src/history.ts","../src/history-editor.ts","../src/with-history.ts"],"names":["History","isHistory","isPlainObject","Array","value","Operation","HISTORY","SAVING","MERGING","HistoryEditor","isHistoryEditor","Editor","isMerging","isSaving","redo","editor","undo","withoutMerging","prev","fn","withoutSaving","withHistory","e","apply","undos","redos","history","batch","inverseOps","op","lastBatch","lastOp","overwrite","shouldOverwrite","save","merge","shouldSave","operations","shouldMerge","shouldClear","Path"],"mappings":"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","sourcesContent":["import isPlainObject from 'is-plain-object'\nimport { Operation } from 'slate'\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Operation[][]\n  undos: Operation[][]\n}\n\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) &&\n      (value.undos.length === 0 || Operation.isOperationList(value.undos[0]))\n    )\n  },\n}\n","import { BaseEditor, Editor } from 'slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends BaseEditor {\n  history: History\n  undo: () => void\n  redo: () => void\n}\n\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return History.isHistory(value.history) && Editor.isEditor(value)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Redo to the previous saved state.\n   */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo()\n  },\n\n  /**\n   * Undo to the previous saved state.\n   */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo()\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    fn()\n    SAVING.set(editor, prev)\n  },\n}\n","import { Editor, Operation, Path } from 'slate'\n\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n *\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\n * this plugin.\n *\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor\n  const { apply } = e\n  e.history = { undos: [], redos: [] }\n\n  e.redo = () => {\n    const { history } = e\n    const { redos } = history\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.pop()\n      history.undos.push(batch)\n    }\n  }\n\n  e.undo = () => {\n    const { history } = e\n    const { undos } = history\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.map(Operation.inverse).reverse()\n\n          for (const op of inverseOps) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.push(batch)\n      history.undos.pop()\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e\n    const { undos } = history\n    const lastBatch = undos[undos.length - 1]\n    const lastOp = lastBatch && lastBatch[lastBatch.length - 1]\n    const overwrite = shouldOverwrite(op, lastOp)\n    let save = HistoryEditor.isSaving(e)\n    let merge = HistoryEditor.isMerging(e)\n\n    if (save == null) {\n      save = shouldSave(op, lastOp)\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false\n        } else if (operations.length !== 0) {\n          merge = true\n        } else {\n          merge = shouldMerge(op, lastOp) || overwrite\n        }\n      }\n\n      if (lastBatch && merge) {\n        if (overwrite) {\n          lastBatch.pop()\n        }\n\n        lastBatch.push(op)\n      } else {\n        const batch = [op]\n        undos.push(batch)\n      }\n\n      while (undos.length > 100) {\n        undos.shift()\n      }\n\n      if (shouldClear(op)) {\n        history.redos = []\n      }\n    }\n\n    apply(op)\n  }\n\n  return e\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (\n    op.type === 'set_selection' &&\n    (op.properties == null || op.newProperties == null)\n  ) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an operation should overwrite the previous one.\n */\n\nconst shouldOverwrite = (\n  op: Operation,\n  prev: Operation | undefined\n): boolean => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation should clear the redos stack.\n */\n\nconst shouldClear = (op: Operation): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}
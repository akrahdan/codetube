{"ast":null,"code":"import { debounce, isArray, isEmpty, mapValues } from 'lodash';\nimport request from 'superagent';\nimport { csrf } from 'libs/superagent-auth';\nimport { ErrorMessages, UserSubmitKey } from './types';\nconst SERVER_ERRORS = {\n  weak: ErrorMessages.WEAK,\n  breach: ErrorMessages.WEAK,\n  // Standard breach error message is confusing for new account creation\n  required: ErrorMessages.REQUIRED,\n  length: ErrorMessages.LENGTH,\n  invalid: ErrorMessages.VALID_EMAIL\n};\nexport const extractValidationErrors = ({\n  body: {\n    errors\n  }\n}) => {\n  if (!errors || isEmpty(Object.values(errors))) return null;\n  return mapValues(errors, error => isArray(error) ? SERVER_ERRORS[error[0]] : SERVER_ERRORS[error] || error);\n};\n\nconst createServerValidator = (key, setIsSubmitting) => {\n  let currentInput;\n  const validator = debounce((input, resolve) => request.post('/register/validate').send({\n    user: {\n      [key]: input\n    }\n  }).use(csrf).accept('json').then(() => resolve(undefined)).catch(err => {\n    var _extractValidationErr;\n\n    return resolve(currentInput === input ? (_extractValidationErr = extractValidationErrors(err.response)) === null || _extractValidationErr === void 0 ? void 0 : _extractValidationErr[key] : undefined);\n  }), 250, {\n    leading: true,\n    trailing: true\n  });\n  return async input => {\n    currentInput = input;\n    setIsSubmitting === null || setIsSubmitting === void 0 ? void 0 : setIsSubmitting(true);\n    const res = await new Promise(resolve => {\n      validator(input, resolve);\n    });\n    setIsSubmitting === null || setIsSubmitting === void 0 ? void 0 : setIsSubmitting(false);\n    return res;\n  };\n};\n\nexport const VALIDATORS = {\n  [UserSubmitKey.EMAIL]: setIsSubmitting => ({\n    required: ErrorMessages.REQUIRED,\n    pattern: {\n      value: /^[^@\\s]+@[^@\\s\\.]+\\.[^@\\s]{2,}$/,\n      message: ErrorMessages.VALID_EMAIL\n    },\n    validate: createServerValidator(UserSubmitKey.EMAIL, setIsSubmitting)\n  }),\n  [UserSubmitKey.PASSWORD]: setIsSubmitting => ({\n    required: ErrorMessages.REQUIRED,\n    minLength: {\n      value: 6,\n      message: ErrorMessages.LENGTH\n    },\n    maxLength: {\n      value: 128,\n      message: ErrorMessages.LENGTH\n    },\n    validate: createServerValidator(UserSubmitKey.PASSWORD, setIsSubmitting)\n  })\n};","map":{"version":3,"sources":["/Users/akrah/Documents/dev/readux/src/codefluent/src/components/Forms/RegistrationForm/validators.ts"],"names":["debounce","isArray","isEmpty","mapValues","request","csrf","ErrorMessages","UserSubmitKey","SERVER_ERRORS","weak","WEAK","breach","required","REQUIRED","length","LENGTH","invalid","VALID_EMAIL","extractValidationErrors","body","errors","Object","values","error","createServerValidator","key","setIsSubmitting","currentInput","validator","input","resolve","post","send","user","use","accept","then","undefined","catch","err","response","leading","trailing","res","Promise","VALIDATORS","EMAIL","pattern","value","message","validate","PASSWORD","minLength","maxLength"],"mappings":"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","sourcesContent":["import { debounce, isArray, isEmpty, mapValues } from 'lodash';\nimport request from 'superagent';\n\nimport { csrf } from 'libs/superagent-auth';\n\nimport { ErrorMessages, UserSubmitKey } from './types';\n\ntype ServerError = keyof typeof SERVER_ERRORS;\ninterface ValidationResponse extends request.Response {\n  body: {\n    errors?: Record<string, ServerError | ServerError[]> | undefined;\n  };\n}\n\ntype disabledHook = (value: boolean) => void;\n\nconst SERVER_ERRORS = {\n  weak: ErrorMessages.WEAK,\n  breach: ErrorMessages.WEAK, // Standard breach error message is confusing for new account creation\n  required: ErrorMessages.REQUIRED,\n  length: ErrorMessages.LENGTH,\n  invalid: ErrorMessages.VALID_EMAIL,\n};\n\nexport const extractValidationErrors = ({\n  body: { errors },\n}: ValidationResponse): Record<string, string> | null => {\n  if (!errors || isEmpty(Object.values(errors))) return null;\n  return mapValues(errors, (error) =>\n    isArray(error) ? SERVER_ERRORS[error[0]] : SERVER_ERRORS[error] || error\n  );\n};\n\nconst createServerValidator = (\n  key: UserSubmitKey,\n  setIsSubmitting?: disabledHook\n) => {\n  let currentInput: string;\n  const validator = debounce(\n    (input: string, resolve: (error: string | undefined) => void) =>\n      request\n        .post('/register/validate')\n        .send({ user: { [key]: input } })\n        .use(csrf)\n        .accept('json')\n        .then(() => resolve(undefined))\n        .catch((err) =>\n          resolve(\n            currentInput === input\n              ? extractValidationErrors(err.response)?.[key]\n              : undefined\n          )\n        ),\n    250,\n    { leading: true, trailing: true }\n  );\n\n  return async (input: string) => {\n    currentInput = input;\n    setIsSubmitting?.(true);\n    const res = await new Promise<string | undefined>((resolve) => {\n      validator(input, resolve);\n    });\n    setIsSubmitting?.(false);\n    return res;\n  };\n};\n\nexport const VALIDATORS = {\n  [UserSubmitKey.EMAIL]: (setIsSubmitting?: disabledHook) => ({\n    required: ErrorMessages.REQUIRED,\n    pattern: {\n      value: /^[^@\\s]+@[^@\\s\\.]+\\.[^@\\s]{2,}$/,\n      message: ErrorMessages.VALID_EMAIL,\n    },\n    validate: createServerValidator(UserSubmitKey.EMAIL, setIsSubmitting),\n  }),\n  [UserSubmitKey.PASSWORD]: (setIsSubmitting?: disabledHook) => ({\n    required: ErrorMessages.REQUIRED,\n    minLength: {\n      value: 6,\n      message: ErrorMessages.LENGTH,\n    },\n    maxLength: {\n      value: 128,\n      message: ErrorMessages.LENGTH,\n    },\n    validate: createServerValidator(UserSubmitKey.PASSWORD, setIsSubmitting),\n  }),\n};\n"]},"metadata":{},"sourceType":"module"}
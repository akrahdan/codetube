{"ast":null,"code":"var _jsxFileName = \"/Users/akrah/Documents/dev/readux/src/codefluent/src/portal/scenes/CoursePlayer/video/video.js\";\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux';\nimport { setVolume, setDuration, setTime } from 'state/player/playerSlice';\nimport css from './video.module.css';\nimport { DefaultResolutions } from '../constants'; // import withAdobeHeartbeat from './with-adobe-heartbeat'\n\nimport { FullscreenState, HLS_SDK_URL, HLS_SDK_URL_SAFARI, MediaTypes } from '../constants';\nimport { getSDK } from '../utilities/get-sdk';\nimport { throttle } from '../utilities/throttle'; // import { sendPlaySuccessEvent } from '../../analytics/player-events'\n\nimport { mapHlsError, mapGenericVideoError } from '../utilities/video-error';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst HLS_EXTENSIONS = /\\.(m3u8)($|\\?)/i;\nconst initialState = {\n  isPlaying: false,\n  reportedVolume: null,\n  reportedPlaybackRate: 1,\n  isBuffering: false,\n  canPlay: false,\n  ready: true\n};\nexport class Video extends Component {\n  constructor(props) {\n    super(props);\n\n    this.newReadyPromise = () => {\n      return new Promise(resolve => {\n        this.ready = () => {\n          this.setState({\n            ready: true\n          }, () => {\n            resolve();\n          });\n        };\n      });\n    };\n\n    this.isSafari = () => navigator.vendor.match(/apple/i);\n\n    this.isHlsSource = source => HLS_EXTENSIONS.test(source);\n\n    this.destroyHls = () => {\n      this.setState({\n        hlsPlaying: false\n      });\n      this.hls && this.hls.destroy();\n    };\n\n    this.startHls = async source => {\n      const {\n        setSupportedResolutions,\n        setMediaType,\n        setCurrentResolution,\n        preferredResolutions,\n        currentResolution,\n        time\n      } = this.props;\n      const sdkUrl = this.isSafari() ? HLS_SDK_URL_SAFARI : HLS_SDK_URL; //https://github.com/video-dev/hls.js/issues/1543\n\n      const Hls = await getSDK(sdkUrl, 'Hls');\n      if (!Hls.isSupported()) return setMediaType && setMediaType(MediaTypes.MP4);\n      this.Hls = Hls;\n      this.hls = new Hls({\n        autoStartLoad: false\n      });\n      this.hls.loadSource(source);\n      const videoElement = document.getElementById('video-element');\n      this.hls.attachMedia(videoElement);\n      this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\n        this.hls.startLoad(time || 0);\n        const autoLevel = {\n          height: 'Auto',\n          index: -1\n        };\n        const supportedResolutions = data.levels.map(r => ({\n          width: r.width,\n          height: r.height,\n          index: data.levels.indexOf(r)\n        }));\n        setSupportedResolutions && setSupportedResolutions(supportedResolutions.concat(autoLevel));\n        const preferredResolution = preferredResolutions.hls ? preferredResolutions.hls : null;\n        const newResolution = preferredResolution && supportedResolutions.find(r => preferredResolution.width === r.width && preferredResolution.height === r.height);\n\n        if (!newResolution) {\n          setCurrentResolution && setCurrentResolution(autoLevel);\n          return;\n        }\n\n        this.hls && (this.hls.currentLevel = newResolution.index);\n        const resolutionShouldChange = newResolution !== currentResolution;\n        resolutionShouldChange && setCurrentResolution && setCurrentResolution(newResolution);\n      });\n      this.hls.on(Hls.Events.ERROR, this.handleHlsError.bind(this));\n      this.hls.on(Hls.Events.MEDIA_ATTACHED, (event, data) => {\n        this.setState({\n          hlsPlaying: true\n        });\n      });\n    };\n\n    this.onHlsLevelChange = ({\n      height,\n      index\n    }) => {\n      const {\n        currentResolution,\n        setCurrentResolution\n      } = this.props;\n\n      if (height === currentResolution.height) {\n        return;\n      }\n\n      this.hls && (this.hls.currentLevel = index);\n      setCurrentResolution && setCurrentResolution({\n        height,\n        index\n      });\n    };\n\n    this.requestNewUrls = () => {\n      const {\n        setLoading,\n        requestUrls\n      } = this.props;\n      requestUrls && requestUrls(true);\n      setLoading && setLoading(true);\n    };\n\n    this.onMediaTypeChange = newMediaType => {\n      const {\n        setSupportedResolutions,\n        setCurrentResolution,\n        preferredResolutions\n      } = this.props;\n\n      if (newMediaType !== MediaTypes.HLS) {\n        setSupportedResolutions && setSupportedResolutions(DefaultResolutions[newMediaType]);\n        const resolution = preferredResolutions && preferredResolutions[newMediaType];\n        setCurrentResolution && setCurrentResolution(resolution);\n      }\n\n      if (newMediaType === MediaTypes.WEBM || newMediaType === MediaTypes.MP4) {\n        this.requestNewUrls();\n      }\n    };\n\n    this.iosEndFullscreen = () => {\n      this.props.setFullscreen(FullscreenState.NORMAL);\n    };\n\n    this.setVolume = percent => {\n      const {\n        onReady\n      } = this.state;\n      onReady.then(() => {\n        const {\n          current: player\n        } = this.element;\n        player && percent === 0 ? player.muted = true : player.muted = false; // player.volume is read only on mobile iOS\n\n        player && isFinite(percent) && (player.volume = percent);\n      });\n    };\n\n    this.setPlaybackRate = rate => {\n      const {\n        onReady\n      } = this.state;\n      onReady.then(() => {\n        const {\n          current: player\n        } = this.element;\n        player && (player.playbackRate = rate);\n      });\n    };\n\n    this.onCaptionUpdate = e => {\n      e.currentTarget.activeCues && this.props.setClosedCaptioningCueList(e.currentTarget.activeCues);\n    };\n\n    this.toggleCaptions = language => {\n      const {\n        onReady\n      } = this.state;\n      onReady.then(() => {\n        const {\n          current: player\n        } = this.element;\n        player && [...player.textTracks].forEach(track => {\n          if (track.mode === 'showing' && track.language !== language.code) track.mode = 'disabled';\n\n          if (track.language === language.code) {\n            track.oncuechange = this.onCaptionUpdate;\n            track.mode = 'hidden';\n          } else {\n            track.oncuechange = null;\n          }\n        });\n      });\n    };\n\n    this.seekTo = amount => {\n      const {\n        onReady\n      } = this.state;\n      onReady.then(() => {\n        const {\n          current: player\n        } = this.element;\n        player && (player.currentTime = amount);\n      });\n    };\n\n    this.onRateChange = rate => {\n      const {\n        current: player\n      } = this.element;\n      player && this.setState({\n        reportedPlaybackRate: player.playbackRate\n      });\n    };\n\n    this.onVolumeChange = rate => {\n      const {\n        current: player\n      } = this.element;\n      player && this.setState({\n        reportedVolume: player.volume\n      });\n    };\n\n    this.onPlay = () => {\n      // const { setPlaying } = this.props\n      // const { isStagingEnv, urls, currentUrlIndex, userId } = this.props\n      this.setState({\n        isPlaying: true\n      }); // const currentUrl = urls[currentUrlIndex || 0]\n      // // sendPlaySuccessEvent(currentUrl, isStagingEnv, userId)\n      // setPlaying && setPlaying(true)\n      // this.updateProgress()\n    };\n\n    this.onPause = () => {\n      const {\n        setPlaying\n      } = this.props;\n      this.setState({\n        isPlaying: false\n      }); // setPlaying && setPlaying(false)\n    };\n\n    this.onCanPlay = () => {\n      const {\n        setBuffering,\n        buffering,\n        loading,\n        setLoading,\n        adobeHeartbeat\n      } = this.props; // this.setState({ canPlay: true })\n      // if (loading) setLoading && setLoading(false)\n      // if (buffering) {\n      //   setBuffering && setBuffering(false)\n      //   adobeHeartbeat && adobeHeartbeat.trackBufferComplete()\n      // }\n    };\n\n    this.onLoadedData = () => {// const { setBuffering, buffering, setOverlay, adobeHeartbeat } = this.props\n      // const { onReady } = this.state\n      // if (!buffering) {\n      //   this.setState({ isBuffering: true })\n      //   setBuffering && setBuffering(true)\n      // }\n      // setOverlay && setOverlay(null)\n      // onReady.then(() => {\n      //   const { current: player } = this.element\n      //   adobeHeartbeat && adobeHeartbeat.initHeartbeat(player.duration)\n      // })\n    };\n\n    this.onEnded = e => {// const { adobeHeartbeat, clipCompletedCallback, end, nextCallback, pause, userAutoplaySetting, clipId } = this.props\n      // end && end()\n      // pause && pause(false)\n      // adobeHeartbeat && adobeHeartbeat.trackComplete()\n      // clipCompletedCallback && clipCompletedCallback(e)\n      // userAutoplaySetting && nextCallback && nextCallback(e)\n    };\n\n    this.updateTracks = videoElement => {// const { closedCaptioningLanguage, closedCaptioningEnabled, setClosedCaptioningCueList } = this.props\n      // const tracks = videoElement && videoElement.textTracks\n      // tracks &&\n      //   Object.values(tracks).forEach((track) => {\n      //     const isActive = closedCaptioningEnabled && track.language === closedCaptioningLanguage.code\n      //     if (isActive) {\n      //       track.mode = 'hidden'\n      //       videoElement.textTracks[0].mode = 'hidden' // Firefox\n      //       track.oncuechange = (e) => {\n      //         e.currentTarget.activeCues && setClosedCaptioningCueList(e.currentTarget.activeCues)\n      //       }\n      //     } else {\n      //       track.mode = 'disabled'\n      //     }\n      //   })\n    };\n\n    this.onLoadedMetadata = () => {\n      // const { ready, registerPlayer } = this.props\n      this.ready(); // const duration = this.getDuration()\n      // ready && ready({ duration, hlsInstance: this.hls, hlsLibrary: this.Hls })\n      // const videoElement = document.getElementById('video-element')\n      // registerPlayer && registerPlayer(videoElement)\n      // this.updateTracks(videoElement)\n    };\n\n    this.getSrc = ({\n      currentUrlIndex,\n      urls\n    }) => {// return currentUrlIndex !== null && urls && urls.length > 0 ? urls[currentUrlIndex].url : null\n    };\n\n    this.onSeeking = () => {// const { adobeHeartbeat } = this.props\n      // adobeHeartbeat && adobeHeartbeat.trackSeekStart()\n    };\n\n    this.onSeeked = () => {// const { adobeHeartbeat } = this.props\n      // adobeHeartbeat && adobeHeartbeat.trackSeekComplete()\n    };\n\n    this.updateProgress = () => {// const { clipId, setTime, playing } = this.props\n      // if (!playing) return\n      // const reportedTime = this.getPlayedSeconds()\n      // setTime && setTime(reportedTime)\n      // reportedTime > 0 && this.throttledSetClipProgress({clipId, videoSecondsWatched: reportedTime })\n      // this.progressTimeout = setTimeout(this.updateProgress, 50)\n    };\n\n    this.onProgress = () => {// const { setBufferedTime } = this.props\n      // const bufferedTime = this.getSecondsLoaded()\n      // setBufferedTime && setBufferedTime(bufferedTime)\n    };\n\n    this.onWaiting = () => {// const { adobeHeartbeat, setBuffering } = this.props\n      // adobeHeartbeat && adobeHeartbeat.trackBufferStart()\n      // setBuffering && setBuffering(true)\n    };\n\n    this.state = { ...initialState,\n      clipId: props.clipId,\n      onReady: this.newReadyPromise(),\n      hlsPlaying: false,\n      videoSrc: null\n    };\n    this.element = /*#__PURE__*/React.createRef();\n  }\n\n  componentDidMount() {\n    const {\n      playing,\n      volume,\n      muted,\n      playbackRate,\n      time,\n      closedCaptioningEnabled,\n      closedCaptioningLanguage,\n      mediaType,\n      userAutoplaySetting,\n      setClipProgress\n    } = this.props;\n    this.throttledSetClipProgress = throttle(setClipProgress, 1000);\n    const src = this.getSrc(this.props);\n\n    if (muted || volume !== null) {\n      volume && this.setVolume(muted ? 0 : volume);\n    }\n\n    if (playbackRate) {\n      this.setPlaybackRate(playbackRate);\n    }\n\n    if (time) {\n      this.seekTo(time);\n    }\n\n    if (closedCaptioningEnabled) {\n      this.toggleCaptions(closedCaptioningLanguage);\n    }\n\n    if (src) {\n      this.maybeStartHls(src, mediaType);\n    }\n\n    this.onMediaTypeChange(mediaType);\n  }\n\n  componentWillUnmount() {\n    this.destroyHls();\n    clearTimeout(this.progressTimeout);\n  }\n\n  maybeStartHls(source, mediaType) {\n    const {\n      setMediaType\n    } = this.props;\n    const {\n      hlsPlaying\n    } = this.state;\n    const isHlsSource = this.isHlsSource(source);\n    const shouldPlayHls = mediaType === MediaTypes.HLS && isHlsSource;\n    if (hlsPlaying) this.destroyHls();\n\n    if (shouldPlayHls) {\n      this.startHls(source);\n    }\n\n    if (mediaType === MediaTypes.HLS && !shouldPlayHls) {\n      setMediaType && setMediaType(MediaTypes.MP4);\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {\n      adobeHeartbeat,\n      clipId,\n      closedCaptioningEnabled,\n      closedCaptioningLanguage,\n      currentUrlIndex,\n      mediaType,\n      currentResolution,\n      setClosedCaptioningCueList\n    } = this.props;\n    const {\n      reportedPlaybackRate,\n      reportedVolume,\n      ready,\n      isPlaying,\n      hlsPlaying\n    } = this.state;\n    const newSource = this.getSrc(nextProps); // Handle URL change\n\n    const sourceDidChange = currentUrlIndex !== nextProps.currentUrlIndex || clipId !== nextProps.clipId || mediaType !== nextProps.mediaType || this.getSrc(this.props) !== newSource;\n    const captionsDidChange = nextProps.closedCaptioningEnabled !== closedCaptioningEnabled || nextProps.closedCaptioningLanguage !== closedCaptioningLanguage;\n    const resolutionDidChange = nextProps.currentResolution !== currentResolution;\n    const mediaTypeDidChange = mediaType && mediaType !== nextProps.mediaType;\n    if (mediaTypeDidChange) this.onMediaTypeChange(nextProps.mediaType);\n\n    if (sourceDidChange && newSource) {\n      setClosedCaptioningCueList && setClosedCaptioningCueList(null);\n      this.maybeStartHls(newSource, mediaType);\n    }\n\n    if (sourceDidChange && ready) {\n      this.setState({\n        onReady: this.newReadyPromise(),\n        ready: false,\n        reportedVolume: null,\n        reportedPlaybackRate: null,\n        isPlaying: null\n      }, () => {\n        adobeHeartbeat && adobeHeartbeat.trackComplete();\n      });\n    }\n\n    if (!ready) {\n      return;\n    } // Handle playing change\n\n\n    if (nextProps.playing && !isPlaying) {\n      this.play();\n    }\n\n    if (!nextProps.playing && isPlaying) {\n      this.pause();\n    } // Handle volume change\n\n\n    if (nextProps.volume !== null || nextProps.muted) {\n      if (!nextProps.muted) {\n        if (nextProps.volume !== reportedVolume) {\n          this.setVolume(nextProps.volume);\n        }\n      }\n\n      if (nextProps.muted && reportedVolume !== 0) {\n        this.setVolume(0);\n      }\n    } // Handle playback rate change\n\n\n    console.log(\"Rate: \", nextProps.playbackRate);\n\n    if (nextProps.playbackRate !== reportedPlaybackRate) {\n      this.setPlaybackRate(nextProps.playbackRate);\n    } // Handle time change\n\n\n    const timeDelta = Math.abs(nextProps.time - this.getPlayedSeconds());\n\n    if (timeDelta >= 1) {\n      this.seekTo(nextProps.time);\n    }\n\n    if (captionsDidChange) {\n      this.toggleCaptions(nextProps.closedCaptioningLanguage);\n    }\n\n    if (resolutionDidChange && hlsPlaying) this.onHlsLevelChange(nextProps.currentResolution);\n  }\n\n  connectIosFullscreenExit() {\n    const {\n      onReady\n    } = this.state;\n    onReady.then(() => {\n      const {\n        current: player\n      } = this.element;\n\n      if (player.webkitExitFullscreen) {\n        player.addEventListener('webkitendfullscreen', this.iosEndFullscreen, false);\n      }\n    });\n  } //#region Player API\n\n\n  play() {\n    const {\n      onReady\n    } = this.state;\n    onReady.then(() => {\n      //   const { adobeHeartbeat, clipId, title } = this.props\n      const {\n        current: player\n      } = this.element;\n\n      if (player) {\n        const promise = player.play(); // adobeHeartbeat && adobeHeartbeat.trackPlay()\n\n        if (promise) {\n          promise.catch(e => {\n            const {\n              onError,\n              pause\n            } = this.props;\n            pause && pause(false);\n            onError && onError(e);\n          });\n        }\n      }\n    });\n  }\n\n  pause() {\n    const {\n      onReady\n    } = this.state;\n    const {\n      adobeHeartbeat,\n      onPause\n    } = this.props;\n    onReady.then(() => {\n      const {\n        current: player\n      } = this.element;\n      player && player.pause(); //   adobeHeartbeat && adobeHeartbeat.trackPause()\n      //   onPause && onPause()\n    });\n  }\n\n  getDuration() {\n    const {\n      current: player\n    } = this.element;\n    return player ? player.duration : 0;\n  }\n\n  getPlayedSeconds() {\n    const {\n      current: player\n    } = this.element;\n    return player ? player.currentTime : 0;\n  }\n\n  getSecondsLoaded() {// const { current: player } = this.element\n    // if (!player) {\n    //   return 0\n    // }\n    // const bufferedLength = player.buffered.length\n    // if (bufferedLength === 0) return 0\n    // let maxBuffered = 0,\n    //   currentBuffered\n    // for (let i = 0; i < bufferedLength; i++) {\n    //   currentBuffered = player.buffered.end(i)\n    //   maxBuffered = currentBuffered > maxBuffered ? currentBuffered : maxBuffered\n    // }\n    // return maxBuffered\n  } //#endregion\n\n\n  renderTrack(language) {// const { clipId, versionId } = this.props\n    // return (\n    //   <track\n    //     key={language.code}\n    //     label={language.name}\n    //     kind=\"captions\"\n    //     srcLang={language.code}\n    //     src={\"\"}\n    //   />\n    // )\n  }\n\n  handleHlsError(event, data) {// const { onVideoError } = this.props\n    // if (data.fatal) {\n    //   switch (data.type) {\n    //     case this.Hls.ErrorTypes.MEDIA_ERROR:\n    //       this.hls.recoverMediaError()\n    //       break\n    //     default:\n    //       this.destroyHls()\n    //       onVideoError && onVideoError(mapHlsError(data), 'handleHlsError')\n    //       break\n    //   }\n    // }\n  }\n\n  render() {\n    // const { onVideoError, versionId, closedCaptioningLanguage, mediaType } = this.props\n    const {\n      playbackRate\n    } = this.props;\n    console.log(\"PlayBackRate: \", playbackRate); // let source = this.getSrc(this.props)\n\n    let source = \"https://archive.org/download/ElephantsDream/ed_1024_512kb.mp4\";\n\n    if (!source) {\n      return /*#__PURE__*/_jsxDEV(\"div\", {\n        className: css.video\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 625,\n        columnNumber: 14\n      }, this);\n    } // if (mediaType === MediaTypes.HLS) source = undefined\n\n\n    return /*#__PURE__*/_jsxDEV(\"video\", {\n      id: \"video-element\",\n      className: css.video,\n      ref: this.element,\n      src: source,\n      preload: \"auto\",\n      playsInline: true,\n      controls: false,\n      loop: false,\n      onLoadedMetadata: this.onLoadedMetadata // onLoadedData={this.onLoadedData}\n      // onCanPlay={this.onCanPlay}\n      ,\n      onPlay: this.onPlay // onSeeking={this.onSeeking}\n      // onSeeked={this.onSeeked}\n      ,\n      onPause: this.onPause // onEnded={this.onEnded}\n      ,\n      onVolumeChange: this.onVolumeChange,\n      onRateChange: this.onRateChange // onWaiting={this.onWaiting}\n      // onProgress={this.onProgress}\n      // onError={(e) => {\n      //   const { current: player } = this.element\n      //   onVideoError && onVideoError(mapGenericVideoError(player.error), 'videoElement.onError')\n      // }}\n\n    }, source, false, {\n      fileName: _jsxFileName,\n      lineNumber: 631,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\nconst mapStateToProps = state => ({\n  playing: state.player.playing,\n  playbackRate: state.player.playbackSpeed,\n  volume: state.player.volume,\n  muted: state.player.muted\n});\n\nconst mapDispatchToProps = dispatch => ({\n  setVolume: payload => dispatch(setVolume(payload)),\n  setDuration: payload => dispatch(setVolume(payload)),\n  setDuration: payload => dispatch(setVolume(payload))\n});\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Video); // export default withAdobeHeartbeat(\n//   connect(\n//     (state) => ({\n//       userAutoplaySetting: state.userAutoplaySetting,\n//       buffering: state.buffering,\n//       clipCompletedCallback: state.clipCompletedCallback,\n//       clipId: state.clipId,\n//       versionId: state.versionId,\n//       closedCaptioningEnabled: state.closedCaptioningEnabled,\n//       closedCaptioningLanguage: state.closedCaptioningLanguage,\n//       currentResolution: state.currentResolution,\n//       currentUrlIndex: state.currentUrlIndex,\n//       loading: state.loading,\n//       muted: state.muted,\n//       nextCallback: state.nextCallback,\n//       resolution: state.resolutionValue,\n//       playbackRate: state.playbackSpeed,\n//       playing: state.playing,\n//       poster: state.poster,\n//       time: state.time,\n//       title: state.title,\n//       urls: state.urls,\n//       userId: state.userId,\n//       version: state.versions ? state.versions.VERSION : '0.0.0',\n//       volume: state.volume,\n//       mediaType: state.mediaType,\n//       preferredResolutions: state.preferredResolutions,\n//       overlay: state.overlay,\n//       isStagingEnv: state.isStagingEnv,\n//       autoPlay: state.autoPlay,\n//     }),\n//     (store) => ({\n//       registerPlayer: actions.registerPlayer,\n//       seekStart: actions.seekStart,\n//       onVideoError: actions.onVideoError,\n//       setBuffering: actions.setBuffering,\n//       setLoading: actions.setLoading,\n//       setMediaType: actions.setMediaType,\n//       setLoading: actions.setLoading,\n//       setCurrentResolution: actions.setCurrentResolution,\n//       setSupportedResolutions: actions.setSupportedResolutions,\n//       requestUrls: actions.requestUrls,\n//       end: actions.end,\n//       ready: actions.ready,\n//       pause: actions.pause,\n//       play: actions.play,\n//       setClosedCaptioningCueList: actions.setClosedCaptioningCueList,\n//       setFullscreen: actions.setFullscreen,\n//       setOverlay: actions.setOverlay,\n//       setClipProgress: actions.setClipProgress,\n//       setPlaying: actions.setPlaying,\n//       setBufferedTime: actions.setBufferedTime,\n//       setDuration: actions.setDuration,\n//       setTime: actions.setTime,\n//     })\n//   )(Video)\n// )","map":{"version":3,"sources":["/Users/akrah/Documents/dev/readux/src/codefluent/src/portal/scenes/CoursePlayer/video/video.js"],"names":["React","Component","connect","setVolume","setDuration","setTime","css","DefaultResolutions","FullscreenState","HLS_SDK_URL","HLS_SDK_URL_SAFARI","MediaTypes","getSDK","throttle","mapHlsError","mapGenericVideoError","HLS_EXTENSIONS","initialState","isPlaying","reportedVolume","reportedPlaybackRate","isBuffering","canPlay","ready","Video","constructor","props","newReadyPromise","Promise","resolve","setState","isSafari","navigator","vendor","match","isHlsSource","source","test","destroyHls","hlsPlaying","hls","destroy","startHls","setSupportedResolutions","setMediaType","setCurrentResolution","preferredResolutions","currentResolution","time","sdkUrl","Hls","isSupported","MP4","autoStartLoad","loadSource","videoElement","document","getElementById","attachMedia","on","Events","MANIFEST_PARSED","event","data","startLoad","autoLevel","height","index","supportedResolutions","levels","map","r","width","indexOf","concat","preferredResolution","newResolution","find","currentLevel","resolutionShouldChange","ERROR","handleHlsError","bind","MEDIA_ATTACHED","onHlsLevelChange","requestNewUrls","setLoading","requestUrls","onMediaTypeChange","newMediaType","HLS","resolution","WEBM","iosEndFullscreen","setFullscreen","NORMAL","percent","onReady","state","then","current","player","element","muted","isFinite","volume","setPlaybackRate","rate","playbackRate","onCaptionUpdate","e","currentTarget","activeCues","setClosedCaptioningCueList","toggleCaptions","language","textTracks","forEach","track","mode","code","oncuechange","seekTo","amount","currentTime","onRateChange","onVolumeChange","onPlay","onPause","setPlaying","onCanPlay","setBuffering","buffering","loading","adobeHeartbeat","onLoadedData","onEnded","updateTracks","onLoadedMetadata","getSrc","currentUrlIndex","urls","onSeeking","onSeeked","updateProgress","onProgress","onWaiting","clipId","videoSrc","createRef","componentDidMount","playing","closedCaptioningEnabled","closedCaptioningLanguage","mediaType","userAutoplaySetting","setClipProgress","throttledSetClipProgress","src","maybeStartHls","componentWillUnmount","clearTimeout","progressTimeout","shouldPlayHls","componentWillReceiveProps","nextProps","newSource","sourceDidChange","captionsDidChange","resolutionDidChange","mediaTypeDidChange","trackComplete","play","pause","console","log","timeDelta","Math","abs","getPlayedSeconds","connectIosFullscreenExit","webkitExitFullscreen","addEventListener","promise","catch","onError","getDuration","duration","getSecondsLoaded","renderTrack","render","video","mapStateToProps","playbackSpeed","mapDispatchToProps","dispatch","payload"],"mappings":"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","sourcesContent":["import React, { Component } from 'react'\nimport { connect } from 'react-redux';\nimport { setVolume, setDuration,setTime } from 'state/player/playerSlice';\nimport css from './video.module.css'\n\n\nimport { DefaultResolutions } from '../constants'\n\n// import withAdobeHeartbeat from './with-adobe-heartbeat'\n\n\nimport { FullscreenState, HLS_SDK_URL, HLS_SDK_URL_SAFARI, MediaTypes } from '../constants'\nimport { getSDK } from '../utilities/get-sdk';\nimport { throttle } from '../utilities/throttle';\n// import { sendPlaySuccessEvent } from '../../analytics/player-events'\nimport { mapHlsError, mapGenericVideoError } from '../utilities/video-error'\n\nconst HLS_EXTENSIONS = /\\.(m3u8)($|\\?)/i\nconst initialState = {\n  isPlaying: false,\n  reportedVolume: null,\n  reportedPlaybackRate: 1,\n  isBuffering: false,\n  canPlay: false,\n  ready: true,\n}\n\nexport class Video extends Component {\n  constructor(props) {\n    super(props)\n\n    this.state = {\n      ...initialState,\n      clipId: props.clipId,\n      onReady: this.newReadyPromise(),\n      hlsPlaying: false,\n      videoSrc: null,\n    }\n\n    this.element = React.createRef()\n  }\n\n  newReadyPromise = () => {\n    return new Promise((resolve) => {\n      this.ready = () => {\n        this.setState({ ready: true }, () => {\n          resolve()\n        })\n      }\n    })\n  }\n\n  isSafari = () => navigator.vendor.match(/apple/i)\n\n  componentDidMount() {\n    const {\n      playing,\n      volume,\n      muted,\n      playbackRate,\n      time,\n      closedCaptioningEnabled,\n      closedCaptioningLanguage,\n      mediaType,\n      userAutoplaySetting,\n      setClipProgress,\n    } = this.props\n    this.throttledSetClipProgress = throttle(setClipProgress, 1000)\n    const src = this.getSrc(this.props)\n\n    if (muted || volume !== null) {\n      volume && this.setVolume(muted ? 0 : volume)\n    }\n\n    if (playbackRate) {\n      this.setPlaybackRate(playbackRate)\n    }\n\n    if (time) {\n      this.seekTo(time)\n    }\n\n    if (closedCaptioningEnabled) {\n      this.toggleCaptions(closedCaptioningLanguage)\n    }\n\n    if (src) {\n      this.maybeStartHls(src, mediaType)\n    }\n    this.onMediaTypeChange(mediaType)\n  }\n\n  componentWillUnmount() {\n    this.destroyHls()\n    clearTimeout(this.progressTimeout)\n  }\n\n  maybeStartHls(source, mediaType) {\n    const { setMediaType } = this.props\n    const { hlsPlaying } = this.state\n    const isHlsSource = this.isHlsSource(source)\n    const shouldPlayHls = mediaType === MediaTypes.HLS && isHlsSource\n\n    if (hlsPlaying) this.destroyHls()\n\n    if (shouldPlayHls) {\n      this.startHls(source)\n    }\n\n    if (mediaType === MediaTypes.HLS && !shouldPlayHls) {\n      setMediaType && setMediaType(MediaTypes.MP4)\n    }\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const {\n      adobeHeartbeat,\n      clipId,\n      closedCaptioningEnabled,\n      closedCaptioningLanguage,\n      currentUrlIndex,\n      mediaType,\n      currentResolution,\n      setClosedCaptioningCueList,\n    } = this.props\n    const { reportedPlaybackRate, reportedVolume, ready, isPlaying, hlsPlaying } = this.state\n\n    const newSource = this.getSrc(nextProps)\n\n    // Handle URL change\n    const sourceDidChange =\n      currentUrlIndex !== nextProps.currentUrlIndex ||\n      clipId !== nextProps.clipId ||\n      mediaType !== nextProps.mediaType ||\n      this.getSrc(this.props) !== newSource\n\n    const captionsDidChange =\n      nextProps.closedCaptioningEnabled !== closedCaptioningEnabled ||\n      nextProps.closedCaptioningLanguage !== closedCaptioningLanguage\n\n    const resolutionDidChange = nextProps.currentResolution !== currentResolution\n\n    const mediaTypeDidChange = mediaType && mediaType !== nextProps.mediaType\n\n    if (mediaTypeDidChange) this.onMediaTypeChange(nextProps.mediaType)\n\n    if (sourceDidChange && newSource) {\n      setClosedCaptioningCueList && setClosedCaptioningCueList(null)\n      this.maybeStartHls(newSource, mediaType)\n    }\n\n    if (sourceDidChange && ready) {\n      this.setState(\n        {\n          onReady: this.newReadyPromise(),\n          ready: false,\n          reportedVolume: null,\n          reportedPlaybackRate: null,\n          isPlaying: null,\n        },\n        () => {\n          adobeHeartbeat && adobeHeartbeat.trackComplete()\n        }\n      )\n    }\n   \n    if (!ready) {\n      return\n    }\n  \n    // Handle playing change\n    if (nextProps.playing && !isPlaying) {\n       \n      this.play()\n    }\n    if (!nextProps.playing && isPlaying) {\n      this.pause()\n    }\n\n    // Handle volume change\n    if (nextProps.volume !== null || nextProps.muted) {\n      if (!nextProps.muted) {\n        if (nextProps.volume !== reportedVolume) {\n          this.setVolume(nextProps.volume)\n        }\n      }\n\n      if (nextProps.muted && reportedVolume !== 0) {\n        this.setVolume(0)\n      }\n    }\n\n    // Handle playback rate change\n    console.log(\"Rate: \", nextProps.playbackRate)\n    if (nextProps.playbackRate !== reportedPlaybackRate) {\n      this.setPlaybackRate(nextProps.playbackRate)\n    }\n\n    // Handle time change\n    const timeDelta = Math.abs(nextProps.time - this.getPlayedSeconds())\n    \n    if (timeDelta >= 1) {\n      this.seekTo(nextProps.time)\n    }\n\n    if (captionsDidChange) {\n      this.toggleCaptions(nextProps.closedCaptioningLanguage)\n    }\n\n    if (resolutionDidChange && hlsPlaying) this.onHlsLevelChange(nextProps.currentResolution)\n  }\n\n  isHlsSource = (source) => HLS_EXTENSIONS.test(source)\n\n  destroyHls = () => {\n    this.setState({ hlsPlaying: false })\n    this.hls && this.hls.destroy()\n  }\n\n  startHls = async (source) => {\n    const {\n      setSupportedResolutions,\n      setMediaType,\n      setCurrentResolution,\n      preferredResolutions,\n      currentResolution,\n      time,\n    } = this.props\n    const sdkUrl = this.isSafari() ? HLS_SDK_URL_SAFARI : HLS_SDK_URL //https://github.com/video-dev/hls.js/issues/1543\n    const Hls = await getSDK(sdkUrl, 'Hls')\n    if (!Hls.isSupported()) return setMediaType && setMediaType(MediaTypes.MP4)\n    this.Hls = Hls\n\n    this.hls = new Hls({ autoStartLoad: false })\n    this.hls.loadSource(source)\n\n    const videoElement = document.getElementById('video-element')\n    this.hls.attachMedia(videoElement)\n\n    this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {\n      this.hls.startLoad(time || 0)\n      const autoLevel = { height: 'Auto', index: -1 }\n      const supportedResolutions = data.levels.map((r) => ({\n        width: r.width,\n        height: r.height,\n        index: data.levels.indexOf(r),\n      }))\n      setSupportedResolutions && setSupportedResolutions(supportedResolutions.concat(autoLevel))\n\n      const preferredResolution = preferredResolutions.hls ? preferredResolutions.hls : null\n      const newResolution =\n        preferredResolution &&\n        supportedResolutions.find(\n          (r) => preferredResolution.width === r.width && preferredResolution.height === r.height\n        )\n\n      if (!newResolution) {\n        setCurrentResolution && setCurrentResolution(autoLevel)\n        return\n      }\n\n      this.hls && (this.hls.currentLevel = newResolution.index)\n      const resolutionShouldChange = newResolution !== currentResolution\n      resolutionShouldChange && setCurrentResolution && setCurrentResolution(newResolution)\n    })\n    this.hls.on(Hls.Events.ERROR, this.handleHlsError.bind(this))\n    this.hls.on(Hls.Events.MEDIA_ATTACHED, (event, data) => {\n      this.setState({ hlsPlaying: true })\n    })\n  }\n\n  onHlsLevelChange = ({ height, index }) => {\n    const { currentResolution, setCurrentResolution } = this.props\n\n    if (height === currentResolution.height) {\n      return\n    }\n    this.hls && (this.hls.currentLevel = index)\n    setCurrentResolution && setCurrentResolution({ height, index })\n  }\n\n  requestNewUrls = () => {\n    const { setLoading, requestUrls } = this.props\n    requestUrls && requestUrls(true)\n    setLoading && setLoading(true)\n  }\n\n  onMediaTypeChange = (newMediaType) => {\n    const { setSupportedResolutions, setCurrentResolution, preferredResolutions } = this.props\n\n    if (newMediaType !== MediaTypes.HLS) {\n      setSupportedResolutions && setSupportedResolutions(DefaultResolutions[newMediaType])\n\n      const resolution = preferredResolutions && preferredResolutions[newMediaType]\n      setCurrentResolution && setCurrentResolution(resolution)\n    }\n\n    if (newMediaType === MediaTypes.WEBM || newMediaType === MediaTypes.MP4) {\n      this.requestNewUrls()\n    }\n  }\n\n  iosEndFullscreen = () => {\n    this.props.setFullscreen(FullscreenState.NORMAL)\n  }\n\n  connectIosFullscreenExit() {\n    const { onReady } = this.state\n    onReady.then(() => {\n      const { current: player } = this.element\n      if (player.webkitExitFullscreen) {\n        player.addEventListener('webkitendfullscreen', this.iosEndFullscreen, false)\n      }\n    })\n  }\n\n  //#region Player API\n  play() {\n    const { onReady } = this.state\n\n    onReady.then(() => {\n    //   const { adobeHeartbeat, clipId, title } = this.props\n      const { current: player } = this.element\n\n      if (player) {\n        const promise = player.play()\n\n        // adobeHeartbeat && adobeHeartbeat.trackPlay()\n\n        if (promise) {\n          promise.catch((e) => {\n            const { onError, pause } = this.props\n            pause && pause(false)\n\n            onError && onError(e)\n          })\n        }\n      }\n    })\n  }\n\n  pause() {\n    const { onReady } = this.state\n    const { adobeHeartbeat, onPause } = this.props\n\n    onReady.then(() => {\n      const { current: player } = this.element\n\n      player && player.pause()\n\n    //   adobeHeartbeat && adobeHeartbeat.trackPause()\n\n    //   onPause && onPause()\n    })\n  }\n\n  setVolume = (percent) => {\n    const { onReady } = this.state\n\n    onReady.then(() => {\n      const { current: player } = this.element\n      player && percent === 0 ? (player.muted = true) : (player.muted = false) // player.volume is read only on mobile iOS\n      player && isFinite(percent) && (player.volume = percent)\n    })\n  }\n\n  setPlaybackRate = (rate) => {\n    const { onReady } = this.state\n\n    onReady.then(() => {\n      const { current: player } = this.element\n\n      player && (player.playbackRate = rate)\n    })\n  }\n\n  onCaptionUpdate = (e) => {\n    e.currentTarget.activeCues && this.props.setClosedCaptioningCueList(e.currentTarget.activeCues)\n  }\n\n  toggleCaptions = (language) => {\n    const { onReady } = this.state\n\n    onReady.then(() => {\n      const { current: player } = this.element\n\n      player &&\n        [...player.textTracks].forEach((track) => {\n          if (track.mode === 'showing' && track.language !== language.code) track.mode = 'disabled'\n\n          if (track.language === language.code) {\n            track.oncuechange = this.onCaptionUpdate\n            track.mode = 'hidden'\n          } else {\n            track.oncuechange = null\n          }\n        })\n    })\n  }\n\n  seekTo = (amount) => {\n    const { onReady } = this.state\n\n    onReady.then(() => {\n      const { current: player } = this.element\n\n      player && (player.currentTime = amount)\n    })\n  }\n\n  getDuration() {\n    const { current: player } = this.element\n\n    return player ? player.duration : 0\n  }\n\n  getPlayedSeconds() {\n    const { current: player } = this.element\n\n    return player ? player.currentTime : 0\n  }\n\n  getSecondsLoaded() {\n    // const { current: player } = this.element\n\n    // if (!player) {\n    //   return 0\n    // }\n\n    // const bufferedLength = player.buffered.length\n\n    // if (bufferedLength === 0) return 0\n\n    // let maxBuffered = 0,\n    //   currentBuffered\n    // for (let i = 0; i < bufferedLength; i++) {\n    //   currentBuffered = player.buffered.end(i)\n    //   maxBuffered = currentBuffered > maxBuffered ? currentBuffered : maxBuffered\n    // }\n\n    // return maxBuffered\n  }\n  //#endregion\n\n  onRateChange = (rate) => {\n    const { current: player } = this.element\n\n    player && this.setState({ reportedPlaybackRate: player.playbackRate })\n  }\n\n  onVolumeChange = (rate) => {\n    const { current: player } = this.element\n\n    player && this.setState({ reportedVolume: player.volume })\n  }\n\n  onPlay = () => {\n    // const { setPlaying } = this.props\n    // const { isStagingEnv, urls, currentUrlIndex, userId } = this.props\n    this.setState({ isPlaying: true })\n    // const currentUrl = urls[currentUrlIndex || 0]\n    // // sendPlaySuccessEvent(currentUrl, isStagingEnv, userId)\n    // setPlaying && setPlaying(true)\n    // this.updateProgress()\n  }\n\n  onPause = () => {\n    const { setPlaying } = this.props\n    this.setState({ isPlaying: false })\n    // setPlaying && setPlaying(false)\n  }\n\n  onCanPlay = () => {\n    const { setBuffering, buffering, loading, setLoading, adobeHeartbeat } = this.props\n\n    // this.setState({ canPlay: true })\n    // if (loading) setLoading && setLoading(false)\n\n    // if (buffering) {\n    //   setBuffering && setBuffering(false)\n    //   adobeHeartbeat && adobeHeartbeat.trackBufferComplete()\n    // }\n  }\n\n  onLoadedData = () => {\n    // const { setBuffering, buffering, setOverlay, adobeHeartbeat } = this.props\n    // const { onReady } = this.state\n\n    // if (!buffering) {\n    //   this.setState({ isBuffering: true })\n    //   setBuffering && setBuffering(true)\n    // }\n\n    // setOverlay && setOverlay(null)\n\n    // onReady.then(() => {\n    //   const { current: player } = this.element\n    //   adobeHeartbeat && adobeHeartbeat.initHeartbeat(player.duration)\n    // })\n  }\n\n  onEnded = (e) => {\n    // const { adobeHeartbeat, clipCompletedCallback, end, nextCallback, pause, userAutoplaySetting, clipId } = this.props\n\n    // end && end()\n\n    // pause && pause(false)\n\n    // adobeHeartbeat && adobeHeartbeat.trackComplete()\n\n    // clipCompletedCallback && clipCompletedCallback(e)\n\n    // userAutoplaySetting && nextCallback && nextCallback(e)\n  }\n\n  renderTrack(language) {\n    // const { clipId, versionId } = this.props\n    // return (\n    //   <track\n    //     key={language.code}\n    //     label={language.name}\n    //     kind=\"captions\"\n    //     srcLang={language.code}\n    //     src={\"\"}\n    //   />\n    // )\n  }\n\n  updateTracks = (videoElement) => {\n    // const { closedCaptioningLanguage, closedCaptioningEnabled, setClosedCaptioningCueList } = this.props\n    // const tracks = videoElement && videoElement.textTracks\n\n    // tracks &&\n    //   Object.values(tracks).forEach((track) => {\n    //     const isActive = closedCaptioningEnabled && track.language === closedCaptioningLanguage.code\n\n    //     if (isActive) {\n    //       track.mode = 'hidden'\n    //       videoElement.textTracks[0].mode = 'hidden' // Firefox\n    //       track.oncuechange = (e) => {\n    //         e.currentTarget.activeCues && setClosedCaptioningCueList(e.currentTarget.activeCues)\n    //       }\n    //     } else {\n    //       track.mode = 'disabled'\n    //     }\n    //   })\n  }\n\n  onLoadedMetadata = () => {\n    // const { ready, registerPlayer } = this.props\n    this.ready()\n\n    // const duration = this.getDuration()\n    // ready && ready({ duration, hlsInstance: this.hls, hlsLibrary: this.Hls })\n\n    // const videoElement = document.getElementById('video-element')\n    // registerPlayer && registerPlayer(videoElement)\n    // this.updateTracks(videoElement)\n  }\n\n  getSrc = ({ currentUrlIndex, urls }) => {\n    // return currentUrlIndex !== null && urls && urls.length > 0 ? urls[currentUrlIndex].url : null\n  }\n\n  onSeeking = () => {\n    // const { adobeHeartbeat } = this.props\n\n    // adobeHeartbeat && adobeHeartbeat.trackSeekStart()\n  }\n\n  onSeeked = () => {\n    // const { adobeHeartbeat } = this.props\n\n    // adobeHeartbeat && adobeHeartbeat.trackSeekComplete()\n  }\n\n  updateProgress = () => {\n    // const { clipId, setTime, playing } = this.props\n    \n    // if (!playing) return\n\n    // const reportedTime = this.getPlayedSeconds()\n    // setTime && setTime(reportedTime)\n    // reportedTime > 0 && this.throttledSetClipProgress({clipId, videoSecondsWatched: reportedTime })\n\n    // this.progressTimeout = setTimeout(this.updateProgress, 50)\n  }\n\n  onProgress = () => {\n    // const { setBufferedTime } = this.props\n    // const bufferedTime = this.getSecondsLoaded()\n\n    // setBufferedTime && setBufferedTime(bufferedTime)\n  }\n\n  handleHlsError(event, data) {\n    // const { onVideoError } = this.props\n    // if (data.fatal) {\n    //   switch (data.type) {\n    //     case this.Hls.ErrorTypes.MEDIA_ERROR:\n    //       this.hls.recoverMediaError()\n    //       break\n    //     default:\n    //       this.destroyHls()\n    //       onVideoError && onVideoError(mapHlsError(data), 'handleHlsError')\n    //       break\n    //   }\n    // }\n  }\n\n  onWaiting = () => {\n    // const { adobeHeartbeat, setBuffering } = this.props\n    // adobeHeartbeat && adobeHeartbeat.trackBufferStart()\n    // setBuffering && setBuffering(true)\n  }\n\n  render() {\n    // const { onVideoError, versionId, closedCaptioningLanguage, mediaType } = this.props\n    const { playbackRate } = this.props;\n    console.log(\"PlayBackRate: \", playbackRate)\n    // let source = this.getSrc(this.props)\n    let source = \"https://archive.org/download/ElephantsDream/ed_1024_512kb.mp4\";\n\n    if (!source) {\n      return <div className={css.video} />\n    }\n\n    // if (mediaType === MediaTypes.HLS) source = undefined\n   \n    return (\n      <video\n        id=\"video-element\"\n        key={source}\n        className={css.video}\n        ref={this.element}\n        src={source}\n        preload=\"auto\"\n        playsInline\n        controls={false}\n        loop={false}\n        onLoadedMetadata={this.onLoadedMetadata}\n        // onLoadedData={this.onLoadedData}\n        // onCanPlay={this.onCanPlay}\n        onPlay={this.onPlay}\n        // onSeeking={this.onSeeking}\n        // onSeeked={this.onSeeked}\n        onPause={this.onPause}\n        // onEnded={this.onEnded}\n        onVolumeChange={this.onVolumeChange}\n        onRateChange={this.onRateChange}\n        // onWaiting={this.onWaiting}\n        // onProgress={this.onProgress}\n        // onError={(e) => {\n        //   const { current: player } = this.element\n        //   onVideoError && onVideoError(mapGenericVideoError(player.error), 'videoElement.onError')\n        // }}\n      >\n        {/* {closedCaptioningLanguage && versionId && this.renderTrack(closedCaptioningLanguage)} */}\n      </video>\n    )\n  }\n}\n\nconst mapStateToProps = state => ({\n    playing: state.player.playing,\n    playbackRate: state.player.playbackSpeed,\n    volume: state.player.volume,\n    muted: state.player.muted,\n\n})\n\nconst mapDispatchToProps = dispatch => ({\n    setVolume: payload => dispatch(setVolume(payload)),\n    setDuration: payload => dispatch(setVolume(payload)),\n    setDuration: payload => dispatch(setVolume(payload))\n\n})\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Video);\n\n// export default withAdobeHeartbeat(\n//   connect(\n//     (state) => ({\n//       userAutoplaySetting: state.userAutoplaySetting,\n//       buffering: state.buffering,\n//       clipCompletedCallback: state.clipCompletedCallback,\n//       clipId: state.clipId,\n//       versionId: state.versionId,\n//       closedCaptioningEnabled: state.closedCaptioningEnabled,\n//       closedCaptioningLanguage: state.closedCaptioningLanguage,\n//       currentResolution: state.currentResolution,\n//       currentUrlIndex: state.currentUrlIndex,\n//       loading: state.loading,\n//       muted: state.muted,\n//       nextCallback: state.nextCallback,\n//       resolution: state.resolutionValue,\n//       playbackRate: state.playbackSpeed,\n//       playing: state.playing,\n//       poster: state.poster,\n//       time: state.time,\n//       title: state.title,\n//       urls: state.urls,\n//       userId: state.userId,\n//       version: state.versions ? state.versions.VERSION : '0.0.0',\n//       volume: state.volume,\n//       mediaType: state.mediaType,\n//       preferredResolutions: state.preferredResolutions,\n//       overlay: state.overlay,\n//       isStagingEnv: state.isStagingEnv,\n//       autoPlay: state.autoPlay,\n//     }),\n//     (store) => ({\n//       registerPlayer: actions.registerPlayer,\n//       seekStart: actions.seekStart,\n//       onVideoError: actions.onVideoError,\n//       setBuffering: actions.setBuffering,\n//       setLoading: actions.setLoading,\n//       setMediaType: actions.setMediaType,\n//       setLoading: actions.setLoading,\n//       setCurrentResolution: actions.setCurrentResolution,\n//       setSupportedResolutions: actions.setSupportedResolutions,\n//       requestUrls: actions.requestUrls,\n//       end: actions.end,\n//       ready: actions.ready,\n//       pause: actions.pause,\n//       play: actions.play,\n//       setClosedCaptioningCueList: actions.setClosedCaptioningCueList,\n//       setFullscreen: actions.setFullscreen,\n//       setOverlay: actions.setOverlay,\n//       setClipProgress: actions.setClipProgress,\n//       setPlaying: actions.setPlaying,\n//       setBufferedTime: actions.setBufferedTime,\n//       setDuration: actions.setDuration,\n//       setTime: actions.setTime,\n//     })\n//   )(Video)\n// )\n"]},"metadata":{},"sourceType":"module"}
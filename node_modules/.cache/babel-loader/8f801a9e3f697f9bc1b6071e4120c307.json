{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport createBrowserHistory from 'rudy-history/createBrowserHistory';\nimport createMemoryHistory from 'rudy-history/createMemoryHistory';\nimport { stripTrailingSlash, addLeadingSlash } from 'rudy-history/PathUtils';\nimport pathToAction from './pure-utils/pathToAction';\nimport { nestHistory } from './pure-utils/nestAction';\nimport isLocationAction from './pure-utils/isLocationAction';\nimport isRedirectAction from './pure-utils/isRedirectAction';\nimport isServer from './pure-utils/isServer';\nimport isReactNative from './pure-utils/isReactNative';\nimport changePageTitle, { getDocument } from './pure-utils/changePageTitle';\nimport attemptCallRouteThunk from './pure-utils/attemptCallRouteThunk';\nimport createThunk from './pure-utils/createThunk';\nimport pathnamePlusSearch from './pure-utils/pathnamePlusSearch';\nimport canUseDom from './pure-utils/canUseDom';\nimport { clearBlocking, createConfirm, confirmUI, setDisplayConfirmLeave, getUserConfirmation } from './pure-utils/confirmLeave';\nimport historyCreateAction from './action-creators/historyCreateAction';\nimport middlewareCreateAction from './action-creators/middlewareCreateAction';\nimport middlewareCreateNotFoundAction from './action-creators/middlewareCreateNotFoundAction';\nimport createLocationReducer, { getInitialState } from './reducer/createLocationReducer';\nimport { NOT_FOUND, ADD_ROUTES } from './index';\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n/** PRIMARY EXPORT - `connectRoutes(history, routeMap, options)`:\n *\n *  PURPOSE: to provide set-it-forget-it syncing of actions to the address bar and vice\n *  versa, using the pairing of action types to express-style routePaths bi-directionally.\n *\n *  EXAMPLE:\n *  with routeMap `{ FOO: '/foo/:paramName' }`,\n *\n *  pathname '/foo/bar' would become:\n *  `{ type: 'FOO', payload: { paramName: 'bar' } }`\n *\n *  AND\n *\n *  action `{ type: 'FOO', payload: { paramName: 'bar' } }`\n *  becomes: pathname '/foo/bar'\n *\n *\n *  HOW: Firstly, the middleware listens to received actions and then converts them to the\n *  pathnames it applies to the address bar (via `history.push({ pathname })`. It also formats\n *  the action to be location-aware, primarily by including a matching pathname, which the\n *  location reducer listens to, and which user reducers can also make use of.\n *\n *  However, user reducers typically only need to  be concerned with the type\n *  and payload like they are accustomed to. That's the whole purpose of this package.\n *  The idea is by matching action types to routePaths, it's set it and forget it!\n *\n *  Secondly, a history listener listens to URL changes and dispatches actions with\n *  types and payloads that match the pathname. Hurray! Browse back/next buttons now work!\n *\n *  Both the history listener and middleware are made to not get into each other's way, i.e.\n *  avoiding double dispatching and double address bar changes.\n *\n *\n *  VERY IMPORTANT NOTE ON SSR: if you're wondering, `connectRoutes()` when called returns\n *  functions in a closure that provide access to variables in a private\n *  \"per instance\" fashion in order to be used in SSR without leaking\n *  state between SSR requests :).\n *\n *  As much as possible has been refactored out of this file into pure or\n *  near-pure utility functions.\n*/\n\n\nexport default (function () {\n  var routesMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (__DEV__) {\n    if (options.restoreScroll && typeof options.restoreScroll !== 'function') {\n      throw new Error('[redux-first-router] invalid `restoreScroll` option. Using\\n        https://github.com/faceyspacey/redux-first-router-restore-scroll\\n        please call `restoreScroll` and assign it the option key\\n        of the same name.');\n    }\n  }\n  /** INTERNAL ENCLOSED STATE (PER INSTANCE FOR SSR!) */\n\n\n  var _options$notFoundPath = options.notFoundPath,\n      notFoundPath = _options$notFoundPath === undefined ? '/not-found' : _options$notFoundPath,\n      _options$scrollTop = options.scrollTop,\n      scrollTop = _options$scrollTop === undefined ? false : _options$scrollTop,\n      location = options.location,\n      title = options.title,\n      onBeforeChange = options.onBeforeChange,\n      onAfterChange = options.onAfterChange,\n      onBackNext = options.onBackNext,\n      restoreScroll = options.restoreScroll,\n      _options$initialDispa = options.initialDispatch,\n      shouldPerformInitialDispatch = _options$initialDispa === undefined ? true : _options$initialDispa,\n      querySerializer = options.querySerializer,\n      displayConfirmLeave = options.displayConfirmLeave,\n      extra = options.extra; // The options must be initialized ASAP to prevent empty options being\n  // received in `getOptions` after the initial events emitted\n\n  _options = options;\n  setDisplayConfirmLeave(displayConfirmLeave);\n\n  if (options.basename) {\n    options.basename = stripTrailingSlash(addLeadingSlash(options.basename));\n  }\n\n  var isBrowser = canUseDom && process.env.NODE_ENV !== 'test';\n  var standard = isBrowser ? createBrowserHistory : createMemoryHistory;\n  var createHistory = options.createHistory || standard;\n  var entries = options.initialEntries || '/'; // fyi only memoryHistory needs initialEntries\n\n  var initialEntries = typeof entries === 'string' ? [entries] : entries;\n  var history = createHistory({\n    basename: options.basename,\n    initialEntries: initialEntries,\n    getUserConfirmation: getUserConfirmation\n  }); // very important: used for comparison to determine address bar changes\n\n  var currentPath = pathnamePlusSearch(history.location);\n  var prevLocation = {\n    // maintains previous location state in location reducer\n    pathname: '',\n    type: '',\n    payload: {}\n  };\n  var selectLocationState = typeof location === 'function' ? location : location ? function (state) {\n    return state[location];\n  } : function (state) {\n    return state.location;\n  };\n  var selectTitleState = typeof title === 'function' ? title : title ? function (state) {\n    return state[title];\n  } : function (state) {\n    return state.title;\n  };\n  var scrollBehavior = restoreScroll && restoreScroll(history);\n  var initialAction = pathToAction(currentPath, routesMap, querySerializer);\n  var type = initialAction.type,\n      payload = initialAction.payload,\n      meta = initialAction.meta;\n  var INITIAL_LOCATION_STATE = getInitialState(currentPath, meta, type, payload, routesMap, history);\n  var prevState = INITIAL_LOCATION_STATE; // used only to pass  as 1st arg to `scrollBehavior.updateScroll` if used\n\n  var nextState = {}; // used as 2nd arg to `scrollBehavior.updateScroll` and to change `document.title`\n\n  var prevLength = 1; // used by `historyCreateAction` to calculate if moving along history.entries track\n\n  var reducer = createLocationReducer(INITIAL_LOCATION_STATE, routesMap);\n  var initialBag = {\n    action: initialAction,\n    extra: extra\n  };\n  var thunk = createThunk(routesMap, selectLocationState, initialBag);\n\n  var initialDispatch = function initialDispatch() {\n    return _initialDispatch && _initialDispatch();\n  };\n\n  var windowDocument = getDocument(); // get plain object for window.document if server side\n\n  var navigators = void 0;\n  var patchNavigators = void 0;\n  var actionToNavigation = void 0;\n  var navigationToAction = void 0; // this value is used to hold temp state between consecutive runs through\n  // the middleware (i.e. from new dispatches triggered within the middleware)\n\n  var tempVal = void 0;\n\n  if (options.navigators) {\n    // redux-first-router-navigation reformats the `navigators` option\n    // to have the navigators nested one depth deeper, so as to include\n    // the various helper functions from its package\n    if (__DEV__ && !options.navigators.navigators) {\n      throw new Error('[redux-first-router] invalid `navigators` option. Pass your map\\n        of navigators to the default import from \\'redux-first-router-navigation\\'.\\n        Don\\'t forget: the keys are your redux state keys.');\n    }\n\n    navigators = options.navigators.navigators;\n    patchNavigators = options.navigators.patchNavigators;\n    actionToNavigation = options.navigators.actionToNavigation;\n    navigationToAction = options.navigators.navigationToAction;\n    patchNavigators(navigators);\n  }\n  /** MIDDLEWARE\n   *  1)  dispatches actions with location info in the `meta` key by matching the received action\n   *      type + payload to express style routePaths (which also results in location reducer state updating)\n   *  2)  changes the address bar url and page title if the currentPathName changes, while\n   *      avoiding collisions with simultaneous browser history changes\n  */\n\n\n  var middleware = function middleware(store) {\n    return function (next) {\n      return function (action) {\n        // We have chosen to not change routes on errors, while letting other middleware\n        // handle it. Perhaps in the future we will explicitly handle it (as an option)\n        if (action.error) return next(action); // code-splitting functionliaty to add routes after store is initially configured\n\n        if (action.type === ADD_ROUTES) {\n          var _selectLocationState2 = selectLocationState(store.getState()),\n              _type = _selectLocationState2.type;\n\n          var _route = routesMap[_type];\n          routesMap = _extends({}, routesMap, action.payload.routes);\n          var result = next(action);\n          var nextRoute = routesMap[_type];\n\n          if (_route !== nextRoute) {\n            if (_confirm !== null) {\n              clearBlocking();\n            }\n\n            if ((typeof nextRoute === 'undefined' ? 'undefined' : _typeof(nextRoute)) === 'object' && nextRoute.confirmLeave) {\n              _confirm = createConfirm(nextRoute.confirmLeave, store, selectLocationState, history, querySerializer, function () {\n                return _confirm = null;\n              });\n            }\n          }\n\n          return result;\n        } // navigation transformation specific to React Navigation\n\n\n        var navigationAction = void 0;\n\n        if (navigators && action.type.indexOf('Navigation/') === 0) {\n          var _navigationToAction = navigationToAction(navigators, store, routesMap, action);\n\n          navigationAction = _navigationToAction.navigationAction;\n          action = _navigationToAction.action;\n        }\n\n        var route = routesMap[action.type]; // We now support \"routes\" without paths for the purpose of dispatching thunks according\n        // to the same idiom as full-fledged routes. The purpose is uniformity of async actions.\n        // The URLs will NOT change.\n\n        if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object' && !route.path) {\n          var _nextAction = next(action);\n\n          attemptCallRouteThunk(store.dispatch, store.getState, route, selectLocationState, {\n            action: _nextAction,\n            extra: extra\n          });\n          return _nextAction;\n        } // START THE TYPICAL FLOW:\n\n\n        if (action.type === NOT_FOUND && !isLocationAction(action)) {\n          // user decided to dispatch `NOT_FOUND`, so we fill in the missing location info\n          action = middlewareCreateNotFoundAction(action, selectLocationState(store.getState()), prevLocation, history, notFoundPath);\n        } else if (route && !isLocationAction(action)) {\n          // THE MAGIC: dispatched action matches a connected type, so we generate a\n          // location-aware action and also as a result update location reducer state.\n          action = middlewareCreateAction(action, routesMap, prevLocation, history, notFoundPath, querySerializer);\n        }\n\n        if (navigators) {\n          action = actionToNavigation(navigators, action, navigationAction, route);\n        } // DISPATCH LIFECYLE:\n\n\n        var skip = void 0;\n\n        if ((route || action.type === NOT_FOUND) && action.meta) {\n          // satisify flow with `action.meta` check\n          skip = _beforeRouteChange(store, history, action);\n        }\n\n        if (skip) return;\n        var nextAction = next(action);\n\n        if (route || action.type === NOT_FOUND) {\n          _afterRouteChange(store, route, nextAction);\n        }\n\n        return nextAction;\n      };\n    };\n  };\n\n  var _beforeRouteChange = function _beforeRouteChange(store, history, action) {\n    var location = action.meta.location;\n\n    if (_confirm) {\n      var message = _confirm(location.current);\n\n      if (message) {\n        confirmUI(message, store, action);\n        return true; // skip if there's a message to show in the confirm UI\n      }\n\n      _confirm = null;\n    }\n\n    if (onBeforeChange) {\n      var skip = void 0;\n\n      var redirectAwareDispatch = function redirectAwareDispatch(action) {\n        if (isRedirectAction(action)) {\n          skip = true;\n          prevLocation = location.current;\n\n          var _nextPath = pathnamePlusSearch(location.current);\n\n          var isHistoryChange = _nextPath === currentPath; // this insures a `history.push` is called instead of `history.replace`\n          // even though it's a redirect, since unlike route changes triggered\n          // from the browser buttons, the URL did not change yet.\n\n          if (!isHistoryChange && !isServer()) {\n            tempVal = 'onBeforeChange';\n          }\n        }\n\n        return store.dispatch(action);\n      };\n\n      var bag = {\n        action: action,\n        extra: extra\n      };\n      onBeforeChange(redirectAwareDispatch, store.getState, bag);\n      if (skip) return true;\n    }\n\n    prevState = selectLocationState(store.getState());\n    prevLocation = location.current;\n    prevLength = history.length; // addressbar updated before action dispatched like in history.listener\n\n    _middlewareAttemptChangeUrl(location, history); // now we can finally set the history on the action since we get its\n    // value from the `history` whose value only changes after `push()`\n\n\n    if (isReactNative()) {\n      location.history = nestHistory(history);\n    }\n  };\n\n  var _afterRouteChange = function _afterRouteChange(store, route, action) {\n    var dispatch = store.dispatch;\n    var state = store.getState();\n    var kind = selectLocationState(state).kind;\n    var title = selectTitleState(state);\n    var bag = {\n      action: action,\n      extra: extra\n    };\n    nextState = selectLocationState(state);\n\n    if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object') {\n      var skip = false;\n\n      var redirectAwareDispatch = function redirectAwareDispatch(action) {\n        if (isRedirectAction(action)) skip = true;\n        return store.dispatch(action);\n      };\n\n      attemptCallRouteThunk(redirectAwareDispatch, store.getState, route, selectLocationState, bag);\n      if (skip) return;\n    }\n\n    if (onAfterChange) {\n      onAfterChange(dispatch, store.getState, bag);\n    }\n\n    if (!isServer()) {\n      if (kind) {\n        if (typeof onBackNext === 'function' && /back|next|pop/.test(kind)) {\n          onBackNext(dispatch, store.getState, bag);\n        }\n\n        setTimeout(function () {\n          changePageTitle(windowDocument, title);\n\n          if (scrollTop) {\n            return window.scrollTo(0, 0);\n          }\n\n          _updateScroll(false);\n        });\n      }\n\n      if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object' && route.confirmLeave) {\n        _confirm = createConfirm(route.confirmLeave, store, selectLocationState, history, querySerializer, function () {\n          return _confirm = null;\n        });\n      }\n    }\n  };\n\n  var _middlewareAttemptChangeUrl = function _middlewareAttemptChangeUrl(location, history) {\n    // IMPORTANT: insure history hasn't already handled location change\n    var nextPath = pathnamePlusSearch(location.current);\n\n    if (nextPath !== currentPath) {\n      // keep currentPath up to date for comparison to prevent double dispatches\n      // between BROWSER back/forward button usage vs middleware-generated actions\n      currentPath = nextPath; // IMPORTANT: must happen before history.push() (to prevent double handling)\n      // for React Native, in the case `back` or `next` is\n      // not called directly, `middlewareCreateAction` may emulate\n      // `history` backNext actions to support features such\n      // as scroll restoration. In those cases, we need to prevent\n      // pushing new routes on to the entries array. `stealth` is\n      // a React Navigation feature for changing StackNavigators\n      // without triggering other navigators (such as a TabNavigator)\n      // to change as well. It allows you to reset hidden StackNavigators.\n\n      var kind = location.kind;\n      var manuallyInvoked = kind && /back|next|pop|stealth/.test(kind);\n\n      if (!manuallyInvoked) {\n        var isRedirect = kind === 'redirect' && tempVal !== 'onBeforeChange';\n        var method = isRedirect ? 'replace' : 'push';\n        history[method](currentPath); // change address bar corresponding to matched actions from middleware\n      }\n    }\n  };\n  /** ENHANCER\n   *  1)  dispatches actions with types and payload extracted from the URL pattern\n   *      when the browser history changes\n   *  2)  on load of the app dispatches an action corresponding to the initial url\n   */\n\n\n  var enhancer = function enhancer(createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      // routesMap stored in location reducer will be stringified as it goes from the server to client\n      // and as a result functions in route objects will be removed--here's how we insure we bring them back\n      if (!isServer() && preloadedState && selectLocationState(preloadedState)) {\n        selectLocationState(preloadedState).routesMap = routesMap;\n      }\n\n      var store = createStore(reducer, preloadedState, enhancer);\n      var state = store.getState();\n      var location = state && selectLocationState(state);\n\n      if (!location || !location.pathname) {\n        throw new Error('[redux-first-router] you must provide the key of the location\\n        reducer state and properly assigned the location reducer to that key.');\n      }\n\n      history.listen(_historyAttemptDispatchAction.bind(null, store)); // dispatch the first location-aware action so initial app state is based on the url on load\n\n      if (!location.hasSSR || isServer()) {\n        // only dispatch on client before SSR is setup, which passes state on to the client\n        _initialDispatch = function _initialDispatch() {\n          var action = historyCreateAction(currentPath, routesMap, prevLocation, history, 'load', querySerializer);\n          store.dispatch(action);\n        };\n\n        if (shouldPerformInitialDispatch !== false) {\n          _initialDispatch();\n        }\n      } else {\n        // set correct prevLocation on client that has SSR so that it will be\n        // assigned to `action.meta.location.prev` and the corresponding state\n        prevLocation = location;\n        var route = routesMap[location.type];\n\n        if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object' && route.confirmLeave) {\n          _confirm = createConfirm(route.confirmLeave, store, selectLocationState, history, querySerializer, function () {\n            return _confirm = null;\n          });\n        }\n      } // update the scroll position after initial rendering of page\n\n\n      if (!isServer()) setTimeout(function () {\n        return _updateScroll(false);\n      });\n      return store;\n    };\n  };\n\n  var _historyAttemptDispatchAction = function _historyAttemptDispatchAction(store, location, historyAction) {\n    // IMPORTANT: insure middleware hasn't already handled location change:\n    var nextPath = pathnamePlusSearch(location);\n\n    if (nextPath !== currentPath) {\n      var kind = historyAction === 'REPLACE' ? 'redirect' : historyAction; // THE MAGIC: parse the address bar path into a matched action\n\n      var action = historyCreateAction(nextPath, routesMap, prevLocation, history, kind.toLowerCase(), querySerializer, currentPath, prevLength);\n      currentPath = nextPath; // IMPORTANT: must happen before dispatch (to prevent double handling)\n\n      store.dispatch(action); // dispatch route type + payload corresponding to browser back/forward usage\n    }\n  };\n  /* SIDE_EFFECTS - client-only state that must escape closure */\n\n\n  _history = history;\n  _scrollBehavior = scrollBehavior;\n  _selectLocationState = selectLocationState;\n\n  var _initialDispatch = void 0;\n\n  var _confirm = null;\n\n  _updateScroll = function _updateScroll() {\n    var performedByUser = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (scrollBehavior) {\n      if (performedByUser || !scrollBehavior.manual) {\n        scrollBehavior.updateScroll(prevState, nextState);\n      }\n    } else if (__DEV__ && performedByUser) {\n      throw new Error('[redux-first-router] you must set the `restoreScroll` option before\\n        you can call `updateScroll`');\n    }\n  };\n  /* RETURN  */\n\n\n  return {\n    reducer: reducer,\n    middleware: middleware,\n    enhancer: enhancer,\n    thunk: thunk,\n    initialDispatch: initialDispatch,\n    // returned only for tests (not for use in application code)\n    _middlewareAttemptChangeUrl: _middlewareAttemptChangeUrl,\n    _afterRouteChange: _afterRouteChange,\n    _historyAttemptDispatchAction: _historyAttemptDispatchAction,\n    windowDocument: windowDocument,\n    history: history\n  };\n});\n/** SIDE EFFECTS:\n *  Client code needs a simple `push`,`back` + `next` functions because it's convenient for\n *  prototyping. It will not harm SSR, so long as you don't use it server side. So if you use it, that means DO NOT\n *  simulate clicking links server side--and dont do that, dispatch actions to setup state instead.\n *\n *  THE IDIOMATIC WAY: instead use https://github.com/faceyspacey/redux-first-router-link 's `<Link />`\n *  component to generate SEO friendly urls. As its `href` prop, you pass it a path, array of path\n *  segments or action, and internally it will use `connectRoutes` to change the address bar and\n *  dispatch the correct final action from middleware.\n *\n *  NOTE ON BACK FUNCTIONALITY: The better way to accomplish a back button is to use your redux state to determine\n *  the previous URL. The location reducer will also contain relevant info. But if you must,\n *  this is here for convenience and it basically simulates the user pressing the browser\n *  back button, which of course the system picks up and parses into an action.\n */\n\nvar _history = void 0;\n\nvar _scrollBehavior = void 0;\n\nvar _updateScroll = void 0;\n\nvar _selectLocationState = void 0;\n\nvar _options = void 0;\n\nexport var push = function push(pathname) {\n  return _history.push(pathname);\n};\nexport var replace = function replace(pathname) {\n  return _history.replace(pathname);\n};\nexport var back = function back() {\n  return _history.goBack();\n};\nexport var next = function next() {\n  return _history.goForward();\n};\nexport var go = function go(n) {\n  return _history.go(n);\n};\nexport var canGo = function canGo(n) {\n  return _history.canGo(n);\n};\nexport var canGoBack = function canGoBack() {\n  return !!(_history.entries && _history.entries[_history.index - 1]);\n};\nexport var canGoForward = function canGoForward() {\n  return !!(_history.entries && _history.entries[_history.index + 1]);\n};\nexport var prevPath = function prevPath() {\n  var entry = _history.entries[_history.index - 1];\n  return entry && entry.pathname;\n};\nexport var nextPath = function nextPath() {\n  var entry = _history.entries[_history.index + 1];\n  return entry && entry.pathname;\n};\nexport var history = function history() {\n  return _history;\n};\nexport var scrollBehavior = function scrollBehavior() {\n  return _scrollBehavior;\n};\nexport var updateScroll = function updateScroll() {\n  return _updateScroll && _updateScroll();\n};\nexport var selectLocationState = function selectLocationState(state) {\n  return _selectLocationState(state);\n};\nexport var getOptions = function getOptions() {\n  return _options || {};\n};","map":{"version":3,"sources":["/Users/akrah/Documents/dev/readux/src/codefluent/node_modules/redux-first-router/dist/es/connectRoutes.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","createBrowserHistory","createMemoryHistory","stripTrailingSlash","addLeadingSlash","pathToAction","nestHistory","isLocationAction","isRedirectAction","isServer","isReactNative","changePageTitle","getDocument","attemptCallRouteThunk","createThunk","pathnamePlusSearch","canUseDom","clearBlocking","createConfirm","confirmUI","setDisplayConfirmLeave","getUserConfirmation","historyCreateAction","middlewareCreateAction","middlewareCreateNotFoundAction","createLocationReducer","getInitialState","NOT_FOUND","ADD_ROUTES","__DEV__","process","env","NODE_ENV","routesMap","undefined","options","restoreScroll","Error","_options$notFoundPath","notFoundPath","_options$scrollTop","scrollTop","location","title","onBeforeChange","onAfterChange","onBackNext","_options$initialDispa","initialDispatch","shouldPerformInitialDispatch","querySerializer","displayConfirmLeave","extra","_options","basename","isBrowser","standard","createHistory","entries","initialEntries","history","currentPath","prevLocation","pathname","type","payload","selectLocationState","state","selectTitleState","scrollBehavior","initialAction","meta","INITIAL_LOCATION_STATE","prevState","nextState","prevLength","reducer","initialBag","action","thunk","_initialDispatch","windowDocument","navigators","patchNavigators","actionToNavigation","navigationToAction","tempVal","middleware","store","next","error","_selectLocationState2","getState","_type","_route","routes","result","nextRoute","_confirm","confirmLeave","navigationAction","indexOf","_navigationToAction","route","path","_nextAction","dispatch","skip","_beforeRouteChange","nextAction","_afterRouteChange","message","current","redirectAwareDispatch","_nextPath","isHistoryChange","bag","_middlewareAttemptChangeUrl","kind","test","setTimeout","window","scrollTo","_updateScroll","nextPath","manuallyInvoked","isRedirect","method","enhancer","createStore","preloadedState","listen","_historyAttemptDispatchAction","bind","hasSSR","historyAction","toLowerCase","_history","_scrollBehavior","_selectLocationState","performedByUser","manual","updateScroll","push","replace","back","goBack","goForward","go","n","canGo","canGoBack","index","canGoForward","prevPath","entry","getOptions"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport createBrowserHistory from 'rudy-history/createBrowserHistory';\n\nimport createMemoryHistory from 'rudy-history/createMemoryHistory';\nimport { stripTrailingSlash, addLeadingSlash } from 'rudy-history/PathUtils';\nimport pathToAction from './pure-utils/pathToAction';\nimport { nestHistory } from './pure-utils/nestAction';\nimport isLocationAction from './pure-utils/isLocationAction';\nimport isRedirectAction from './pure-utils/isRedirectAction';\nimport isServer from './pure-utils/isServer';\nimport isReactNative from './pure-utils/isReactNative';\nimport changePageTitle, { getDocument } from './pure-utils/changePageTitle';\nimport attemptCallRouteThunk from './pure-utils/attemptCallRouteThunk';\nimport createThunk from './pure-utils/createThunk';\nimport pathnamePlusSearch from './pure-utils/pathnamePlusSearch';\nimport canUseDom from './pure-utils/canUseDom';\n\nimport { clearBlocking, createConfirm, confirmUI, setDisplayConfirmLeave, getUserConfirmation } from './pure-utils/confirmLeave';\n\nimport historyCreateAction from './action-creators/historyCreateAction';\nimport middlewareCreateAction from './action-creators/middlewareCreateAction';\nimport middlewareCreateNotFoundAction from './action-creators/middlewareCreateNotFoundAction';\n\nimport createLocationReducer, { getInitialState } from './reducer/createLocationReducer';\nimport { NOT_FOUND, ADD_ROUTES } from './index';\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\n/** PRIMARY EXPORT - `connectRoutes(history, routeMap, options)`:\n *\n *  PURPOSE: to provide set-it-forget-it syncing of actions to the address bar and vice\n *  versa, using the pairing of action types to express-style routePaths bi-directionally.\n *\n *  EXAMPLE:\n *  with routeMap `{ FOO: '/foo/:paramName' }`,\n *\n *  pathname '/foo/bar' would become:\n *  `{ type: 'FOO', payload: { paramName: 'bar' } }`\n *\n *  AND\n *\n *  action `{ type: 'FOO', payload: { paramName: 'bar' } }`\n *  becomes: pathname '/foo/bar'\n *\n *\n *  HOW: Firstly, the middleware listens to received actions and then converts them to the\n *  pathnames it applies to the address bar (via `history.push({ pathname })`. It also formats\n *  the action to be location-aware, primarily by including a matching pathname, which the\n *  location reducer listens to, and which user reducers can also make use of.\n *\n *  However, user reducers typically only need to  be concerned with the type\n *  and payload like they are accustomed to. That's the whole purpose of this package.\n *  The idea is by matching action types to routePaths, it's set it and forget it!\n *\n *  Secondly, a history listener listens to URL changes and dispatches actions with\n *  types and payloads that match the pathname. Hurray! Browse back/next buttons now work!\n *\n *  Both the history listener and middleware are made to not get into each other's way, i.e.\n *  avoiding double dispatching and double address bar changes.\n *\n *\n *  VERY IMPORTANT NOTE ON SSR: if you're wondering, `connectRoutes()` when called returns\n *  functions in a closure that provide access to variables in a private\n *  \"per instance\" fashion in order to be used in SSR without leaking\n *  state between SSR requests :).\n *\n *  As much as possible has been refactored out of this file into pure or\n *  near-pure utility functions.\n*/\n\nexport default (function () {\n  var routesMap = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (__DEV__) {\n    if (options.restoreScroll && typeof options.restoreScroll !== 'function') {\n      throw new Error('[redux-first-router] invalid `restoreScroll` option. Using\\n        https://github.com/faceyspacey/redux-first-router-restore-scroll\\n        please call `restoreScroll` and assign it the option key\\n        of the same name.');\n    }\n  }\n\n  /** INTERNAL ENCLOSED STATE (PER INSTANCE FOR SSR!) */\n\n  var _options$notFoundPath = options.notFoundPath,\n      notFoundPath = _options$notFoundPath === undefined ? '/not-found' : _options$notFoundPath,\n      _options$scrollTop = options.scrollTop,\n      scrollTop = _options$scrollTop === undefined ? false : _options$scrollTop,\n      location = options.location,\n      title = options.title,\n      onBeforeChange = options.onBeforeChange,\n      onAfterChange = options.onAfterChange,\n      onBackNext = options.onBackNext,\n      restoreScroll = options.restoreScroll,\n      _options$initialDispa = options.initialDispatch,\n      shouldPerformInitialDispatch = _options$initialDispa === undefined ? true : _options$initialDispa,\n      querySerializer = options.querySerializer,\n      displayConfirmLeave = options.displayConfirmLeave,\n      extra = options.extra;\n\n  // The options must be initialized ASAP to prevent empty options being\n  // received in `getOptions` after the initial events emitted\n\n  _options = options;\n\n  setDisplayConfirmLeave(displayConfirmLeave);\n\n  if (options.basename) {\n    options.basename = stripTrailingSlash(addLeadingSlash(options.basename));\n  }\n\n  var isBrowser = canUseDom && process.env.NODE_ENV !== 'test';\n  var standard = isBrowser ? createBrowserHistory : createMemoryHistory;\n  var createHistory = options.createHistory || standard;\n  var entries = options.initialEntries || '/'; // fyi only memoryHistory needs initialEntries\n  var initialEntries = typeof entries === 'string' ? [entries] : entries;\n\n  var history = createHistory({\n    basename: options.basename,\n    initialEntries: initialEntries,\n    getUserConfirmation: getUserConfirmation\n  });\n\n  // very important: used for comparison to determine address bar changes\n  var currentPath = pathnamePlusSearch(history.location);\n\n  var prevLocation = {\n    // maintains previous location state in location reducer\n    pathname: '',\n    type: '',\n    payload: {}\n  };\n\n  var selectLocationState = typeof location === 'function' ? location : location ? function (state) {\n    return state[location];\n  } : function (state) {\n    return state.location;\n  };\n\n  var selectTitleState = typeof title === 'function' ? title : title ? function (state) {\n    return state[title];\n  } : function (state) {\n    return state.title;\n  };\n\n  var scrollBehavior = restoreScroll && restoreScroll(history);\n\n  var initialAction = pathToAction(currentPath, routesMap, querySerializer);\n  var type = initialAction.type,\n      payload = initialAction.payload,\n      meta = initialAction.meta;\n\n\n  var INITIAL_LOCATION_STATE = getInitialState(currentPath, meta, type, payload, routesMap, history);\n\n  var prevState = INITIAL_LOCATION_STATE; // used only to pass  as 1st arg to `scrollBehavior.updateScroll` if used\n  var nextState = {}; // used as 2nd arg to `scrollBehavior.updateScroll` and to change `document.title`\n  var prevLength = 1; // used by `historyCreateAction` to calculate if moving along history.entries track\n\n  var reducer = createLocationReducer(INITIAL_LOCATION_STATE, routesMap);\n  var initialBag = { action: initialAction, extra: extra };\n  var thunk = createThunk(routesMap, selectLocationState, initialBag);\n  var initialDispatch = function initialDispatch() {\n    return _initialDispatch && _initialDispatch();\n  };\n\n  var windowDocument = getDocument(); // get plain object for window.document if server side\n\n  var navigators = void 0;\n  var patchNavigators = void 0;\n  var actionToNavigation = void 0;\n  var navigationToAction = void 0;\n\n  // this value is used to hold temp state between consecutive runs through\n  // the middleware (i.e. from new dispatches triggered within the middleware)\n  var tempVal = void 0;\n\n  if (options.navigators) {\n    // redux-first-router-navigation reformats the `navigators` option\n    // to have the navigators nested one depth deeper, so as to include\n    // the various helper functions from its package\n    if (__DEV__ && !options.navigators.navigators) {\n      throw new Error('[redux-first-router] invalid `navigators` option. Pass your map\\n        of navigators to the default import from \\'redux-first-router-navigation\\'.\\n        Don\\'t forget: the keys are your redux state keys.');\n    }\n\n    navigators = options.navigators.navigators;\n    patchNavigators = options.navigators.patchNavigators;\n    actionToNavigation = options.navigators.actionToNavigation;\n    navigationToAction = options.navigators.navigationToAction;\n\n    patchNavigators(navigators);\n  }\n\n  /** MIDDLEWARE\n   *  1)  dispatches actions with location info in the `meta` key by matching the received action\n   *      type + payload to express style routePaths (which also results in location reducer state updating)\n   *  2)  changes the address bar url and page title if the currentPathName changes, while\n   *      avoiding collisions with simultaneous browser history changes\n  */\n\n  var middleware = function middleware(store) {\n    return function (next) {\n      return function (action) {\n        // We have chosen to not change routes on errors, while letting other middleware\n        // handle it. Perhaps in the future we will explicitly handle it (as an option)\n        if (action.error) return next(action);\n\n        // code-splitting functionliaty to add routes after store is initially configured\n        if (action.type === ADD_ROUTES) {\n          var _selectLocationState2 = selectLocationState(store.getState()),\n              _type = _selectLocationState2.type;\n\n          var _route = routesMap[_type];\n\n          routesMap = _extends({}, routesMap, action.payload.routes);\n\n          var result = next(action);\n          var nextRoute = routesMap[_type];\n\n          if (_route !== nextRoute) {\n            if (_confirm !== null) {\n              clearBlocking();\n            }\n\n            if ((typeof nextRoute === 'undefined' ? 'undefined' : _typeof(nextRoute)) === 'object' && nextRoute.confirmLeave) {\n              _confirm = createConfirm(nextRoute.confirmLeave, store, selectLocationState, history, querySerializer, function () {\n                return _confirm = null;\n              });\n            }\n          }\n\n          return result;\n        }\n\n        // navigation transformation specific to React Navigation\n        var navigationAction = void 0;\n\n        if (navigators && action.type.indexOf('Navigation/') === 0) {\n          var _navigationToAction = navigationToAction(navigators, store, routesMap, action);\n\n          navigationAction = _navigationToAction.navigationAction;\n          action = _navigationToAction.action;\n        }\n\n        var route = routesMap[action.type];\n\n        // We now support \"routes\" without paths for the purpose of dispatching thunks according\n        // to the same idiom as full-fledged routes. The purpose is uniformity of async actions.\n        // The URLs will NOT change.\n        if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object' && !route.path) {\n          var _nextAction = next(action);\n\n          attemptCallRouteThunk(store.dispatch, store.getState, route, selectLocationState, { action: _nextAction, extra: extra });\n\n          return _nextAction;\n        }\n\n        // START THE TYPICAL FLOW:\n\n        if (action.type === NOT_FOUND && !isLocationAction(action)) {\n          // user decided to dispatch `NOT_FOUND`, so we fill in the missing location info\n          action = middlewareCreateNotFoundAction(action, selectLocationState(store.getState()), prevLocation, history, notFoundPath);\n        } else if (route && !isLocationAction(action)) {\n          // THE MAGIC: dispatched action matches a connected type, so we generate a\n          // location-aware action and also as a result update location reducer state.\n          action = middlewareCreateAction(action, routesMap, prevLocation, history, notFoundPath, querySerializer);\n        }\n\n        if (navigators) {\n          action = actionToNavigation(navigators, action, navigationAction, route);\n        }\n\n        // DISPATCH LIFECYLE:\n        var skip = void 0;\n        if ((route || action.type === NOT_FOUND) && action.meta) {\n          // satisify flow with `action.meta` check\n          skip = _beforeRouteChange(store, history, action);\n        }\n\n        if (skip) return;\n        var nextAction = next(action);\n\n        if (route || action.type === NOT_FOUND) {\n          _afterRouteChange(store, route, nextAction);\n        }\n\n        return nextAction;\n      };\n    };\n  };\n\n  var _beforeRouteChange = function _beforeRouteChange(store, history, action) {\n    var location = action.meta.location;\n\n    if (_confirm) {\n      var message = _confirm(location.current);\n\n      if (message) {\n        confirmUI(message, store, action);\n        return true; // skip if there's a message to show in the confirm UI\n      }\n\n      _confirm = null;\n    }\n\n    if (onBeforeChange) {\n      var skip = void 0;\n\n      var redirectAwareDispatch = function redirectAwareDispatch(action) {\n        if (isRedirectAction(action)) {\n          skip = true;\n          prevLocation = location.current;\n          var _nextPath = pathnamePlusSearch(location.current);\n          var isHistoryChange = _nextPath === currentPath;\n\n          // this insures a `history.push` is called instead of `history.replace`\n          // even though it's a redirect, since unlike route changes triggered\n          // from the browser buttons, the URL did not change yet.\n          if (!isHistoryChange && !isServer()) {\n            tempVal = 'onBeforeChange';\n          }\n        }\n\n        return store.dispatch(action);\n      };\n\n      var bag = { action: action, extra: extra };\n      onBeforeChange(redirectAwareDispatch, store.getState, bag);\n      if (skip) return true;\n    }\n\n    prevState = selectLocationState(store.getState());\n    prevLocation = location.current;\n    prevLength = history.length;\n\n    // addressbar updated before action dispatched like in history.listener\n    _middlewareAttemptChangeUrl(location, history);\n\n    // now we can finally set the history on the action since we get its\n    // value from the `history` whose value only changes after `push()`\n    if (isReactNative()) {\n      location.history = nestHistory(history);\n    }\n  };\n\n  var _afterRouteChange = function _afterRouteChange(store, route, action) {\n    var dispatch = store.dispatch;\n    var state = store.getState();\n    var kind = selectLocationState(state).kind;\n    var title = selectTitleState(state);\n    var bag = { action: action, extra: extra };\n    nextState = selectLocationState(state);\n\n    if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object') {\n      var skip = false;\n\n      var redirectAwareDispatch = function redirectAwareDispatch(action) {\n        if (isRedirectAction(action)) skip = true;\n        return store.dispatch(action);\n      };\n\n      attemptCallRouteThunk(redirectAwareDispatch, store.getState, route, selectLocationState, bag);\n\n      if (skip) return;\n    }\n\n    if (onAfterChange) {\n      onAfterChange(dispatch, store.getState, bag);\n    }\n\n    if (!isServer()) {\n      if (kind) {\n        if (typeof onBackNext === 'function' && /back|next|pop/.test(kind)) {\n          onBackNext(dispatch, store.getState, bag);\n        }\n\n        setTimeout(function () {\n          changePageTitle(windowDocument, title);\n\n          if (scrollTop) {\n            return window.scrollTo(0, 0);\n          }\n\n          _updateScroll(false);\n        });\n      }\n\n      if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object' && route.confirmLeave) {\n        _confirm = createConfirm(route.confirmLeave, store, selectLocationState, history, querySerializer, function () {\n          return _confirm = null;\n        });\n      }\n    }\n  };\n\n  var _middlewareAttemptChangeUrl = function _middlewareAttemptChangeUrl(location, history) {\n    // IMPORTANT: insure history hasn't already handled location change\n    var nextPath = pathnamePlusSearch(location.current);\n    if (nextPath !== currentPath) {\n      // keep currentPath up to date for comparison to prevent double dispatches\n      // between BROWSER back/forward button usage vs middleware-generated actions\n      currentPath = nextPath; // IMPORTANT: must happen before history.push() (to prevent double handling)\n\n      // for React Native, in the case `back` or `next` is\n      // not called directly, `middlewareCreateAction` may emulate\n      // `history` backNext actions to support features such\n      // as scroll restoration. In those cases, we need to prevent\n      // pushing new routes on to the entries array. `stealth` is\n      // a React Navigation feature for changing StackNavigators\n      // without triggering other navigators (such as a TabNavigator)\n      // to change as well. It allows you to reset hidden StackNavigators.\n      var kind = location.kind;\n\n      var manuallyInvoked = kind && /back|next|pop|stealth/.test(kind);\n\n      if (!manuallyInvoked) {\n        var isRedirect = kind === 'redirect' && tempVal !== 'onBeforeChange';\n        var method = isRedirect ? 'replace' : 'push';\n        history[method](currentPath); // change address bar corresponding to matched actions from middleware\n      }\n    }\n  };\n\n  /** ENHANCER\n   *  1)  dispatches actions with types and payload extracted from the URL pattern\n   *      when the browser history changes\n   *  2)  on load of the app dispatches an action corresponding to the initial url\n   */\n\n  var enhancer = function enhancer(createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      // routesMap stored in location reducer will be stringified as it goes from the server to client\n      // and as a result functions in route objects will be removed--here's how we insure we bring them back\n      if (!isServer() && preloadedState && selectLocationState(preloadedState)) {\n        selectLocationState(preloadedState).routesMap = routesMap;\n      }\n\n      var store = createStore(reducer, preloadedState, enhancer);\n      var state = store.getState();\n      var location = state && selectLocationState(state);\n\n      if (!location || !location.pathname) {\n        throw new Error('[redux-first-router] you must provide the key of the location\\n        reducer state and properly assigned the location reducer to that key.');\n      }\n\n      history.listen(_historyAttemptDispatchAction.bind(null, store));\n\n      // dispatch the first location-aware action so initial app state is based on the url on load\n      if (!location.hasSSR || isServer()) {\n        // only dispatch on client before SSR is setup, which passes state on to the client\n        _initialDispatch = function _initialDispatch() {\n          var action = historyCreateAction(currentPath, routesMap, prevLocation, history, 'load', querySerializer);\n\n          store.dispatch(action);\n        };\n\n        if (shouldPerformInitialDispatch !== false) {\n          _initialDispatch();\n        }\n      } else {\n        // set correct prevLocation on client that has SSR so that it will be\n        // assigned to `action.meta.location.prev` and the corresponding state\n        prevLocation = location;\n\n        var route = routesMap[location.type];\n\n        if ((typeof route === 'undefined' ? 'undefined' : _typeof(route)) === 'object' && route.confirmLeave) {\n          _confirm = createConfirm(route.confirmLeave, store, selectLocationState, history, querySerializer, function () {\n            return _confirm = null;\n          });\n        }\n      }\n\n      // update the scroll position after initial rendering of page\n      if (!isServer()) setTimeout(function () {\n        return _updateScroll(false);\n      });\n\n      return store;\n    };\n  };\n\n  var _historyAttemptDispatchAction = function _historyAttemptDispatchAction(store, location, historyAction) {\n    // IMPORTANT: insure middleware hasn't already handled location change:\n    var nextPath = pathnamePlusSearch(location);\n\n    if (nextPath !== currentPath) {\n      var kind = historyAction === 'REPLACE' ? 'redirect' : historyAction;\n\n      // THE MAGIC: parse the address bar path into a matched action\n      var action = historyCreateAction(nextPath, routesMap, prevLocation, history, kind.toLowerCase(), querySerializer, currentPath, prevLength);\n\n      currentPath = nextPath; // IMPORTANT: must happen before dispatch (to prevent double handling)\n\n      store.dispatch(action); // dispatch route type + payload corresponding to browser back/forward usage\n    }\n  };\n\n  /* SIDE_EFFECTS - client-only state that must escape closure */\n\n  _history = history;\n  _scrollBehavior = scrollBehavior;\n  _selectLocationState = selectLocationState;\n\n  var _initialDispatch = void 0;\n  var _confirm = null;\n\n  _updateScroll = function _updateScroll() {\n    var performedByUser = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    if (scrollBehavior) {\n      if (performedByUser || !scrollBehavior.manual) {\n        scrollBehavior.updateScroll(prevState, nextState);\n      }\n    } else if (__DEV__ && performedByUser) {\n      throw new Error('[redux-first-router] you must set the `restoreScroll` option before\\n        you can call `updateScroll`');\n    }\n  };\n\n  /* RETURN  */\n\n  return {\n    reducer: reducer,\n    middleware: middleware,\n    enhancer: enhancer,\n    thunk: thunk,\n    initialDispatch: initialDispatch,\n\n    // returned only for tests (not for use in application code)\n    _middlewareAttemptChangeUrl: _middlewareAttemptChangeUrl,\n    _afterRouteChange: _afterRouteChange,\n    _historyAttemptDispatchAction: _historyAttemptDispatchAction,\n    windowDocument: windowDocument,\n    history: history\n  };\n});\n\n/** SIDE EFFECTS:\n *  Client code needs a simple `push`,`back` + `next` functions because it's convenient for\n *  prototyping. It will not harm SSR, so long as you don't use it server side. So if you use it, that means DO NOT\n *  simulate clicking links server side--and dont do that, dispatch actions to setup state instead.\n *\n *  THE IDIOMATIC WAY: instead use https://github.com/faceyspacey/redux-first-router-link 's `<Link />`\n *  component to generate SEO friendly urls. As its `href` prop, you pass it a path, array of path\n *  segments or action, and internally it will use `connectRoutes` to change the address bar and\n *  dispatch the correct final action from middleware.\n *\n *  NOTE ON BACK FUNCTIONALITY: The better way to accomplish a back button is to use your redux state to determine\n *  the previous URL. The location reducer will also contain relevant info. But if you must,\n *  this is here for convenience and it basically simulates the user pressing the browser\n *  back button, which of course the system picks up and parses into an action.\n */\n\nvar _history = void 0;\nvar _scrollBehavior = void 0;\nvar _updateScroll = void 0;\nvar _selectLocationState = void 0;\nvar _options = void 0;\n\nexport var push = function push(pathname) {\n  return _history.push(pathname);\n};\n\nexport var replace = function replace(pathname) {\n  return _history.replace(pathname);\n};\n\nexport var back = function back() {\n  return _history.goBack();\n};\n\nexport var next = function next() {\n  return _history.goForward();\n};\n\nexport var go = function go(n) {\n  return _history.go(n);\n};\n\nexport var canGo = function canGo(n) {\n  return _history.canGo(n);\n};\n\nexport var canGoBack = function canGoBack() {\n  return !!(_history.entries && _history.entries[_history.index - 1]);\n};\n\nexport var canGoForward = function canGoForward() {\n  return !!(_history.entries && _history.entries[_history.index + 1]);\n};\n\nexport var prevPath = function prevPath() {\n  var entry = _history.entries[_history.index - 1];\n  return entry && entry.pathname;\n};\n\nexport var nextPath = function nextPath() {\n  var entry = _history.entries[_history.index + 1];\n  return entry && entry.pathname;\n};\n\nexport var history = function history() {\n  return _history;\n};\n\nexport var scrollBehavior = function scrollBehavior() {\n  return _scrollBehavior;\n};\n\nexport var updateScroll = function updateScroll() {\n  return _updateScroll && _updateScroll();\n};\n\nexport var selectLocationState = function selectLocationState(state) {\n  return _selectLocationState(state);\n};\n\nexport var getOptions = function getOptions() {\n  return _options || {};\n};"]},"metadata":{},"sourceType":"module"}
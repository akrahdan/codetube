"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.trackNetworkError = exports.stopRuntimeErrorTracking = exports.startRuntimeErrorTracking = exports.stopConsoleTracking = exports.startConsoleTracking = exports.startAutomaticErrorCollection = void 0;
var tslib_1 = require("tslib");
var fetchProxy_1 = require("../browser/fetchProxy");
var xhrProxy_1 = require("../browser/xhrProxy");
var error_1 = require("../tools/error");
var observable_1 = require("../tools/observable");
var timeUtils_1 = require("../tools/timeUtils");
var utils_1 = require("../tools/utils");
var internalMonitoring_1 = require("./internalMonitoring");
var tracekit_1 = require("./tracekit");
var errorObservable;
function startAutomaticErrorCollection(configuration) {
    if (!errorObservable) {
        errorObservable = new observable_1.Observable();
        trackNetworkError(configuration, errorObservable);
        startConsoleTracking(errorObservable);
        startRuntimeErrorTracking(errorObservable);
    }
    return errorObservable;
}
exports.startAutomaticErrorCollection = startAutomaticErrorCollection;
var originalConsoleError;
/* eslint-disable no-console */
function startConsoleTracking(errorObservable) {
    originalConsoleError = console.error;
    console.error = function () {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            params[_i] = arguments[_i];
        }
        var handlingStack = error_1.createHandlingStack();
        internalMonitoring_1.callMonitored(function () {
            originalConsoleError.apply(console, params);
            errorObservable.notify(tslib_1.__assign(tslib_1.__assign({}, buildErrorFromParams(params, handlingStack)), { source: error_1.ErrorSource.CONSOLE, startClocks: timeUtils_1.clocksNow(), handling: error_1.ErrorHandling.HANDLED }));
        });
    };
}
exports.startConsoleTracking = startConsoleTracking;
function stopConsoleTracking() {
    console.error = originalConsoleError;
}
exports.stopConsoleTracking = stopConsoleTracking;
/* eslint-enable no-console */
function buildErrorFromParams(params, handlingStack) {
    var firstErrorParam = utils_1.find(params, function (param) { return param instanceof Error; });
    return {
        message: tslib_1.__spreadArrays(['console error:'], params).map(function (param) { return formatConsoleParameters(param); }).join(' '),
        stack: firstErrorParam ? error_1.toStackTraceString(tracekit_1.computeStackTrace(firstErrorParam)) : undefined,
        handlingStack: handlingStack,
    };
}
function formatConsoleParameters(param) {
    if (typeof param === 'string') {
        return param;
    }
    if (param instanceof Error) {
        return error_1.formatErrorMessage(tracekit_1.computeStackTrace(param));
    }
    return utils_1.jsonStringify(param, undefined, 2);
}
var traceKitReportHandler;
function startRuntimeErrorTracking(errorObservable) {
    traceKitReportHandler = function (stackTrace, _, errorObject) {
        var _a = error_1.formatUnknownError(stackTrace, errorObject, 'Uncaught'), stack = _a.stack, message = _a.message, type = _a.type;
        errorObservable.notify({
            message: message,
            stack: stack,
            type: type,
            source: error_1.ErrorSource.SOURCE,
            startClocks: timeUtils_1.clocksNow(),
            originalError: errorObject,
            handling: error_1.ErrorHandling.UNHANDLED,
        });
    };
    tracekit_1.subscribe(traceKitReportHandler);
}
exports.startRuntimeErrorTracking = startRuntimeErrorTracking;
function stopRuntimeErrorTracking() {
    tracekit_1.unsubscribe(traceKitReportHandler);
}
exports.stopRuntimeErrorTracking = stopRuntimeErrorTracking;
function trackNetworkError(configuration, errorObservable) {
    xhrProxy_1.startXhrProxy().onRequestComplete(function (context) { return handleCompleteRequest(utils_1.RequestType.XHR, context); });
    fetchProxy_1.startFetchProxy().onRequestComplete(function (context) { return handleCompleteRequest(utils_1.RequestType.FETCH, context); });
    function handleCompleteRequest(type, request) {
        if (!configuration.isIntakeUrl(request.url) &&
            (!configuration.isEnabled('remove-network-errors') || !request.isAborted) &&
            (isRejected(request) || isServerError(request))) {
            errorObservable.notify({
                message: format(type) + " error " + request.method + " " + request.url,
                resource: {
                    method: request.method,
                    statusCode: request.status,
                    url: request.url,
                },
                source: error_1.ErrorSource.NETWORK,
                stack: truncateResponseText(request.responseText, configuration) || 'Failed to load',
                startClocks: request.startClocks,
            });
        }
    }
    return {
        stop: function () {
            xhrProxy_1.resetXhrProxy();
            fetchProxy_1.resetFetchProxy();
        },
    };
}
exports.trackNetworkError = trackNetworkError;
function isRejected(request) {
    return request.status === 0 && request.responseType !== 'opaque';
}
function isServerError(request) {
    return request.status >= 500;
}
function truncateResponseText(responseText, configuration) {
    if (responseText && responseText.length > configuration.requestErrorResponseLengthLimit) {
        return responseText.substring(0, configuration.requestErrorResponseLengthLimit) + "...";
    }
    return responseText;
}
function format(type) {
    if (utils_1.RequestType.XHR === type) {
        return 'XHR';
    }
    return 'Fetch';
}
//# sourceMappingURL=automaticErrorCollection.js.map
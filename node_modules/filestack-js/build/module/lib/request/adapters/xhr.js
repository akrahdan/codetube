import { __awaiter, __generator } from "tslib";
/*
 * Copyright (c) 2018 by Filestack
 * Some rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import Debug from 'debug';
import * as utils from '../utils';
import { FsHttpMethod } from '../types';
import { FsRequestError, FsRequestErrorCode } from '../error';
import { prepareData, parseResponse, parse as parseHeaders, combineURL } from './../helpers';
var debug = Debug('fs:request:xhr');
var CANCEL_CLEAR = "FsCleanMemory";
var XhrAdapter = /** @class */ (function () {
    function XhrAdapter() {
    }
    XhrAdapter.prototype.request = function (config) {
        var _this = this;
        // if this option is unspecified set it by default
        if (typeof config.filestackHeaders === 'undefined') {
            config.filestackHeaders = true;
        }
        config = prepareData(config);
        config.headers = config.headers || {};
        var data = config.data, headers = config.headers;
        // if data is type of form let browser to set proper content type
        if (utils.isFormData(data)) {
            delete headers['Content-Type'];
        }
        var request = new XMLHttpRequest();
        if (config.blobResponse) {
            request.responseType = 'blob';
        }
        // HTTP basic authentication
        if (config.auth) {
            if (!config.auth.username || config.auth.username.length === 0 || !config.auth.password || config.auth.password.length === 0) {
                return Promise.reject(new FsRequestError("Basic auth: username and password are required " + config.auth, config));
            }
            headers.Authorization = 'Basic ' + btoa(unescape(encodeURIComponent(config.auth.username + ":" + config.auth.password)));
            debug('Set request authorization to %s', config.auth.username + config.auth.password);
        }
        var url = config.url.trim();
        if (!/^http(s)?:\/\//.test(url)) {
            url = "https://" + url;
        }
        url = combineURL(url, config.params);
        debug('Starting request to %s with options %O', url, config);
        request.open(config.method.toUpperCase(), url, true);
        request.timeout = config.timeout;
        return new Promise(function (resolve, reject) {
            var cancelListener;
            if (config.cancelToken) {
                cancelListener = config.cancelToken.once('cancel', function (reason) {
                    /* istanbul ignore next: if request is done cancel token should not throw any error */
                    if (request) {
                        request.abort();
                        request = null;
                    }
                    debug('Request canceled by user %s, config: %O', reason, config);
                    return reject(new FsRequestError("Request aborted. Reason: " + reason, config, null, FsRequestErrorCode.ABORTED));
                });
            }
            request.onreadystatechange = function () { return __awaiter(_this, void 0, void 0, function () {
                var responseHeaders, responseData, response;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!request || request.readyState !== 4) {
                                return [2 /*return*/];
                            }
                            if (request.status === 0 && !request.responseURL) {
                                return [2 /*return*/];
                            }
                            responseHeaders = parseHeaders(request.getAllResponseHeaders());
                            responseData = request.response;
                            response = {
                                data: responseData,
                                status: request.status,
                                statusText: request.statusText,
                                headers: responseHeaders,
                                config: config,
                            };
                            request = null;
                            return [4 /*yield*/, parseResponse(response)];
                        case 1:
                            response = _a.sent();
                            if (500 <= response.status && response.status <= 599) {
                                // server error throw
                                debug('Server error(5xx) - %O', response);
                                return [2 /*return*/, reject(new FsRequestError("Server error " + url, config, response, FsRequestErrorCode.SERVER))];
                            }
                            else if (400 <= response.status && response.status <= 499) {
                                debug('Request error(4xx) - %O', response);
                                return [2 /*return*/, reject(new FsRequestError("Request error " + url, config, response, FsRequestErrorCode.REQUEST))];
                            }
                            // clear cancel token to avoid memory leak
                            if (config.cancelToken) {
                                config.cancelToken.removeListener(cancelListener);
                            }
                            return [2 /*return*/, resolve(response)];
                    }
                });
            }); };
            // Handle browser request cancellation (as opposed to a manual cancellation)
            request.onabort = function handleAbort() {
                /* istanbul ignore next: just to be sure that abort was not called twice */
                if (!request) {
                    return;
                }
                request = null;
                reject(new FsRequestError('Request aborted', config, null, FsRequestErrorCode.ABORTED));
            };
            // Handle low level network errors
            request.onerror = function handleError(err) {
                request = null;
                debug('Request error! %O', err);
                reject(new FsRequestError('Network Error', config, null, FsRequestErrorCode.NETWORK));
            };
            // Handle timeout
            request.ontimeout = function handleTimeout() {
                request = null;
                debug('Request timed out. %O', config);
                reject(new FsRequestError('Request timeout', config, null, FsRequestErrorCode.TIMEOUT));
            };
            // Add headers to the request
            if ('setRequestHeader' in request && headers && Object.keys(headers).length) {
                for (var key in headers) {
                    if (headers[key] === undefined) {
                        continue;
                    }
                    debug('Set request header %s to %s', key, headers[key]);
                    request.setRequestHeader(key, headers[key]);
                }
            }
            if (typeof config.onProgress === 'function' && [FsHttpMethod.POST, FsHttpMethod.PUT].indexOf(config.method) > -1) {
                /* istanbul ignore else: else path is just fallback to normal progress event */
                if (request.upload) {
                    debug('Bind to upload progress event');
                    request.upload.addEventListener('progress', config.onProgress);
                }
                else {
                    debug('Bind to progress event');
                    request.addEventListener('progress', config.onProgress);
                }
            }
            if (data === undefined) {
                data = null;
            }
            request.send(data);
        });
    };
    return XhrAdapter;
}());
export { XhrAdapter };

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvcmVxdWVzdC9hZGFwdGVycy94aHIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMxQixPQUFPLEtBQUssS0FBSyxNQUFNLFVBQVUsQ0FBQztBQUVsQyxPQUFPLEVBQWdDLFlBQVksRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUN0RSxPQUFPLEVBQUUsY0FBYyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sVUFBVSxDQUFDO0FBQzlELE9BQU8sRUFBRSxXQUFXLEVBQUUsYUFBYSxFQUFFLEtBQUssSUFBSSxZQUFZLEVBQUUsVUFBVSxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRTdGLElBQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQ3RDLElBQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQztBQUVyQztJQUFBO0lBZ0tBLENBQUM7SUE5SkMsNEJBQU8sR0FBUCxVQUFRLE1BQXdCO1FBQWhDLGlCQTZKQztRQTVKQyxrREFBa0Q7UUFDbEQsSUFBSSxPQUFPLE1BQU0sQ0FBQyxnQkFBZ0IsS0FBSyxXQUFXLEVBQUU7WUFDbEQsTUFBTSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQztTQUNoQztRQUVELE1BQU0sR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDN0IsTUFBTSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQztRQUVoQyxJQUFBLGtCQUFJLEVBQUUsd0JBQU8sQ0FBWTtRQUUvQixpRUFBaUU7UUFDakUsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzFCLE9BQU8sT0FBTyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQ2hDO1FBRUQsSUFBSSxPQUFPLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztRQUVuQyxJQUFJLE1BQU0sQ0FBQyxZQUFZLEVB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Q3hELE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7aUJBQzdDO2FBQ0Y7WUFFRCxJQUFJLE9BQU8sTUFBTSxDQUFDLFVBQVUsS0FBSyxVQUFVLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFO2dCQUNoSCwrRUFBK0U7Z0JBQy9FLElBQUksT0FBTyxDQUFDLE1BQU0sRUFBRTtvQkFDbEIsS0FBSyxDQUFDLCtCQUErQixDQUFDLENBQUM7b0JBQ3ZDLE9BQU8sQ0FBQyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDaEU7cUJBQU07b0JBQ0wsS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7b0JBQ2hDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2lCQUN6RDthQUNGO1lBRUQsSUFBSSxJQUFJLEtBQUssU0FBUyxFQUFFO2dCQUN0QixJQUFJLEdBQUcsSUFBSSxDQUFDO2FBQ2I7WUFFRCxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUNILGlCQUFDO0FBQUQsQ0FoS0EsQUFnS0MsSUFBQSIsImZpbGUiOiJsaWIvcmVxdWVzdC9hZGFwdGVycy94aHIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE4IGJ5IEZpbGVzdGFja1xuICogU29tZSByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMnO1xuaW1wb3J0IHsgQWRhcHRlckludGVyZmFjZSB9IGZyb20gJy4vaW50ZXJmYWNlJztcbmltcG9ydCB7IEZzUmVxdWVzdE9wdGlvbnMsIEZzUmVzcG9uc2UsIEZzSHR0cE1ldGhvZCB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IEZzUmVxdWVzdEVycm9yLCBGc1JlcXVlc3RFcnJvckNvZGUgfSBmcm9tICcuLi9lcnJvcic7XG5pbXBvcnQgeyBwcmVwYXJlRGF0YSwgcGFyc2VSZXNwb25zZSwgcGFyc2UgYXMgcGFyc2VIZWFkZXJzLCBjb21iaW5lVVJMIH0gZnJvbSAnLi8uLi9oZWxwZXJzJztcblxuY29uc3QgZGVidWcgPSBEZWJ1ZygnZnM6cmVxdWVzdDp4aHInKTtcbmNvbnN0IENBTkNFTF9DTEVBUiA9IGBGc0NsZWFuTWVtb3J5YDtcblxuZXhwb3J0IGNsYXNzIFhockFkYXB0ZXIgaW1wbGVtZW50cyBBZGFwdGVySW50ZXJmYWNlIHtcblxuICByZXF1ZXN0KGNvbmZpZzogRnNSZXF1ZXN0T3B0aW9ucykge1xuICAgIC8vIGlmIHRoaXMgb3B0aW9uIGlzIHVuc3BlY2lmaWVkIHNldCBpdCBieSBkZWZhdWx0XG4gICAgaWYgKHR5cGVvZiBjb25maWcuZmlsZXN0YWNrSGVhZGVycyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZy5maWxlc3RhY2tIZWFkZXJzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25maWcgPSBwcmVwYXJlRGF0YShjb25maWcpO1xuICAgIGNvbmZpZy5oZWFkZXJzID0gY29uZmlnLmhlYWRlcnMgfHwge307XG5cbiAgICBsZXQgeyBkYXRhLCBoZWFkZXJzIH0gPSBjb25maWc7XG5cbiAgICAvLyBpZiBkYXRhIGlzIHR5cGUgb2YgZm9ybSBsZXQgYnJvd3NlciB0byBzZXQgcHJvcGVyIGNvbnRlbnQgdHlwZVxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpKSB7XG4gICAgICBkZWxldGUgaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgfVxuXG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGlmIChjb25maWcuYmxvYlJlc3BvbnNlKSB7XG4gICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICBpZiAoIWNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8IGNvbmZpZy5hdXRoLnVzZXJuYW1lLmxlbmd0aCA9PT0gMCB8fCAhY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgY29uZmlnLmF1dGgucGFzc3dvcmQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYEJhc2ljIGF1dGg6IHVzZXJuYW1lIGFuZCBwYXNzd29yZCBhcmUgcmVxdWlyZWQgJHtjb25maWcuYXV0aH1gLCBjb25maWcpKTtcbiAgICAgIH1cblxuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChgJHtjb25maWcuYXV0aC51c2VybmFtZX06JHtjb25maWcuYXV0aC5wYXNzd29yZH1gKSkpO1xuICAgICAgZGVidWcoJ1NldCByZXF1ZXN0IGF1dGhvcml6YXRpb24gdG8gJXMnLCBjb25maWcuYXV0aC51c2VybmFtZSArIGNvbmZpZy5hdXRoLnBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICBsZXQgdXJsID0gY29uZmlnLnVybC50cmltKCk7XG5cbiAgICBpZiAoIS9eaHR0cChzKT86XFwvXFwvLy50ZXN0KHVybCkpIHtcbiAgICAgIHVybCA9IGBodHRwczovLyR7dXJsfWA7XG4gICAgfVxuXG4gICAgdXJsID0gY29tYmluZVVSTCh1cmwsIGNvbmZpZy5wYXJhbXMpO1xuXG4gICAgZGVidWcoJ1N0YXJ0aW5nIHJlcXVlc3QgdG8gJXMgd2l0aCBvcHRpb25zICVPJywgdXJsLCBjb25maWcpO1xuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgdXJsLCB0cnVlKTtcblxuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPEZzUmVzcG9uc2U+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjYW5jZWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgICBjYW5jZWxMaXN0ZW5lciA9IGNvbmZpZy5jYW5jZWxUb2tlbi5vbmNlKCdjYW5jZWwnLCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGlmIHJlcXVlc3QgaXMgZG9uZSBjYW5jZWwgdG9rZW4gc2hvdWxkIG5vdCB0aHJvdyBhbnkgZXJyb3IgKi9cbiAgICAgICAgICBpZiAocmVxdWVzdCkge1xuICAgICAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWcoJ1JlcXVlc3QgY2FuY2VsZWQgYnkgdXNlciAlcywgY29uZmlnOiAlTycsIHJlYXNvbiwgY29uZmlnKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgUmVxdWVzdCBhYm9ydGVkLiBSZWFzb246ICR7cmVhc29ufWAsIGNvbmZpZywgbnVsbCwgRnNSZXF1ZXN0RXJyb3JDb2RlLkFCT1JURUQpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICFyZXF1ZXN0LnJlc3BvbnNlVVJMKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpO1xuICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSByZXF1ZXN0LnJlc3BvbnNlO1xuXG4gICAgICAgIGxldCByZXNwb25zZTogRnNSZXNwb25zZSA9IHtcbiAgICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICB9O1xuXG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgICAgIGlmICg1MDAgPD0gcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyA8PSA1OTkpIHtcbiAgICAgICAgICAvLyBzZXJ2ZXIgZXJyb3IgdGhyb3dcbiAgICAgICAgICBkZWJ1ZygnU2VydmVyIGVycm9yKDV4eCkgLSAlTycsIHJlc3BvbnNlKTtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcihgU2VydmVyIGVycm9yICR7dXJsfWAsIGNvbmZpZywgcmVzcG9uc2UsIEZzUmVxdWVzdEVycm9yQ29kZS5TRVJWRVIpKTtcbiAgICAgICAgfSBlbHNlIGlmICg0MDAgPD0gcmVzcG9uc2Uuc3RhdHVzICYmIHJlc3BvbnNlLnN0YXR1cyA8PSA0OTkpIHtcbiAgICAgICAgICBkZWJ1ZygnUmVxdWVzdCBlcnJvcig0eHgpIC0gJU8nLCByZXNwb25zZSk7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoYFJlcXVlc3QgZXJyb3IgJHt1cmx9YCwgY29uZmlnLCByZXNwb25zZSwgRnNSZXF1ZXN0RXJyb3JDb2RlLlJFUVVFU1QpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFyIGNhbmNlbCB0b2tlbiB0byBhdm9pZCBtZW1vcnkgbGVha1xuICAgICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnJlbW92ZUxpc3RlbmVyKGNhbmNlbExpc3RlbmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDoganVzdCB0byBiZSBzdXJlIHRoYXQgYWJvcnQgd2FzIG5vdCBjYWxsZWQgdHdpY2UgKi9cbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHJlamVjdChuZXcgRnNSZXF1ZXN0RXJyb3IoJ1JlcXVlc3QgYWJvcnRlZCcsIGNvbmZpZywgbnVsbCwgRnNSZXF1ZXN0RXJyb3JDb2RlLkFCT1JURUQpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycikge1xuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgZGVidWcoJ1JlcXVlc3QgZXJyb3IhICVPJywgZXJyKTtcbiAgICAgICAgcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgRnNSZXF1ZXN0RXJyb3JDb2RlLk5FVFdPUkspKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgICBkZWJ1ZygnUmVxdWVzdCB0aW1lZCBvdXQuICVPJywgY29uZmlnKTtcbiAgICAgICAgcmVqZWN0KG5ldyBGc1JlcXVlc3RFcnJvcignUmVxdWVzdCB0aW1lb3V0JywgY29uZmlnLCBudWxsLCBGc1JlcXVlc3RFcnJvckNvZGUuVElNRU9VVCkpO1xuICAgICAgfTtcblxuICAgICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCAmJiBoZWFkZXJzICYmIE9iamVjdC5rZXlzKGhlYWRlcnMpLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgIGlmIChoZWFkZXJzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGVidWcoJ1NldCByZXF1ZXN0IGhlYWRlciAlcyB0byAlcycsIGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCBoZWFkZXJzW2tleV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLm9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgW0ZzSHR0cE1ldGhvZC5QT1NULCBGc0h0dHBNZXRob2QuUFVUXS5pbmRleE9mKGNvbmZpZy5tZXRob2QpID4gLTEpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IGVsc2UgcGF0aCBpcyBqdXN0IGZhbGxiYWNrIHRvIG5vcm1hbCBwcm9ncmVzcyBldmVudCAqL1xuICAgICAgICBpZiAocmVxdWVzdC51cGxvYWQpIHtcbiAgICAgICAgICBkZWJ1ZygnQmluZCB0byB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnQnKTtcbiAgICAgICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblByb2dyZXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnQmluZCB0byBwcm9ncmVzcyBldmVudCcpO1xuICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5zZW5kKGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG4iXX0=

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import { get, identity, isFunction, isObject, isString, merge } from 'lodash';
import { getStaticCss } from './utils/getStaticProperties';
import { orderPropNames } from './utils/propNames';
import { arrayParser, isMediaArray, isMediaMap, objectParser, orderBreakpoints, parseBreakpoints } from './utils/responsive';
export var variance = {
  // Parser to handle any set of configured props
  createParser: function createParser(config) {
    var propNames = orderPropNames(config);
    var breakpoints;

    var parser = function parser(props) {
      var styles = {};
      var theme = props.theme; // Attempt to cache the breakpoints if we have not yet or if theme has become available.

      if (breakpoints === undefined || breakpoints === null && theme !== null && theme !== void 0 && theme.breakpoints) {
        // Save the breakpoints if we can
        breakpoints = parseBreakpoints(theme === null || theme === void 0 ? void 0 : theme.breakpoints);
      } // Loops over all prop names on the configured config to check for configured styles


      propNames.forEach(function (prop) {
        var property = config[prop];
        var value = get(props, prop);

        switch (_typeof(value)) {
          case 'string':
          case 'number':
            return Object.assign(styles, property.styleFn(value, prop, props));
          // handle any props configured with the responsive notation

          case 'object':
            if (!breakpoints) {
              return;
            } // If it is an array the order of values is smallest to largest: [_, xs, ...]


            if (isMediaArray(value)) {
              return merge(styles, arrayParser(value, props, property, breakpoints.array));
            } // Check to see if value is an object matching the responsive syntax and generate the styles.


            if (isMediaMap(value)) {
              return merge(styles, objectParser(value, props, property, breakpoints.map));
            }

        }
      });
      return breakpoints ? orderBreakpoints(styles, breakpoints.array) : styles;
    }; // return the parser function with the resulting meta information for further composition


    return Object.assign(parser, {
      propNames: propNames,
      config: config
    });
  },
  // Given a single property configuration enrich the config with a transform function
  // that traverses the properties the function is responsible for.
  createTransform: function createTransform(prop, config) {
    var _config$transform = config.transform,
        transform = _config$transform === void 0 ? identity : _config$transform,
        property = config.property,
        _config$properties = config.properties,
        properties = _config$properties === void 0 ? [property] : _config$properties,
        scale = config.scale;
    return _objectSpread(_objectSpread({}, config), {}, {
      prop: prop,
      styleFn: function styleFn(value, prop, props) {
        var styles = {};
        var useTransform = false;
        var usedValue;
        var scaleVal;

        if (isFunction(value)) {
          usedValue = value(props.theme);
        } else {
          var _scaleVal;

          if (isString(scale)) scaleVal = get(props, "theme.".concat(scale, ".").concat(value));
          if (isObject(scale)) scaleVal = get(scale, "".concat(value));
          useTransform = scaleVal !== undefined || scale === undefined;
          usedValue = (_scaleVal = scaleVal) !== null && _scaleVal !== void 0 ? _scaleVal : value;
        } // for each property look up the scale value from theme if passed and apply any
        // final transforms to the value


        properties.forEach(function (property) {
          var finalValue = useTransform ? transform(usedValue, property, props) : usedValue;

          if (isObject(finalValue)) {
            Object.assign(styles, finalValue);
          } else {
            Object.assign(styles, _defineProperty({}, property, finalValue));
          }
        }); // return the resulting styles object

        return styles;
      }
    });
  },
  compose: function compose() {
    for (var _len = arguments.length, parsers = new Array(_len), _key = 0; _key < _len; _key++) {
      parsers[_key] = arguments[_key];
    }

    return this.createParser(parsers.reduce(function (carry, parser) {
      return _objectSpread(_objectSpread({}, carry), parser.config);
    }, {}));
  },
  createCss: function createCss(config) {
    var parser = this.create(config);
    var filteredProps = parser.propNames;
    return function (cssProps) {
      var cache;
      var allKeys = Object.keys(cssProps);
      /** Any key of the CSSProps that is not a System Prop or a Static CSS Property is treated as a nested selector */

      var selectors = allKeys.filter(function (key) {
        return !filteredProps.includes(key) && isObject(cssProps[key]);
      });
      /** Static CSS Properties get extracted if they match neither syntax */

      var staticCss = getStaticCss(cssProps, ['theme'].concat(_toConsumableArray(selectors), _toConsumableArray(filteredProps)));
      return function (_ref) {
        var theme = _ref.theme;
        if (cache) return cache;
        var css = parser(_objectSpread(_objectSpread({}, cssProps), {}, {
          theme: theme
        }));
        selectors.forEach(function (selector) {
          var _cssProps$selector;

          var selectorConfig = (_cssProps$selector = cssProps[selector]) !== null && _cssProps$selector !== void 0 ? _cssProps$selector : {};
          css[selector] = _objectSpread(_objectSpread({}, getStaticCss(selectorConfig, filteredProps)), parser(_objectSpread(_objectSpread({}, selectorConfig), {}, {
            theme: theme
          })));
        });
        /** Merge the static and generated css and save it to the cache */

        cache = _objectSpread(_objectSpread({}, staticCss), css);
        return cache;
      };
    };
  },
  createVariant: function createVariant(config) {
    var css = this.createCss(config);
    return function (_ref2) {
      var _ref2$prop = _ref2.prop,
          prop = _ref2$prop === void 0 ? 'variant' : _ref2$prop,
          defaultVariant = _ref2.defaultVariant,
          _ref2$base = _ref2.base,
          base = _ref2$base === void 0 ? {} : _ref2$base,
          variants = _ref2.variants;
      var baseFn = css(base);
      var variantFns = {};
      Object.keys(variants).forEach(function (key) {
        var variantKey = key;
        var cssProps = variants[variantKey];
        variantFns[variantKey] = css(cssProps);
      });
      return function (props) {
        var _variantFns;

        var _props$prop = props[prop],
            selected = _props$prop === void 0 ? defaultVariant : _props$prop;
        var styles = {};
        if (!selected) return styles;
        return merge(styles, baseFn(props), variantFns === null || variantFns === void 0 ? void 0 : (_variantFns = variantFns[selected]) === null || _variantFns === void 0 ? void 0 : _variantFns.call(variantFns, props));
      };
    };
  },
  createStates: function createStates(config) {
    var css = this.createCss(config);
    return function (states) {
      var orderedStates = Object.keys(states);
      var stateFns = {};
      orderedStates.forEach(function (key) {
        var stateKey = key;
        var cssProps = states[stateKey];
        stateFns[stateKey] = css(cssProps);
      });
      return function (props) {
        var styles = {};
        orderedStates.forEach(function (state) {
          merge(styles, props[state] && stateFns[state](props));
        });
        return styles;
      };
    };
  },
  create: function create(config) {
    var transforms = {}; // Create a transform function for each of the props

    for (var prop in config) {
      if (typeof prop === 'string') {
        transforms[prop] = this.createTransform(prop, config[prop]);
      }
    } // Create a parser that handles all the props within the config


    return this.createParser(transforms);
  }
};
import _styled from "@emotion/styled/base";

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

import { AlertIcon, CheckCircledIcon } from '@codecademy/gamut-icons';
import { system } from '@codecademy/gamut-styles';
import React, { forwardRef, useState } from 'react';
import { Box, FlexBox } from '../Box';
import { conditionalStyles, conditionalStyleState, formBaseFieldStyles, formFieldFocusStyles, formFieldPaddingStyles, formFieldStyles } from './styles/shared-system-props';

/**  We greatly prefer NOT to do this but ReactRecurly has some specific needs around focus-styles + padding that force us to export them seperately. If we ever stop using React-Recurly, this code will be ðŸ”ª.
 *tldr: Do not do this unless you have already talked to Web-Plat and have failed to find any alternate (and better) solutions. */
export var reactRecurlyFormFieldFocusStyles = system.css(formFieldFocusStyles);
export var reactRecurlyFormFieldPaddingStyles = system.css(formFieldPaddingStyles);
export var iFrameWrapper = _styled("div", {
  target: "e1ys3kqj1",
  label: "iFrameWrapper"
})(formBaseFieldStyles, " ", conditionalStyles, " text-indent:0;" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Gb3JtL0lucHV0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFvRThEIiwiZmlsZSI6Ii4uLy4uL3NyYy9Gb3JtL0lucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFsZXJ0SWNvbiwgQ2hlY2tDaXJjbGVkSWNvbiB9IGZyb20gJ0Bjb2RlY2FkZW15L2dhbXV0LWljb25zJztcbmltcG9ydCB7IHN5c3RlbSB9IGZyb20gJ0Bjb2RlY2FkZW15L2dhbXV0LXN0eWxlcyc7XG5pbXBvcnQgc3R5bGVkLCB7IFN0eWxlZENvbXBvbmVudCB9IGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgUmVhY3QsIHtcbiAgQ2hhbmdlRXZlbnQsXG4gIGZvcndhcmRSZWYsXG4gIElucHV0SFRNTEF0dHJpYnV0ZXMsXG4gIHVzZVN0YXRlLFxufSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEJveCwgRmxleEJveCB9IGZyb20gJy4uL0JveCc7XG5pbXBvcnQge1xuICBjb25kaXRpb25hbFN0eWxlUHJvcHMsXG4gIGNvbmRpdGlvbmFsU3R5bGVzLFxuICBjb25kaXRpb25hbFN0eWxlU3RhdGUsXG4gIGZvcm1CYXNlRmllbGRTdHlsZXMsXG4gIGZvcm1GaWVsZEZvY3VzU3R5bGVzLFxuICBmb3JtRmllbGRQYWRkaW5nU3R5bGVzLFxuICBmb3JtRmllbGRTdHlsZXMsXG59IGZyb20gJy4vc3R5bGVzL3NoYXJlZC1zeXN0ZW0tcHJvcHMnO1xuXG5leHBvcnQgdHlwZSBJbnB1dFByb3BzID0gSW5wdXRIVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50PiAmIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgZXJyb3I/OiBib29sZWFuO1xuICAvKipcbiAgICogW1RoZSBmb3IvaWQgc3RyaW5nIG9mIGEgbGFiZWwgb3IgbGFiZWxhYmxlIGZvcm0tcmVsYXRlZCBlbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTExhYmVsRWxlbWVudC9odG1sRm9yKS4gVGhlIG91dGVyIEZvcm1Hcm91cCBvciBGb3JtTGFiZWwgc2hvdWxkIGhhdmUgYW4gaWRlbnRpY2FsIHN0cmluZyBhcyB0aGUgaW5uZXIgRm9ybUVsZW1lbnQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG4gICAqL1xuICBodG1sRm9yPzogc3RyaW5nO1xuICBsYWJlbD86IHN0cmluZztcbiAgbmFtZT86IHN0cmluZztcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gIHJlcXVpcmVkPzogYm9vbGVhbjtcbiAgdHlwZT86IHN0cmluZztcbiAgdmFsaWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogQWxsb3dzIElucHV0cyB0byBtYW5hZ2UgdGhlaXIgb3duIGFjdGl2YXRlZCBzdHlsZSBzdGF0ZSB0byBhY2NvdW50IGZvciBzb21lIGVkZ2UtY2FzZXMuXG4gICAqL1xuICBhY3RpdmF0ZWQ/OiBib29sZWFuO1xufTtcbmV4cG9ydCBpbnRlcmZhY2UgU3R5bGVkSW5wdXRQcm9wcyBleHRlbmRzIElucHV0UHJvcHMge1xuICBpY29uPzogYm9vbGVhbjtcbn1cblxuLypcbiAqIEByZW1hcmtzIFdlIHdvdWxkIGxvdmUgdG8gcHJvcGVybHkgdHlwZSB0aGlzIHdpdGggZ2VuZXJpY3MsIGJ1dCwgYWxhcywgd2UgY2Fubm90IHlldC5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0NvZGVjYWRlbXkvY2xpZW50LW1vZHVsZXMvcHVsbC8yNzAjZGlzY3Vzc2lvbl9yMjcwOTE3MTQ3XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjEwNDhcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dFdyYXBwZXJQcm9wcyBleHRlbmRzIElucHV0UHJvcHMge1xuICBhcz86IFN0eWxlZENvbXBvbmVudDxTdHlsZWRJbnB1dFByb3BzLCBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxhbnk+PjtcbiAgLyoqXG4gICAqIEEgY3VzdG9tIGljb24gc3ZnIGZyb20gZ2FtdXQtaWNvbnMuXG4gICAqL1xuICBpY29uPzogdHlwZW9mIEFsZXJ0SWNvbjtcbn1cblxuLyoqICBXZSBncmVhdGx5IHByZWZlciBOT1QgdG8gZG8gdGhpcyBidXQgUmVhY3RSZWN1cmx5IGhhcyBzb21lIHNwZWNpZmljIG5lZWRzIGFyb3VuZCBmb2N1cy1zdHlsZXMgKyBwYWRkaW5nIHRoYXQgZm9yY2UgdXMgdG8gZXhwb3J0IHRoZW0gc2VwZXJhdGVseS4gSWYgd2UgZXZlciBzdG9wIHVzaW5nIFJlYWN0LVJlY3VybHksIHRoaXMgY29kZSB3aWxsIGJlIPCflKouXG4gKnRsZHI6IERvIG5vdCBkbyB0aGlzIHVubGVzcyB5b3UgaGF2ZSBhbHJlYWR5IHRhbGtlZCB0byBXZWItUGxhdCBhbmQgaGF2ZSBmYWlsZWQgdG8gZmluZCBhbnkgYWx0ZXJuYXRlIChhbmQgYmV0dGVyKSBzb2x1dGlvbnMuICovXG5cbmV4cG9ydCBjb25zdCByZWFjdFJlY3VybHlGb3JtRmllbGRGb2N1c1N0eWxlcyA9IHN5c3RlbS5jc3MoXG4gIGZvcm1GaWVsZEZvY3VzU3R5bGVzXG4pO1xuXG5leHBvcnQgY29uc3QgcmVhY3RSZWN1cmx5Rm9ybUZpZWxkUGFkZGluZ1N0eWxlcyA9IHN5c3RlbS5jc3MoXG4gIGZvcm1GaWVsZFBhZGRpbmdTdHlsZXNcbik7XG5cbmV4cG9ydCBjb25zdCBpRnJhbWVXcmFwcGVyID0gc3R5bGVkLmRpdjxjb25kaXRpb25hbFN0eWxlUHJvcHM+YFxuICAke2Zvcm1CYXNlRmllbGRTdHlsZXN9XG4gICR7Y29uZGl0aW9uYWxTdHlsZXN9XG4gIHRleHQtaW5kZW50OiAwO1xuYDtcblxuY29uc3QgSW5wdXRFbGVtZW50ID0gc3R5bGVkLmlucHV0PFN0eWxlZElucHV0UHJvcHM+YFxuICAke2Zvcm1GaWVsZFN0eWxlc31cbiAgJHtjb25kaXRpb25hbFN0eWxlc31cbiAgdGV4dC1pbmRlbnQ6IDA7XG4gIHBhZGRpbmctcmlnaHQ6ICR7KHByb3BzKSA9PiAocHJvcHMuaWNvbiA/IGAyLjNyZW1gIDogYGluaXRpYWxgKX07XG5gO1xuXG5jb25zdCBpbnB1dFN0YXRlcyA9IHtcbiAgZXJyb3I6IHtcbiAgICBjb2xvcjogJ3JlZCcsXG4gICAgaWNvbjogQWxlcnRJY29uLFxuICB9LFxuICB2YWxpZDoge1xuICAgIGNvbG9yOiAnZ3JlZW4nLFxuICAgIGljb246IENoZWNrQ2lyY2xlZEljb24sXG4gIH0sXG4gIGNsZWFuOiB7XG4gICAgY29sb3I6ICdncmF5LTYwMCcsXG4gICAgaWNvbjogdW5kZWZpbmVkLFxuICB9LFxufSBhcyBjb25zdDtcblxuY29uc3QgZ2V0SW5wdXRTdGF0ZSA9IChlcnJvcjogYm9vbGVhbiwgdmFsaWQ6IGJvb2xlYW4pID0+IHtcbiAgaWYgKGVycm9yKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKHZhbGlkKSByZXR1cm4gJ3ZhbGlkJztcbiAgcmV0dXJuICdjbGVhbic7XG59O1xuXG5leHBvcnQgY29uc3QgSW5wdXQgPSBmb3J3YXJkUmVmPEhUTUxJbnB1dEVsZW1lbnQsIElucHV0V3JhcHBlclByb3BzPihcbiAgKFxuICAgIHsgZXJyb3IsIGNsYXNzTmFtZSwgaWQsIHZhbGlkLCBhY3RpdmF0ZWQsIGFzOiBBcywgaWNvbjogSWNvbiwgLi4ucmVzdCB9LFxuICAgIHJlZlxuICApID0+IHtcbiAgICBjb25zdCBbYWN0aXZhdGVkU3R5bGUsIHNldEFjdGl2YXRlZFN0eWxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IHsgY29sb3IsIGljb24gfSA9IGlucHV0U3RhdGVzW1xuICAgICAgZ2V0SW5wdXRTdGF0ZShCb29sZWFuKGVycm9yKSwgQm9vbGVhbih2YWxpZCkpXG4gICAgXTtcblxuICAgIC8qXG4gICAgICogQHJlbWFya3MgV2Ugd291bGQgbG92ZSB0byBwcm9wZXJseSB0eXBlIHRoaXMgd2l0aCBnZW5lcmljcywgYnV0LCBhbGFzLCB3ZSBjYW5ub3QgeWV0LiBTZWUgY29tbWVudHMgb24gbGluZXMgNDUtNDcgZm9yIG1vcmUgZGV0YWlsLlxuICAgICAqL1xuXG4gICAgY29uc3QgY2hhbmdlSGFuZGxlciA9IChldmVudDogQ2hhbmdlRXZlbnQ8YW55PikgPT4ge1xuICAgICAgcmVzdD8ub25DaGFuZ2U/LihldmVudCk7XG4gICAgICBzZXRBY3RpdmF0ZWRTdHlsZSh0cnVlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgQXNDb21wb25lbnQgPSBBcyB8fCBJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgU2hvd25JY29uID0gSWNvbiB8fCBpY29uO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgZGlzcGxheT17cmVzdC50eXBlID09PSAnaGlkZGVuJyA/ICdub25lJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIHRleHRDb2xvcj17Y29sb3J9XG4gICAgICA+XG4gICAgICAgIDxBc0NvbXBvbmVudFxuICAgICAgICAgIHsuLi5yZXN0fVxuICAgICAgICAgIGlkPXtpZCB8fCByZXN0Lmh0bWxGb3J9XG4gICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgdmFyaWFudD17Y29uZGl0aW9uYWxTdHlsZVN0YXRlKEJvb2xlYW4oZXJyb3IpLCBhY3RpdmF0ZWRTdHlsZSl9XG4gICAgICAgICAgaWNvbj17ZXJyb3IgfHwgdmFsaWQgfHwgISFJY29ufVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgIG9uQ2hhbmdlPXtjaGFuZ2VIYW5kbGVyfVxuICAgICAgICAvPlxuICAgICAgICB7ISFTaG93bkljb24gJiYgKFxuICAgICAgICAgIDxGbGV4Qm94XG4gICAgICAgICAgICBwcj17SWNvbiA/IDEyIDogMTZ9XG4gICAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICAgICAgcmlnaHQ9XCIwXCJcbiAgICAgICAgICAgIHRvcD1cIjBcIlxuICAgICAgICAgICAgYm90dG9tPVwiMFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFNob3duSWNvbiBzaXplPXtJY29uID8gMjQgOiAxNn0gYXJpYS1oaWRkZW4gLz5cbiAgICAgICAgICA8L0ZsZXhCb3g+XG4gICAgICAgICl9XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG4pO1xuXG5JbnB1dC5kZWZhdWx0UHJvcHMgPSB7XG4gIHR5cGU6ICd0ZXh0Jyxcbn07XG4iXX0= */"));

var InputElement = _styled("input", {
  target: "e1ys3kqj0",
  label: "InputElement"
})(formFieldStyles, " ", conditionalStyles, " text-indent:0;padding-right:", function (props) {
  return props.icon ? "2.3rem" : "initial";
}, ";" + (process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9Gb3JtL0lucHV0LnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUEwRW1EIiwiZmlsZSI6Ii4uLy4uL3NyYy9Gb3JtL0lucHV0LnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFsZXJ0SWNvbiwgQ2hlY2tDaXJjbGVkSWNvbiB9IGZyb20gJ0Bjb2RlY2FkZW15L2dhbXV0LWljb25zJztcbmltcG9ydCB7IHN5c3RlbSB9IGZyb20gJ0Bjb2RlY2FkZW15L2dhbXV0LXN0eWxlcyc7XG5pbXBvcnQgc3R5bGVkLCB7IFN0eWxlZENvbXBvbmVudCB9IGZyb20gJ0BlbW90aW9uL3N0eWxlZCc7XG5pbXBvcnQgUmVhY3QsIHtcbiAgQ2hhbmdlRXZlbnQsXG4gIGZvcndhcmRSZWYsXG4gIElucHV0SFRNTEF0dHJpYnV0ZXMsXG4gIHVzZVN0YXRlLFxufSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7IEJveCwgRmxleEJveCB9IGZyb20gJy4uL0JveCc7XG5pbXBvcnQge1xuICBjb25kaXRpb25hbFN0eWxlUHJvcHMsXG4gIGNvbmRpdGlvbmFsU3R5bGVzLFxuICBjb25kaXRpb25hbFN0eWxlU3RhdGUsXG4gIGZvcm1CYXNlRmllbGRTdHlsZXMsXG4gIGZvcm1GaWVsZEZvY3VzU3R5bGVzLFxuICBmb3JtRmllbGRQYWRkaW5nU3R5bGVzLFxuICBmb3JtRmllbGRTdHlsZXMsXG59IGZyb20gJy4vc3R5bGVzL3NoYXJlZC1zeXN0ZW0tcHJvcHMnO1xuXG5leHBvcnQgdHlwZSBJbnB1dFByb3BzID0gSW5wdXRIVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50PiAmIHtcbiAgaWQ/OiBzdHJpbmc7XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbiAgZXJyb3I/OiBib29sZWFuO1xuICAvKipcbiAgICogW1RoZSBmb3IvaWQgc3RyaW5nIG9mIGEgbGFiZWwgb3IgbGFiZWxhYmxlIGZvcm0tcmVsYXRlZCBlbGVtZW50XShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTExhYmVsRWxlbWVudC9odG1sRm9yKS4gVGhlIG91dGVyIEZvcm1Hcm91cCBvciBGb3JtTGFiZWwgc2hvdWxkIGhhdmUgYW4gaWRlbnRpY2FsIHN0cmluZyBhcyB0aGUgaW5uZXIgRm9ybUVsZW1lbnQgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXG4gICAqL1xuICBodG1sRm9yPzogc3RyaW5nO1xuICBsYWJlbD86IHN0cmluZztcbiAgbmFtZT86IHN0cmluZztcbiAgcGxhY2Vob2xkZXI/OiBzdHJpbmc7XG4gIHJlcXVpcmVkPzogYm9vbGVhbjtcbiAgdHlwZT86IHN0cmluZztcbiAgdmFsaWQ/OiBib29sZWFuO1xuICAvKipcbiAgICogQWxsb3dzIElucHV0cyB0byBtYW5hZ2UgdGhlaXIgb3duIGFjdGl2YXRlZCBzdHlsZSBzdGF0ZSB0byBhY2NvdW50IGZvciBzb21lIGVkZ2UtY2FzZXMuXG4gICAqL1xuICBhY3RpdmF0ZWQ/OiBib29sZWFuO1xufTtcbmV4cG9ydCBpbnRlcmZhY2UgU3R5bGVkSW5wdXRQcm9wcyBleHRlbmRzIElucHV0UHJvcHMge1xuICBpY29uPzogYm9vbGVhbjtcbn1cblxuLypcbiAqIEByZW1hcmtzIFdlIHdvdWxkIGxvdmUgdG8gcHJvcGVybHkgdHlwZSB0aGlzIHdpdGggZ2VuZXJpY3MsIGJ1dCwgYWxhcywgd2UgY2Fubm90IHlldC5cbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL0NvZGVjYWRlbXkvY2xpZW50LW1vZHVsZXMvcHVsbC8yNzAjZGlzY3Vzc2lvbl9yMjcwOTE3MTQ3XG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMjEwNDhcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dFdyYXBwZXJQcm9wcyBleHRlbmRzIElucHV0UHJvcHMge1xuICBhcz86IFN0eWxlZENvbXBvbmVudDxTdHlsZWRJbnB1dFByb3BzLCBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjxhbnk+PjtcbiAgLyoqXG4gICAqIEEgY3VzdG9tIGljb24gc3ZnIGZyb20gZ2FtdXQtaWNvbnMuXG4gICAqL1xuICBpY29uPzogdHlwZW9mIEFsZXJ0SWNvbjtcbn1cblxuLyoqICBXZSBncmVhdGx5IHByZWZlciBOT1QgdG8gZG8gdGhpcyBidXQgUmVhY3RSZWN1cmx5IGhhcyBzb21lIHNwZWNpZmljIG5lZWRzIGFyb3VuZCBmb2N1cy1zdHlsZXMgKyBwYWRkaW5nIHRoYXQgZm9yY2UgdXMgdG8gZXhwb3J0IHRoZW0gc2VwZXJhdGVseS4gSWYgd2UgZXZlciBzdG9wIHVzaW5nIFJlYWN0LVJlY3VybHksIHRoaXMgY29kZSB3aWxsIGJlIPCflKouXG4gKnRsZHI6IERvIG5vdCBkbyB0aGlzIHVubGVzcyB5b3UgaGF2ZSBhbHJlYWR5IHRhbGtlZCB0byBXZWItUGxhdCBhbmQgaGF2ZSBmYWlsZWQgdG8gZmluZCBhbnkgYWx0ZXJuYXRlIChhbmQgYmV0dGVyKSBzb2x1dGlvbnMuICovXG5cbmV4cG9ydCBjb25zdCByZWFjdFJlY3VybHlGb3JtRmllbGRGb2N1c1N0eWxlcyA9IHN5c3RlbS5jc3MoXG4gIGZvcm1GaWVsZEZvY3VzU3R5bGVzXG4pO1xuXG5leHBvcnQgY29uc3QgcmVhY3RSZWN1cmx5Rm9ybUZpZWxkUGFkZGluZ1N0eWxlcyA9IHN5c3RlbS5jc3MoXG4gIGZvcm1GaWVsZFBhZGRpbmdTdHlsZXNcbik7XG5cbmV4cG9ydCBjb25zdCBpRnJhbWVXcmFwcGVyID0gc3R5bGVkLmRpdjxjb25kaXRpb25hbFN0eWxlUHJvcHM+YFxuICAke2Zvcm1CYXNlRmllbGRTdHlsZXN9XG4gICR7Y29uZGl0aW9uYWxTdHlsZXN9XG4gIHRleHQtaW5kZW50OiAwO1xuYDtcblxuY29uc3QgSW5wdXRFbGVtZW50ID0gc3R5bGVkLmlucHV0PFN0eWxlZElucHV0UHJvcHM+YFxuICAke2Zvcm1GaWVsZFN0eWxlc31cbiAgJHtjb25kaXRpb25hbFN0eWxlc31cbiAgdGV4dC1pbmRlbnQ6IDA7XG4gIHBhZGRpbmctcmlnaHQ6ICR7KHByb3BzKSA9PiAocHJvcHMuaWNvbiA/IGAyLjNyZW1gIDogYGluaXRpYWxgKX07XG5gO1xuXG5jb25zdCBpbnB1dFN0YXRlcyA9IHtcbiAgZXJyb3I6IHtcbiAgICBjb2xvcjogJ3JlZCcsXG4gICAgaWNvbjogQWxlcnRJY29uLFxuICB9LFxuICB2YWxpZDoge1xuICAgIGNvbG9yOiAnZ3JlZW4nLFxuICAgIGljb246IENoZWNrQ2lyY2xlZEljb24sXG4gIH0sXG4gIGNsZWFuOiB7XG4gICAgY29sb3I6ICdncmF5LTYwMCcsXG4gICAgaWNvbjogdW5kZWZpbmVkLFxuICB9LFxufSBhcyBjb25zdDtcblxuY29uc3QgZ2V0SW5wdXRTdGF0ZSA9IChlcnJvcjogYm9vbGVhbiwgdmFsaWQ6IGJvb2xlYW4pID0+IHtcbiAgaWYgKGVycm9yKSByZXR1cm4gJ2Vycm9yJztcbiAgaWYgKHZhbGlkKSByZXR1cm4gJ3ZhbGlkJztcbiAgcmV0dXJuICdjbGVhbic7XG59O1xuXG5leHBvcnQgY29uc3QgSW5wdXQgPSBmb3J3YXJkUmVmPEhUTUxJbnB1dEVsZW1lbnQsIElucHV0V3JhcHBlclByb3BzPihcbiAgKFxuICAgIHsgZXJyb3IsIGNsYXNzTmFtZSwgaWQsIHZhbGlkLCBhY3RpdmF0ZWQsIGFzOiBBcywgaWNvbjogSWNvbiwgLi4ucmVzdCB9LFxuICAgIHJlZlxuICApID0+IHtcbiAgICBjb25zdCBbYWN0aXZhdGVkU3R5bGUsIHNldEFjdGl2YXRlZFN0eWxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IHsgY29sb3IsIGljb24gfSA9IGlucHV0U3RhdGVzW1xuICAgICAgZ2V0SW5wdXRTdGF0ZShCb29sZWFuKGVycm9yKSwgQm9vbGVhbih2YWxpZCkpXG4gICAgXTtcblxuICAgIC8qXG4gICAgICogQHJlbWFya3MgV2Ugd291bGQgbG92ZSB0byBwcm9wZXJseSB0eXBlIHRoaXMgd2l0aCBnZW5lcmljcywgYnV0LCBhbGFzLCB3ZSBjYW5ub3QgeWV0LiBTZWUgY29tbWVudHMgb24gbGluZXMgNDUtNDcgZm9yIG1vcmUgZGV0YWlsLlxuICAgICAqL1xuXG4gICAgY29uc3QgY2hhbmdlSGFuZGxlciA9IChldmVudDogQ2hhbmdlRXZlbnQ8YW55PikgPT4ge1xuICAgICAgcmVzdD8ub25DaGFuZ2U/LihldmVudCk7XG4gICAgICBzZXRBY3RpdmF0ZWRTdHlsZSh0cnVlKTtcbiAgICB9O1xuXG4gICAgY29uc3QgQXNDb21wb25lbnQgPSBBcyB8fCBJbnB1dEVsZW1lbnQ7XG4gICAgY29uc3QgU2hvd25JY29uID0gSWNvbiB8fCBpY29uO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3hcbiAgICAgICAgZGlzcGxheT17cmVzdC50eXBlID09PSAnaGlkZGVuJyA/ICdub25lJyA6IHVuZGVmaW5lZH1cbiAgICAgICAgcG9zaXRpb249XCJyZWxhdGl2ZVwiXG4gICAgICAgIHRleHRDb2xvcj17Y29sb3J9XG4gICAgICA+XG4gICAgICAgIDxBc0NvbXBvbmVudFxuICAgICAgICAgIHsuLi5yZXN0fVxuICAgICAgICAgIGlkPXtpZCB8fCByZXN0Lmh0bWxGb3J9XG4gICAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgICAgdmFyaWFudD17Y29uZGl0aW9uYWxTdHlsZVN0YXRlKEJvb2xlYW4oZXJyb3IpLCBhY3RpdmF0ZWRTdHlsZSl9XG4gICAgICAgICAgaWNvbj17ZXJyb3IgfHwgdmFsaWQgfHwgISFJY29ufVxuICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3NOYW1lfVxuICAgICAgICAgIG9uQ2hhbmdlPXtjaGFuZ2VIYW5kbGVyfVxuICAgICAgICAvPlxuICAgICAgICB7ISFTaG93bkljb24gJiYgKFxuICAgICAgICAgIDxGbGV4Qm94XG4gICAgICAgICAgICBwcj17SWNvbiA/IDEyIDogMTZ9XG4gICAgICAgICAgICBwb3NpdGlvbj1cImFic29sdXRlXCJcbiAgICAgICAgICAgIGFsaWduSXRlbXM9XCJjZW50ZXJcIlxuICAgICAgICAgICAgcmlnaHQ9XCIwXCJcbiAgICAgICAgICAgIHRvcD1cIjBcIlxuICAgICAgICAgICAgYm90dG9tPVwiMFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPFNob3duSWNvbiBzaXplPXtJY29uID8gMjQgOiAxNn0gYXJpYS1oaWRkZW4gLz5cbiAgICAgICAgICA8L0ZsZXhCb3g+XG4gICAgICAgICl9XG4gICAgICA8L0JveD5cbiAgICApO1xuICB9XG4pO1xuXG5JbnB1dC5kZWZhdWx0UHJvcHMgPSB7XG4gIHR5cGU6ICd0ZXh0Jyxcbn07XG4iXX0= */"));

var inputStates = {
  error: {
    color: 'red',
    icon: AlertIcon
  },
  valid: {
    color: 'green',
    icon: CheckCircledIcon
  },
  clean: {
    color: 'gray-600',
    icon: undefined
  }
};

var getInputState = function getInputState(error, valid) {
  if (error) return 'error';
  if (valid) return 'valid';
  return 'clean';
};

export var Input = /*#__PURE__*/forwardRef(function Input(_ref, ref) {
  var error = _ref.error,
      className = _ref.className,
      id = _ref.id,
      valid = _ref.valid,
      activated = _ref.activated,
      As = _ref.as,
      Icon = _ref.icon,
      rest = _objectWithoutProperties(_ref, ["error", "className", "id", "valid", "activated", "as", "icon"]);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      activatedStyle = _useState2[0],
      setActivatedStyle = _useState2[1];

  var _inputStates$getInput = inputStates[getInputState(Boolean(error), Boolean(valid))],
      color = _inputStates$getInput.color,
      icon = _inputStates$getInput.icon;
  /*
   * @remarks We would love to properly type this with generics, but, alas, we cannot yet. See comments on lines 45-47 for more detail.
   */

  var changeHandler = function changeHandler(event) {
    var _rest$onChange;

    rest === null || rest === void 0 ? void 0 : (_rest$onChange = rest.onChange) === null || _rest$onChange === void 0 ? void 0 : _rest$onChange.call(rest, event);
    setActivatedStyle(true);
  };

  var AsComponent = As || InputElement;
  var ShownIcon = Icon || icon;
  return /*#__PURE__*/React.createElement(Box, {
    display: rest.type === 'hidden' ? 'none' : undefined,
    position: "relative",
    textColor: color
  }, /*#__PURE__*/React.createElement(AsComponent, _extends({}, rest, {
    id: id || rest.htmlFor,
    ref: ref,
    variant: conditionalStyleState(Boolean(error), activatedStyle),
    icon: error || valid || !!Icon,
    className: className,
    onChange: changeHandler
  })), !!ShownIcon && /*#__PURE__*/React.createElement(FlexBox, {
    pr: Icon ? 12 : 16,
    position: "absolute",
    alignItems: "center",
    right: "0",
    top: "0",
    bottom: "0"
  }, /*#__PURE__*/React.createElement(ShownIcon, {
    size: Icon ? 24 : 16,
    "aria-hidden": true
  })));
});
Input.defaultProps = {
  type: 'text'
};